// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"products-service/internal/app/ent/migrate"

	"products-service/internal/app/ent/brand"
	"products-service/internal/app/ent/category"
	"products-service/internal/app/ent/features"
	"products-service/internal/app/ent/featuresunitvalues"
	"products-service/internal/app/ent/featuresvalues"
	"products-service/internal/app/ent/featuresvaluestypes"
	"products-service/internal/app/ent/imagefolderpath"
	"products-service/internal/app/ent/imagefoldersource"
	"products-service/internal/app/ent/images"
	"products-service/internal/app/ent/infotypes"
	"products-service/internal/app/ent/pricetype"
	"products-service/internal/app/ent/producthasfeature"
	"products-service/internal/app/ent/producthasimage"
	"products-service/internal/app/ent/producthasinfo"
	"products-service/internal/app/ent/producthasproductreference"
	"products-service/internal/app/ent/productinfo"
	"products-service/internal/app/ent/productprices"
	"products-service/internal/app/ent/productreferences"
	"products-service/internal/app/ent/products"
	"products-service/internal/app/ent/promotionhasproduct"
	"products-service/internal/app/ent/promotions"
	"products-service/internal/app/ent/referencesources"
	"products-service/internal/app/ent/toolhasproduct"
	"products-service/internal/app/ent/tools"
	"products-service/internal/app/ent/user"
	"products-service/internal/app/ent/varianttype"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Brand is the client for interacting with the Brand builders.
	Brand *BrandClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Features is the client for interacting with the Features builders.
	Features *FeaturesClient
	// FeaturesUnitValues is the client for interacting with the FeaturesUnitValues builders.
	FeaturesUnitValues *FeaturesUnitValuesClient
	// FeaturesValues is the client for interacting with the FeaturesValues builders.
	FeaturesValues *FeaturesValuesClient
	// FeaturesValuesTypes is the client for interacting with the FeaturesValuesTypes builders.
	FeaturesValuesTypes *FeaturesValuesTypesClient
	// ImageFolderPath is the client for interacting with the ImageFolderPath builders.
	ImageFolderPath *ImageFolderPathClient
	// ImageFolderSource is the client for interacting with the ImageFolderSource builders.
	ImageFolderSource *ImageFolderSourceClient
	// Images is the client for interacting with the Images builders.
	Images *ImagesClient
	// InfoTypes is the client for interacting with the InfoTypes builders.
	InfoTypes *InfoTypesClient
	// PriceType is the client for interacting with the PriceType builders.
	PriceType *PriceTypeClient
	// ProductHasFeature is the client for interacting with the ProductHasFeature builders.
	ProductHasFeature *ProductHasFeatureClient
	// ProductHasImage is the client for interacting with the ProductHasImage builders.
	ProductHasImage *ProductHasImageClient
	// ProductHasInfo is the client for interacting with the ProductHasInfo builders.
	ProductHasInfo *ProductHasInfoClient
	// ProductHasProductReference is the client for interacting with the ProductHasProductReference builders.
	ProductHasProductReference *ProductHasProductReferenceClient
	// ProductInfo is the client for interacting with the ProductInfo builders.
	ProductInfo *ProductInfoClient
	// ProductPrices is the client for interacting with the ProductPrices builders.
	ProductPrices *ProductPricesClient
	// ProductReferences is the client for interacting with the ProductReferences builders.
	ProductReferences *ProductReferencesClient
	// Products is the client for interacting with the Products builders.
	Products *ProductsClient
	// PromotionHasProduct is the client for interacting with the PromotionHasProduct builders.
	PromotionHasProduct *PromotionHasProductClient
	// Promotions is the client for interacting with the Promotions builders.
	Promotions *PromotionsClient
	// ReferenceSources is the client for interacting with the ReferenceSources builders.
	ReferenceSources *ReferenceSourcesClient
	// ToolHasProduct is the client for interacting with the ToolHasProduct builders.
	ToolHasProduct *ToolHasProductClient
	// Tools is the client for interacting with the Tools builders.
	Tools *ToolsClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VariantType is the client for interacting with the VariantType builders.
	VariantType *VariantTypeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Brand = NewBrandClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Features = NewFeaturesClient(c.config)
	c.FeaturesUnitValues = NewFeaturesUnitValuesClient(c.config)
	c.FeaturesValues = NewFeaturesValuesClient(c.config)
	c.FeaturesValuesTypes = NewFeaturesValuesTypesClient(c.config)
	c.ImageFolderPath = NewImageFolderPathClient(c.config)
	c.ImageFolderSource = NewImageFolderSourceClient(c.config)
	c.Images = NewImagesClient(c.config)
	c.InfoTypes = NewInfoTypesClient(c.config)
	c.PriceType = NewPriceTypeClient(c.config)
	c.ProductHasFeature = NewProductHasFeatureClient(c.config)
	c.ProductHasImage = NewProductHasImageClient(c.config)
	c.ProductHasInfo = NewProductHasInfoClient(c.config)
	c.ProductHasProductReference = NewProductHasProductReferenceClient(c.config)
	c.ProductInfo = NewProductInfoClient(c.config)
	c.ProductPrices = NewProductPricesClient(c.config)
	c.ProductReferences = NewProductReferencesClient(c.config)
	c.Products = NewProductsClient(c.config)
	c.PromotionHasProduct = NewPromotionHasProductClient(c.config)
	c.Promotions = NewPromotionsClient(c.config)
	c.ReferenceSources = NewReferenceSourcesClient(c.config)
	c.ToolHasProduct = NewToolHasProductClient(c.config)
	c.Tools = NewToolsClient(c.config)
	c.User = NewUserClient(c.config)
	c.VariantType = NewVariantTypeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                        ctx,
		config:                     cfg,
		Brand:                      NewBrandClient(cfg),
		Category:                   NewCategoryClient(cfg),
		Features:                   NewFeaturesClient(cfg),
		FeaturesUnitValues:         NewFeaturesUnitValuesClient(cfg),
		FeaturesValues:             NewFeaturesValuesClient(cfg),
		FeaturesValuesTypes:        NewFeaturesValuesTypesClient(cfg),
		ImageFolderPath:            NewImageFolderPathClient(cfg),
		ImageFolderSource:          NewImageFolderSourceClient(cfg),
		Images:                     NewImagesClient(cfg),
		InfoTypes:                  NewInfoTypesClient(cfg),
		PriceType:                  NewPriceTypeClient(cfg),
		ProductHasFeature:          NewProductHasFeatureClient(cfg),
		ProductHasImage:            NewProductHasImageClient(cfg),
		ProductHasInfo:             NewProductHasInfoClient(cfg),
		ProductHasProductReference: NewProductHasProductReferenceClient(cfg),
		ProductInfo:                NewProductInfoClient(cfg),
		ProductPrices:              NewProductPricesClient(cfg),
		ProductReferences:          NewProductReferencesClient(cfg),
		Products:                   NewProductsClient(cfg),
		PromotionHasProduct:        NewPromotionHasProductClient(cfg),
		Promotions:                 NewPromotionsClient(cfg),
		ReferenceSources:           NewReferenceSourcesClient(cfg),
		ToolHasProduct:             NewToolHasProductClient(cfg),
		Tools:                      NewToolsClient(cfg),
		User:                       NewUserClient(cfg),
		VariantType:                NewVariantTypeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                        ctx,
		config:                     cfg,
		Brand:                      NewBrandClient(cfg),
		Category:                   NewCategoryClient(cfg),
		Features:                   NewFeaturesClient(cfg),
		FeaturesUnitValues:         NewFeaturesUnitValuesClient(cfg),
		FeaturesValues:             NewFeaturesValuesClient(cfg),
		FeaturesValuesTypes:        NewFeaturesValuesTypesClient(cfg),
		ImageFolderPath:            NewImageFolderPathClient(cfg),
		ImageFolderSource:          NewImageFolderSourceClient(cfg),
		Images:                     NewImagesClient(cfg),
		InfoTypes:                  NewInfoTypesClient(cfg),
		PriceType:                  NewPriceTypeClient(cfg),
		ProductHasFeature:          NewProductHasFeatureClient(cfg),
		ProductHasImage:            NewProductHasImageClient(cfg),
		ProductHasInfo:             NewProductHasInfoClient(cfg),
		ProductHasProductReference: NewProductHasProductReferenceClient(cfg),
		ProductInfo:                NewProductInfoClient(cfg),
		ProductPrices:              NewProductPricesClient(cfg),
		ProductReferences:          NewProductReferencesClient(cfg),
		Products:                   NewProductsClient(cfg),
		PromotionHasProduct:        NewPromotionHasProductClient(cfg),
		Promotions:                 NewPromotionsClient(cfg),
		ReferenceSources:           NewReferenceSourcesClient(cfg),
		ToolHasProduct:             NewToolHasProductClient(cfg),
		Tools:                      NewToolsClient(cfg),
		User:                       NewUserClient(cfg),
		VariantType:                NewVariantTypeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Brand.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Brand, c.Category, c.Features, c.FeaturesUnitValues, c.FeaturesValues,
		c.FeaturesValuesTypes, c.ImageFolderPath, c.ImageFolderSource, c.Images,
		c.InfoTypes, c.PriceType, c.ProductHasFeature, c.ProductHasImage,
		c.ProductHasInfo, c.ProductHasProductReference, c.ProductInfo, c.ProductPrices,
		c.ProductReferences, c.Products, c.PromotionHasProduct, c.Promotions,
		c.ReferenceSources, c.ToolHasProduct, c.Tools, c.User, c.VariantType,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Brand, c.Category, c.Features, c.FeaturesUnitValues, c.FeaturesValues,
		c.FeaturesValuesTypes, c.ImageFolderPath, c.ImageFolderSource, c.Images,
		c.InfoTypes, c.PriceType, c.ProductHasFeature, c.ProductHasImage,
		c.ProductHasInfo, c.ProductHasProductReference, c.ProductInfo, c.ProductPrices,
		c.ProductReferences, c.Products, c.PromotionHasProduct, c.Promotions,
		c.ReferenceSources, c.ToolHasProduct, c.Tools, c.User, c.VariantType,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BrandMutation:
		return c.Brand.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *FeaturesMutation:
		return c.Features.mutate(ctx, m)
	case *FeaturesUnitValuesMutation:
		return c.FeaturesUnitValues.mutate(ctx, m)
	case *FeaturesValuesMutation:
		return c.FeaturesValues.mutate(ctx, m)
	case *FeaturesValuesTypesMutation:
		return c.FeaturesValuesTypes.mutate(ctx, m)
	case *ImageFolderPathMutation:
		return c.ImageFolderPath.mutate(ctx, m)
	case *ImageFolderSourceMutation:
		return c.ImageFolderSource.mutate(ctx, m)
	case *ImagesMutation:
		return c.Images.mutate(ctx, m)
	case *InfoTypesMutation:
		return c.InfoTypes.mutate(ctx, m)
	case *PriceTypeMutation:
		return c.PriceType.mutate(ctx, m)
	case *ProductHasFeatureMutation:
		return c.ProductHasFeature.mutate(ctx, m)
	case *ProductHasImageMutation:
		return c.ProductHasImage.mutate(ctx, m)
	case *ProductHasInfoMutation:
		return c.ProductHasInfo.mutate(ctx, m)
	case *ProductHasProductReferenceMutation:
		return c.ProductHasProductReference.mutate(ctx, m)
	case *ProductInfoMutation:
		return c.ProductInfo.mutate(ctx, m)
	case *ProductPricesMutation:
		return c.ProductPrices.mutate(ctx, m)
	case *ProductReferencesMutation:
		return c.ProductReferences.mutate(ctx, m)
	case *ProductsMutation:
		return c.Products.mutate(ctx, m)
	case *PromotionHasProductMutation:
		return c.PromotionHasProduct.mutate(ctx, m)
	case *PromotionsMutation:
		return c.Promotions.mutate(ctx, m)
	case *ReferenceSourcesMutation:
		return c.ReferenceSources.mutate(ctx, m)
	case *ToolHasProductMutation:
		return c.ToolHasProduct.mutate(ctx, m)
	case *ToolsMutation:
		return c.Tools.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VariantTypeMutation:
		return c.VariantType.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BrandClient is a client for the Brand schema.
type BrandClient struct {
	config
}

// NewBrandClient returns a client for the Brand from the given config.
func NewBrandClient(c config) *BrandClient {
	return &BrandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `brand.Hooks(f(g(h())))`.
func (c *BrandClient) Use(hooks ...Hook) {
	c.hooks.Brand = append(c.hooks.Brand, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `brand.Intercept(f(g(h())))`.
func (c *BrandClient) Intercept(interceptors ...Interceptor) {
	c.inters.Brand = append(c.inters.Brand, interceptors...)
}

// Create returns a builder for creating a Brand entity.
func (c *BrandClient) Create() *BrandCreate {
	mutation := newBrandMutation(c.config, OpCreate)
	return &BrandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Brand entities.
func (c *BrandClient) CreateBulk(builders ...*BrandCreate) *BrandCreateBulk {
	return &BrandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BrandClient) MapCreateBulk(slice any, setFunc func(*BrandCreate, int)) *BrandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BrandCreateBulk{err: fmt.Errorf("calling to BrandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BrandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BrandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Brand.
func (c *BrandClient) Update() *BrandUpdate {
	mutation := newBrandMutation(c.config, OpUpdate)
	return &BrandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrandClient) UpdateOne(b *Brand) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrand(b))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrandClient) UpdateOneID(id int) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrandID(id))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Brand.
func (c *BrandClient) Delete() *BrandDelete {
	mutation := newBrandMutation(c.config, OpDelete)
	return &BrandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BrandClient) DeleteOne(b *Brand) *BrandDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BrandClient) DeleteOneID(id int) *BrandDeleteOne {
	builder := c.Delete().Where(brand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrandDeleteOne{builder}
}

// Query returns a query builder for Brand.
func (c *BrandClient) Query() *BrandQuery {
	return &BrandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBrand},
		inters: c.Interceptors(),
	}
}

// Get returns a Brand entity by its id.
func (c *BrandClient) Get(ctx context.Context, id int) (*Brand, error) {
	return c.Query().Where(brand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrandClient) GetX(ctx context.Context, id int) *Brand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Brand.
func (c *BrandClient) QueryProducts(b *Brand) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, brand.ProductsTable, brand.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BrandClient) Hooks() []Hook {
	return c.hooks.Brand
}

// Interceptors returns the client interceptors.
func (c *BrandClient) Interceptors() []Interceptor {
	return c.inters.Brand
}

func (c *BrandClient) mutate(ctx context.Context, m *BrandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BrandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BrandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BrandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Brand mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Category.
func (c *CategoryClient) QueryProducts(ca *Category) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.ProductsTable, category.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Category.
func (c *CategoryClient) QueryParent(ca *Category) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, category.ParentTable, category.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Category.
func (c *CategoryClient) QueryChildren(ca *Category) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.ChildrenTable, category.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// FeaturesClient is a client for the Features schema.
type FeaturesClient struct {
	config
}

// NewFeaturesClient returns a client for the Features from the given config.
func NewFeaturesClient(c config) *FeaturesClient {
	return &FeaturesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `features.Hooks(f(g(h())))`.
func (c *FeaturesClient) Use(hooks ...Hook) {
	c.hooks.Features = append(c.hooks.Features, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `features.Intercept(f(g(h())))`.
func (c *FeaturesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Features = append(c.inters.Features, interceptors...)
}

// Create returns a builder for creating a Features entity.
func (c *FeaturesClient) Create() *FeaturesCreate {
	mutation := newFeaturesMutation(c.config, OpCreate)
	return &FeaturesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Features entities.
func (c *FeaturesClient) CreateBulk(builders ...*FeaturesCreate) *FeaturesCreateBulk {
	return &FeaturesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeaturesClient) MapCreateBulk(slice any, setFunc func(*FeaturesCreate, int)) *FeaturesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeaturesCreateBulk{err: fmt.Errorf("calling to FeaturesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeaturesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeaturesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Features.
func (c *FeaturesClient) Update() *FeaturesUpdate {
	mutation := newFeaturesMutation(c.config, OpUpdate)
	return &FeaturesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeaturesClient) UpdateOne(f *Features) *FeaturesUpdateOne {
	mutation := newFeaturesMutation(c.config, OpUpdateOne, withFeatures(f))
	return &FeaturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeaturesClient) UpdateOneID(id int) *FeaturesUpdateOne {
	mutation := newFeaturesMutation(c.config, OpUpdateOne, withFeaturesID(id))
	return &FeaturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Features.
func (c *FeaturesClient) Delete() *FeaturesDelete {
	mutation := newFeaturesMutation(c.config, OpDelete)
	return &FeaturesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeaturesClient) DeleteOne(f *Features) *FeaturesDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeaturesClient) DeleteOneID(id int) *FeaturesDeleteOne {
	builder := c.Delete().Where(features.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeaturesDeleteOne{builder}
}

// Query returns a query builder for Features.
func (c *FeaturesClient) Query() *FeaturesQuery {
	return &FeaturesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeatures},
		inters: c.Interceptors(),
	}
}

// Get returns a Features entity by its id.
func (c *FeaturesClient) Get(ctx context.Context, id int) (*Features, error) {
	return c.Query().Where(features.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeaturesClient) GetX(ctx context.Context, id int) *Features {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFeatureValues queries the feature_values edge of a Features.
func (c *FeaturesClient) QueryFeatureValues(f *Features) *FeaturesValuesQuery {
	query := (&FeaturesValuesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(features.Table, features.FieldID, id),
			sqlgraph.To(featuresvalues.Table, featuresvalues.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, features.FeatureValuesTable, features.FeatureValuesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasFeature queries the product_has_feature edge of a Features.
func (c *FeaturesClient) QueryProductHasFeature(f *Features) *ProductHasFeatureQuery {
	query := (&ProductHasFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(features.Table, features.FieldID, id),
			sqlgraph.To(producthasfeature.Table, producthasfeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, features.ProductHasFeatureTable, features.ProductHasFeatureColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeaturesClient) Hooks() []Hook {
	return c.hooks.Features
}

// Interceptors returns the client interceptors.
func (c *FeaturesClient) Interceptors() []Interceptor {
	return c.inters.Features
}

func (c *FeaturesClient) mutate(ctx context.Context, m *FeaturesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeaturesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeaturesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeaturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeaturesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Features mutation op: %q", m.Op())
	}
}

// FeaturesUnitValuesClient is a client for the FeaturesUnitValues schema.
type FeaturesUnitValuesClient struct {
	config
}

// NewFeaturesUnitValuesClient returns a client for the FeaturesUnitValues from the given config.
func NewFeaturesUnitValuesClient(c config) *FeaturesUnitValuesClient {
	return &FeaturesUnitValuesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featuresunitvalues.Hooks(f(g(h())))`.
func (c *FeaturesUnitValuesClient) Use(hooks ...Hook) {
	c.hooks.FeaturesUnitValues = append(c.hooks.FeaturesUnitValues, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featuresunitvalues.Intercept(f(g(h())))`.
func (c *FeaturesUnitValuesClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeaturesUnitValues = append(c.inters.FeaturesUnitValues, interceptors...)
}

// Create returns a builder for creating a FeaturesUnitValues entity.
func (c *FeaturesUnitValuesClient) Create() *FeaturesUnitValuesCreate {
	mutation := newFeaturesUnitValuesMutation(c.config, OpCreate)
	return &FeaturesUnitValuesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeaturesUnitValues entities.
func (c *FeaturesUnitValuesClient) CreateBulk(builders ...*FeaturesUnitValuesCreate) *FeaturesUnitValuesCreateBulk {
	return &FeaturesUnitValuesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeaturesUnitValuesClient) MapCreateBulk(slice any, setFunc func(*FeaturesUnitValuesCreate, int)) *FeaturesUnitValuesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeaturesUnitValuesCreateBulk{err: fmt.Errorf("calling to FeaturesUnitValuesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeaturesUnitValuesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeaturesUnitValuesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeaturesUnitValues.
func (c *FeaturesUnitValuesClient) Update() *FeaturesUnitValuesUpdate {
	mutation := newFeaturesUnitValuesMutation(c.config, OpUpdate)
	return &FeaturesUnitValuesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeaturesUnitValuesClient) UpdateOne(fuv *FeaturesUnitValues) *FeaturesUnitValuesUpdateOne {
	mutation := newFeaturesUnitValuesMutation(c.config, OpUpdateOne, withFeaturesUnitValues(fuv))
	return &FeaturesUnitValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeaturesUnitValuesClient) UpdateOneID(id int) *FeaturesUnitValuesUpdateOne {
	mutation := newFeaturesUnitValuesMutation(c.config, OpUpdateOne, withFeaturesUnitValuesID(id))
	return &FeaturesUnitValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeaturesUnitValues.
func (c *FeaturesUnitValuesClient) Delete() *FeaturesUnitValuesDelete {
	mutation := newFeaturesUnitValuesMutation(c.config, OpDelete)
	return &FeaturesUnitValuesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeaturesUnitValuesClient) DeleteOne(fuv *FeaturesUnitValues) *FeaturesUnitValuesDeleteOne {
	return c.DeleteOneID(fuv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeaturesUnitValuesClient) DeleteOneID(id int) *FeaturesUnitValuesDeleteOne {
	builder := c.Delete().Where(featuresunitvalues.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeaturesUnitValuesDeleteOne{builder}
}

// Query returns a query builder for FeaturesUnitValues.
func (c *FeaturesUnitValuesClient) Query() *FeaturesUnitValuesQuery {
	return &FeaturesUnitValuesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeaturesUnitValues},
		inters: c.Interceptors(),
	}
}

// Get returns a FeaturesUnitValues entity by its id.
func (c *FeaturesUnitValuesClient) Get(ctx context.Context, id int) (*FeaturesUnitValues, error) {
	return c.Query().Where(featuresunitvalues.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeaturesUnitValuesClient) GetX(ctx context.Context, id int) *FeaturesUnitValues {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFeatureValues queries the feature_values edge of a FeaturesUnitValues.
func (c *FeaturesUnitValuesClient) QueryFeatureValues(fuv *FeaturesUnitValues) *FeaturesValuesQuery {
	query := (&FeaturesValuesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fuv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(featuresunitvalues.Table, featuresunitvalues.FieldID, id),
			sqlgraph.To(featuresvalues.Table, featuresvalues.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, featuresunitvalues.FeatureValuesTable, featuresunitvalues.FeatureValuesColumn),
		)
		fromV = sqlgraph.Neighbors(fuv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeaturesUnitValuesClient) Hooks() []Hook {
	return c.hooks.FeaturesUnitValues
}

// Interceptors returns the client interceptors.
func (c *FeaturesUnitValuesClient) Interceptors() []Interceptor {
	return c.inters.FeaturesUnitValues
}

func (c *FeaturesUnitValuesClient) mutate(ctx context.Context, m *FeaturesUnitValuesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeaturesUnitValuesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeaturesUnitValuesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeaturesUnitValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeaturesUnitValuesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeaturesUnitValues mutation op: %q", m.Op())
	}
}

// FeaturesValuesClient is a client for the FeaturesValues schema.
type FeaturesValuesClient struct {
	config
}

// NewFeaturesValuesClient returns a client for the FeaturesValues from the given config.
func NewFeaturesValuesClient(c config) *FeaturesValuesClient {
	return &FeaturesValuesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featuresvalues.Hooks(f(g(h())))`.
func (c *FeaturesValuesClient) Use(hooks ...Hook) {
	c.hooks.FeaturesValues = append(c.hooks.FeaturesValues, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featuresvalues.Intercept(f(g(h())))`.
func (c *FeaturesValuesClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeaturesValues = append(c.inters.FeaturesValues, interceptors...)
}

// Create returns a builder for creating a FeaturesValues entity.
func (c *FeaturesValuesClient) Create() *FeaturesValuesCreate {
	mutation := newFeaturesValuesMutation(c.config, OpCreate)
	return &FeaturesValuesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeaturesValues entities.
func (c *FeaturesValuesClient) CreateBulk(builders ...*FeaturesValuesCreate) *FeaturesValuesCreateBulk {
	return &FeaturesValuesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeaturesValuesClient) MapCreateBulk(slice any, setFunc func(*FeaturesValuesCreate, int)) *FeaturesValuesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeaturesValuesCreateBulk{err: fmt.Errorf("calling to FeaturesValuesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeaturesValuesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeaturesValuesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeaturesValues.
func (c *FeaturesValuesClient) Update() *FeaturesValuesUpdate {
	mutation := newFeaturesValuesMutation(c.config, OpUpdate)
	return &FeaturesValuesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeaturesValuesClient) UpdateOne(fv *FeaturesValues) *FeaturesValuesUpdateOne {
	mutation := newFeaturesValuesMutation(c.config, OpUpdateOne, withFeaturesValues(fv))
	return &FeaturesValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeaturesValuesClient) UpdateOneID(id int) *FeaturesValuesUpdateOne {
	mutation := newFeaturesValuesMutation(c.config, OpUpdateOne, withFeaturesValuesID(id))
	return &FeaturesValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeaturesValues.
func (c *FeaturesValuesClient) Delete() *FeaturesValuesDelete {
	mutation := newFeaturesValuesMutation(c.config, OpDelete)
	return &FeaturesValuesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeaturesValuesClient) DeleteOne(fv *FeaturesValues) *FeaturesValuesDeleteOne {
	return c.DeleteOneID(fv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeaturesValuesClient) DeleteOneID(id int) *FeaturesValuesDeleteOne {
	builder := c.Delete().Where(featuresvalues.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeaturesValuesDeleteOne{builder}
}

// Query returns a query builder for FeaturesValues.
func (c *FeaturesValuesClient) Query() *FeaturesValuesQuery {
	return &FeaturesValuesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeaturesValues},
		inters: c.Interceptors(),
	}
}

// Get returns a FeaturesValues entity by its id.
func (c *FeaturesValuesClient) Get(ctx context.Context, id int) (*FeaturesValues, error) {
	return c.Query().Where(featuresvalues.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeaturesValuesClient) GetX(ctx context.Context, id int) *FeaturesValues {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFeature queries the feature edge of a FeaturesValues.
func (c *FeaturesValuesClient) QueryFeature(fv *FeaturesValues) *FeaturesQuery {
	query := (&FeaturesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(featuresvalues.Table, featuresvalues.FieldID, id),
			sqlgraph.To(features.Table, features.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, featuresvalues.FeatureTable, featuresvalues.FeatureColumn),
		)
		fromV = sqlgraph.Neighbors(fv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatureUnitValues queries the feature_unit_values edge of a FeaturesValues.
func (c *FeaturesValuesClient) QueryFeatureUnitValues(fv *FeaturesValues) *FeaturesUnitValuesQuery {
	query := (&FeaturesUnitValuesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(featuresvalues.Table, featuresvalues.FieldID, id),
			sqlgraph.To(featuresunitvalues.Table, featuresunitvalues.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, featuresvalues.FeatureUnitValuesTable, featuresvalues.FeatureUnitValuesColumn),
		)
		fromV = sqlgraph.Neighbors(fv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeaturesValuesClient) Hooks() []Hook {
	return c.hooks.FeaturesValues
}

// Interceptors returns the client interceptors.
func (c *FeaturesValuesClient) Interceptors() []Interceptor {
	return c.inters.FeaturesValues
}

func (c *FeaturesValuesClient) mutate(ctx context.Context, m *FeaturesValuesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeaturesValuesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeaturesValuesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeaturesValuesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeaturesValuesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeaturesValues mutation op: %q", m.Op())
	}
}

// FeaturesValuesTypesClient is a client for the FeaturesValuesTypes schema.
type FeaturesValuesTypesClient struct {
	config
}

// NewFeaturesValuesTypesClient returns a client for the FeaturesValuesTypes from the given config.
func NewFeaturesValuesTypesClient(c config) *FeaturesValuesTypesClient {
	return &FeaturesValuesTypesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featuresvaluestypes.Hooks(f(g(h())))`.
func (c *FeaturesValuesTypesClient) Use(hooks ...Hook) {
	c.hooks.FeaturesValuesTypes = append(c.hooks.FeaturesValuesTypes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featuresvaluestypes.Intercept(f(g(h())))`.
func (c *FeaturesValuesTypesClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeaturesValuesTypes = append(c.inters.FeaturesValuesTypes, interceptors...)
}

// Create returns a builder for creating a FeaturesValuesTypes entity.
func (c *FeaturesValuesTypesClient) Create() *FeaturesValuesTypesCreate {
	mutation := newFeaturesValuesTypesMutation(c.config, OpCreate)
	return &FeaturesValuesTypesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeaturesValuesTypes entities.
func (c *FeaturesValuesTypesClient) CreateBulk(builders ...*FeaturesValuesTypesCreate) *FeaturesValuesTypesCreateBulk {
	return &FeaturesValuesTypesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeaturesValuesTypesClient) MapCreateBulk(slice any, setFunc func(*FeaturesValuesTypesCreate, int)) *FeaturesValuesTypesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeaturesValuesTypesCreateBulk{err: fmt.Errorf("calling to FeaturesValuesTypesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeaturesValuesTypesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeaturesValuesTypesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeaturesValuesTypes.
func (c *FeaturesValuesTypesClient) Update() *FeaturesValuesTypesUpdate {
	mutation := newFeaturesValuesTypesMutation(c.config, OpUpdate)
	return &FeaturesValuesTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeaturesValuesTypesClient) UpdateOne(fvt *FeaturesValuesTypes) *FeaturesValuesTypesUpdateOne {
	mutation := newFeaturesValuesTypesMutation(c.config, OpUpdateOne, withFeaturesValuesTypes(fvt))
	return &FeaturesValuesTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeaturesValuesTypesClient) UpdateOneID(id int) *FeaturesValuesTypesUpdateOne {
	mutation := newFeaturesValuesTypesMutation(c.config, OpUpdateOne, withFeaturesValuesTypesID(id))
	return &FeaturesValuesTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeaturesValuesTypes.
func (c *FeaturesValuesTypesClient) Delete() *FeaturesValuesTypesDelete {
	mutation := newFeaturesValuesTypesMutation(c.config, OpDelete)
	return &FeaturesValuesTypesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeaturesValuesTypesClient) DeleteOne(fvt *FeaturesValuesTypes) *FeaturesValuesTypesDeleteOne {
	return c.DeleteOneID(fvt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeaturesValuesTypesClient) DeleteOneID(id int) *FeaturesValuesTypesDeleteOne {
	builder := c.Delete().Where(featuresvaluestypes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeaturesValuesTypesDeleteOne{builder}
}

// Query returns a query builder for FeaturesValuesTypes.
func (c *FeaturesValuesTypesClient) Query() *FeaturesValuesTypesQuery {
	return &FeaturesValuesTypesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeaturesValuesTypes},
		inters: c.Interceptors(),
	}
}

// Get returns a FeaturesValuesTypes entity by its id.
func (c *FeaturesValuesTypesClient) Get(ctx context.Context, id int) (*FeaturesValuesTypes, error) {
	return c.Query().Where(featuresvaluestypes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeaturesValuesTypesClient) GetX(ctx context.Context, id int) *FeaturesValuesTypes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductInfo queries the product_info edge of a FeaturesValuesTypes.
func (c *FeaturesValuesTypesClient) QueryProductInfo(fvt *FeaturesValuesTypes) *ProductInfoQuery {
	query := (&ProductInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fvt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(featuresvaluestypes.Table, featuresvaluestypes.FieldID, id),
			sqlgraph.To(productinfo.Table, productinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, featuresvaluestypes.ProductInfoTable, featuresvaluestypes.ProductInfoColumn),
		)
		fromV = sqlgraph.Neighbors(fvt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatureValues queries the feature_values edge of a FeaturesValuesTypes.
func (c *FeaturesValuesTypesClient) QueryFeatureValues(fvt *FeaturesValuesTypes) *FeaturesValuesQuery {
	query := (&FeaturesValuesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fvt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(featuresvaluestypes.Table, featuresvaluestypes.FieldID, id),
			sqlgraph.To(featuresvalues.Table, featuresvalues.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, featuresvaluestypes.FeatureValuesTable, featuresvaluestypes.FeatureValuesColumn),
		)
		fromV = sqlgraph.Neighbors(fvt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeaturesValuesTypesClient) Hooks() []Hook {
	return c.hooks.FeaturesValuesTypes
}

// Interceptors returns the client interceptors.
func (c *FeaturesValuesTypesClient) Interceptors() []Interceptor {
	return c.inters.FeaturesValuesTypes
}

func (c *FeaturesValuesTypesClient) mutate(ctx context.Context, m *FeaturesValuesTypesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeaturesValuesTypesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeaturesValuesTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeaturesValuesTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeaturesValuesTypesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeaturesValuesTypes mutation op: %q", m.Op())
	}
}

// ImageFolderPathClient is a client for the ImageFolderPath schema.
type ImageFolderPathClient struct {
	config
}

// NewImageFolderPathClient returns a client for the ImageFolderPath from the given config.
func NewImageFolderPathClient(c config) *ImageFolderPathClient {
	return &ImageFolderPathClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `imagefolderpath.Hooks(f(g(h())))`.
func (c *ImageFolderPathClient) Use(hooks ...Hook) {
	c.hooks.ImageFolderPath = append(c.hooks.ImageFolderPath, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `imagefolderpath.Intercept(f(g(h())))`.
func (c *ImageFolderPathClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImageFolderPath = append(c.inters.ImageFolderPath, interceptors...)
}

// Create returns a builder for creating a ImageFolderPath entity.
func (c *ImageFolderPathClient) Create() *ImageFolderPathCreate {
	mutation := newImageFolderPathMutation(c.config, OpCreate)
	return &ImageFolderPathCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImageFolderPath entities.
func (c *ImageFolderPathClient) CreateBulk(builders ...*ImageFolderPathCreate) *ImageFolderPathCreateBulk {
	return &ImageFolderPathCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImageFolderPathClient) MapCreateBulk(slice any, setFunc func(*ImageFolderPathCreate, int)) *ImageFolderPathCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImageFolderPathCreateBulk{err: fmt.Errorf("calling to ImageFolderPathClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImageFolderPathCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImageFolderPathCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImageFolderPath.
func (c *ImageFolderPathClient) Update() *ImageFolderPathUpdate {
	mutation := newImageFolderPathMutation(c.config, OpUpdate)
	return &ImageFolderPathUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImageFolderPathClient) UpdateOne(ifp *ImageFolderPath) *ImageFolderPathUpdateOne {
	mutation := newImageFolderPathMutation(c.config, OpUpdateOne, withImageFolderPath(ifp))
	return &ImageFolderPathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImageFolderPathClient) UpdateOneID(id int) *ImageFolderPathUpdateOne {
	mutation := newImageFolderPathMutation(c.config, OpUpdateOne, withImageFolderPathID(id))
	return &ImageFolderPathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImageFolderPath.
func (c *ImageFolderPathClient) Delete() *ImageFolderPathDelete {
	mutation := newImageFolderPathMutation(c.config, OpDelete)
	return &ImageFolderPathDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImageFolderPathClient) DeleteOne(ifp *ImageFolderPath) *ImageFolderPathDeleteOne {
	return c.DeleteOneID(ifp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImageFolderPathClient) DeleteOneID(id int) *ImageFolderPathDeleteOne {
	builder := c.Delete().Where(imagefolderpath.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImageFolderPathDeleteOne{builder}
}

// Query returns a query builder for ImageFolderPath.
func (c *ImageFolderPathClient) Query() *ImageFolderPathQuery {
	return &ImageFolderPathQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImageFolderPath},
		inters: c.Interceptors(),
	}
}

// Get returns a ImageFolderPath entity by its id.
func (c *ImageFolderPathClient) Get(ctx context.Context, id int) (*ImageFolderPath, error) {
	return c.Query().Where(imagefolderpath.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImageFolderPathClient) GetX(ctx context.Context, id int) *ImageFolderPath {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImageFolderSource queries the image_folder_source edge of a ImageFolderPath.
func (c *ImageFolderPathClient) QueryImageFolderSource(ifp *ImageFolderPath) *ImageFolderSourceQuery {
	query := (&ImageFolderSourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(imagefolderpath.Table, imagefolderpath.FieldID, id),
			sqlgraph.To(imagefoldersource.Table, imagefoldersource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, imagefolderpath.ImageFolderSourceTable, imagefolderpath.ImageFolderSourceColumn),
		)
		fromV = sqlgraph.Neighbors(ifp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a ImageFolderPath.
func (c *ImageFolderPathClient) QueryImages(ifp *ImageFolderPath) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(imagefolderpath.Table, imagefolderpath.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, imagefolderpath.ImagesTable, imagefolderpath.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(ifp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImageFolderPathClient) Hooks() []Hook {
	return c.hooks.ImageFolderPath
}

// Interceptors returns the client interceptors.
func (c *ImageFolderPathClient) Interceptors() []Interceptor {
	return c.inters.ImageFolderPath
}

func (c *ImageFolderPathClient) mutate(ctx context.Context, m *ImageFolderPathMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImageFolderPathCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImageFolderPathUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImageFolderPathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImageFolderPathDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImageFolderPath mutation op: %q", m.Op())
	}
}

// ImageFolderSourceClient is a client for the ImageFolderSource schema.
type ImageFolderSourceClient struct {
	config
}

// NewImageFolderSourceClient returns a client for the ImageFolderSource from the given config.
func NewImageFolderSourceClient(c config) *ImageFolderSourceClient {
	return &ImageFolderSourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `imagefoldersource.Hooks(f(g(h())))`.
func (c *ImageFolderSourceClient) Use(hooks ...Hook) {
	c.hooks.ImageFolderSource = append(c.hooks.ImageFolderSource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `imagefoldersource.Intercept(f(g(h())))`.
func (c *ImageFolderSourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImageFolderSource = append(c.inters.ImageFolderSource, interceptors...)
}

// Create returns a builder for creating a ImageFolderSource entity.
func (c *ImageFolderSourceClient) Create() *ImageFolderSourceCreate {
	mutation := newImageFolderSourceMutation(c.config, OpCreate)
	return &ImageFolderSourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImageFolderSource entities.
func (c *ImageFolderSourceClient) CreateBulk(builders ...*ImageFolderSourceCreate) *ImageFolderSourceCreateBulk {
	return &ImageFolderSourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImageFolderSourceClient) MapCreateBulk(slice any, setFunc func(*ImageFolderSourceCreate, int)) *ImageFolderSourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImageFolderSourceCreateBulk{err: fmt.Errorf("calling to ImageFolderSourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImageFolderSourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImageFolderSourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImageFolderSource.
func (c *ImageFolderSourceClient) Update() *ImageFolderSourceUpdate {
	mutation := newImageFolderSourceMutation(c.config, OpUpdate)
	return &ImageFolderSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImageFolderSourceClient) UpdateOne(ifs *ImageFolderSource) *ImageFolderSourceUpdateOne {
	mutation := newImageFolderSourceMutation(c.config, OpUpdateOne, withImageFolderSource(ifs))
	return &ImageFolderSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImageFolderSourceClient) UpdateOneID(id int) *ImageFolderSourceUpdateOne {
	mutation := newImageFolderSourceMutation(c.config, OpUpdateOne, withImageFolderSourceID(id))
	return &ImageFolderSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImageFolderSource.
func (c *ImageFolderSourceClient) Delete() *ImageFolderSourceDelete {
	mutation := newImageFolderSourceMutation(c.config, OpDelete)
	return &ImageFolderSourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImageFolderSourceClient) DeleteOne(ifs *ImageFolderSource) *ImageFolderSourceDeleteOne {
	return c.DeleteOneID(ifs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImageFolderSourceClient) DeleteOneID(id int) *ImageFolderSourceDeleteOne {
	builder := c.Delete().Where(imagefoldersource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImageFolderSourceDeleteOne{builder}
}

// Query returns a query builder for ImageFolderSource.
func (c *ImageFolderSourceClient) Query() *ImageFolderSourceQuery {
	return &ImageFolderSourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImageFolderSource},
		inters: c.Interceptors(),
	}
}

// Get returns a ImageFolderSource entity by its id.
func (c *ImageFolderSourceClient) Get(ctx context.Context, id int) (*ImageFolderSource, error) {
	return c.Query().Where(imagefoldersource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImageFolderSourceClient) GetX(ctx context.Context, id int) *ImageFolderSource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImageFolderPath queries the image_folder_path edge of a ImageFolderSource.
func (c *ImageFolderSourceClient) QueryImageFolderPath(ifs *ImageFolderSource) *ImageFolderPathQuery {
	query := (&ImageFolderPathClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(imagefoldersource.Table, imagefoldersource.FieldID, id),
			sqlgraph.To(imagefolderpath.Table, imagefolderpath.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, imagefoldersource.ImageFolderPathTable, imagefoldersource.ImageFolderPathColumn),
		)
		fromV = sqlgraph.Neighbors(ifs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImageFolderSourceClient) Hooks() []Hook {
	return c.hooks.ImageFolderSource
}

// Interceptors returns the client interceptors.
func (c *ImageFolderSourceClient) Interceptors() []Interceptor {
	return c.inters.ImageFolderSource
}

func (c *ImageFolderSourceClient) mutate(ctx context.Context, m *ImageFolderSourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImageFolderSourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImageFolderSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImageFolderSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImageFolderSourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImageFolderSource mutation op: %q", m.Op())
	}
}

// ImagesClient is a client for the Images schema.
type ImagesClient struct {
	config
}

// NewImagesClient returns a client for the Images from the given config.
func NewImagesClient(c config) *ImagesClient {
	return &ImagesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `images.Hooks(f(g(h())))`.
func (c *ImagesClient) Use(hooks ...Hook) {
	c.hooks.Images = append(c.hooks.Images, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `images.Intercept(f(g(h())))`.
func (c *ImagesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Images = append(c.inters.Images, interceptors...)
}

// Create returns a builder for creating a Images entity.
func (c *ImagesClient) Create() *ImagesCreate {
	mutation := newImagesMutation(c.config, OpCreate)
	return &ImagesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Images entities.
func (c *ImagesClient) CreateBulk(builders ...*ImagesCreate) *ImagesCreateBulk {
	return &ImagesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImagesClient) MapCreateBulk(slice any, setFunc func(*ImagesCreate, int)) *ImagesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImagesCreateBulk{err: fmt.Errorf("calling to ImagesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImagesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImagesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Images.
func (c *ImagesClient) Update() *ImagesUpdate {
	mutation := newImagesMutation(c.config, OpUpdate)
	return &ImagesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImagesClient) UpdateOne(i *Images) *ImagesUpdateOne {
	mutation := newImagesMutation(c.config, OpUpdateOne, withImages(i))
	return &ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImagesClient) UpdateOneID(id int) *ImagesUpdateOne {
	mutation := newImagesMutation(c.config, OpUpdateOne, withImagesID(id))
	return &ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Images.
func (c *ImagesClient) Delete() *ImagesDelete {
	mutation := newImagesMutation(c.config, OpDelete)
	return &ImagesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImagesClient) DeleteOne(i *Images) *ImagesDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImagesClient) DeleteOneID(id int) *ImagesDeleteOne {
	builder := c.Delete().Where(images.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImagesDeleteOne{builder}
}

// Query returns a query builder for Images.
func (c *ImagesClient) Query() *ImagesQuery {
	return &ImagesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImages},
		inters: c.Interceptors(),
	}
}

// Get returns a Images entity by its id.
func (c *ImagesClient) Get(ctx context.Context, id int) (*Images, error) {
	return c.Query().Where(images.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImagesClient) GetX(ctx context.Context, id int) *Images {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImageFolderPath queries the image_folder_path edge of a Images.
func (c *ImagesClient) QueryImageFolderPath(i *Images) *ImageFolderPathQuery {
	query := (&ImageFolderPathClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(images.Table, images.FieldID, id),
			sqlgraph.To(imagefolderpath.Table, imagefolderpath.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, images.ImageFolderPathTable, images.ImageFolderPathColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasImage queries the product_has_image edge of a Images.
func (c *ImagesClient) QueryProductHasImage(i *Images) *ProductHasImageQuery {
	query := (&ProductHasImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(images.Table, images.FieldID, id),
			sqlgraph.To(producthasimage.Table, producthasimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, images.ProductHasImageTable, images.ProductHasImageColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImagesClient) Hooks() []Hook {
	return c.hooks.Images
}

// Interceptors returns the client interceptors.
func (c *ImagesClient) Interceptors() []Interceptor {
	return c.inters.Images
}

func (c *ImagesClient) mutate(ctx context.Context, m *ImagesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImagesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImagesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImagesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Images mutation op: %q", m.Op())
	}
}

// InfoTypesClient is a client for the InfoTypes schema.
type InfoTypesClient struct {
	config
}

// NewInfoTypesClient returns a client for the InfoTypes from the given config.
func NewInfoTypesClient(c config) *InfoTypesClient {
	return &InfoTypesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `infotypes.Hooks(f(g(h())))`.
func (c *InfoTypesClient) Use(hooks ...Hook) {
	c.hooks.InfoTypes = append(c.hooks.InfoTypes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `infotypes.Intercept(f(g(h())))`.
func (c *InfoTypesClient) Intercept(interceptors ...Interceptor) {
	c.inters.InfoTypes = append(c.inters.InfoTypes, interceptors...)
}

// Create returns a builder for creating a InfoTypes entity.
func (c *InfoTypesClient) Create() *InfoTypesCreate {
	mutation := newInfoTypesMutation(c.config, OpCreate)
	return &InfoTypesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InfoTypes entities.
func (c *InfoTypesClient) CreateBulk(builders ...*InfoTypesCreate) *InfoTypesCreateBulk {
	return &InfoTypesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InfoTypesClient) MapCreateBulk(slice any, setFunc func(*InfoTypesCreate, int)) *InfoTypesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InfoTypesCreateBulk{err: fmt.Errorf("calling to InfoTypesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InfoTypesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InfoTypesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InfoTypes.
func (c *InfoTypesClient) Update() *InfoTypesUpdate {
	mutation := newInfoTypesMutation(c.config, OpUpdate)
	return &InfoTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InfoTypesClient) UpdateOne(it *InfoTypes) *InfoTypesUpdateOne {
	mutation := newInfoTypesMutation(c.config, OpUpdateOne, withInfoTypes(it))
	return &InfoTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InfoTypesClient) UpdateOneID(id int) *InfoTypesUpdateOne {
	mutation := newInfoTypesMutation(c.config, OpUpdateOne, withInfoTypesID(id))
	return &InfoTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InfoTypes.
func (c *InfoTypesClient) Delete() *InfoTypesDelete {
	mutation := newInfoTypesMutation(c.config, OpDelete)
	return &InfoTypesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InfoTypesClient) DeleteOne(it *InfoTypes) *InfoTypesDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InfoTypesClient) DeleteOneID(id int) *InfoTypesDeleteOne {
	builder := c.Delete().Where(infotypes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InfoTypesDeleteOne{builder}
}

// Query returns a query builder for InfoTypes.
func (c *InfoTypesClient) Query() *InfoTypesQuery {
	return &InfoTypesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInfoTypes},
		inters: c.Interceptors(),
	}
}

// Get returns a InfoTypes entity by its id.
func (c *InfoTypesClient) Get(ctx context.Context, id int) (*InfoTypes, error) {
	return c.Query().Where(infotypes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InfoTypesClient) GetX(ctx context.Context, id int) *InfoTypes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductInfo queries the product_info edge of a InfoTypes.
func (c *InfoTypesClient) QueryProductInfo(it *InfoTypes) *ProductInfoQuery {
	query := (&ProductInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(infotypes.Table, infotypes.FieldID, id),
			sqlgraph.To(productinfo.Table, productinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, infotypes.ProductInfoTable, infotypes.ProductInfoColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InfoTypesClient) Hooks() []Hook {
	return c.hooks.InfoTypes
}

// Interceptors returns the client interceptors.
func (c *InfoTypesClient) Interceptors() []Interceptor {
	return c.inters.InfoTypes
}

func (c *InfoTypesClient) mutate(ctx context.Context, m *InfoTypesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InfoTypesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InfoTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InfoTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InfoTypesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InfoTypes mutation op: %q", m.Op())
	}
}

// PriceTypeClient is a client for the PriceType schema.
type PriceTypeClient struct {
	config
}

// NewPriceTypeClient returns a client for the PriceType from the given config.
func NewPriceTypeClient(c config) *PriceTypeClient {
	return &PriceTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pricetype.Hooks(f(g(h())))`.
func (c *PriceTypeClient) Use(hooks ...Hook) {
	c.hooks.PriceType = append(c.hooks.PriceType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pricetype.Intercept(f(g(h())))`.
func (c *PriceTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PriceType = append(c.inters.PriceType, interceptors...)
}

// Create returns a builder for creating a PriceType entity.
func (c *PriceTypeClient) Create() *PriceTypeCreate {
	mutation := newPriceTypeMutation(c.config, OpCreate)
	return &PriceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PriceType entities.
func (c *PriceTypeClient) CreateBulk(builders ...*PriceTypeCreate) *PriceTypeCreateBulk {
	return &PriceTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PriceTypeClient) MapCreateBulk(slice any, setFunc func(*PriceTypeCreate, int)) *PriceTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PriceTypeCreateBulk{err: fmt.Errorf("calling to PriceTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PriceTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PriceTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PriceType.
func (c *PriceTypeClient) Update() *PriceTypeUpdate {
	mutation := newPriceTypeMutation(c.config, OpUpdate)
	return &PriceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PriceTypeClient) UpdateOne(pt *PriceType) *PriceTypeUpdateOne {
	mutation := newPriceTypeMutation(c.config, OpUpdateOne, withPriceType(pt))
	return &PriceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PriceTypeClient) UpdateOneID(id int) *PriceTypeUpdateOne {
	mutation := newPriceTypeMutation(c.config, OpUpdateOne, withPriceTypeID(id))
	return &PriceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PriceType.
func (c *PriceTypeClient) Delete() *PriceTypeDelete {
	mutation := newPriceTypeMutation(c.config, OpDelete)
	return &PriceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PriceTypeClient) DeleteOne(pt *PriceType) *PriceTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PriceTypeClient) DeleteOneID(id int) *PriceTypeDeleteOne {
	builder := c.Delete().Where(pricetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PriceTypeDeleteOne{builder}
}

// Query returns a query builder for PriceType.
func (c *PriceTypeClient) Query() *PriceTypeQuery {
	return &PriceTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePriceType},
		inters: c.Interceptors(),
	}
}

// Get returns a PriceType entity by its id.
func (c *PriceTypeClient) Get(ctx context.Context, id int) (*PriceType, error) {
	return c.Query().Where(pricetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PriceTypeClient) GetX(ctx context.Context, id int) *PriceType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductPrices queries the product_prices edge of a PriceType.
func (c *PriceTypeClient) QueryProductPrices(pt *PriceType) *ProductPricesQuery {
	query := (&ProductPricesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pricetype.Table, pricetype.FieldID, id),
			sqlgraph.To(productprices.Table, productprices.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, pricetype.ProductPricesTable, pricetype.ProductPricesColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PriceTypeClient) Hooks() []Hook {
	return c.hooks.PriceType
}

// Interceptors returns the client interceptors.
func (c *PriceTypeClient) Interceptors() []Interceptor {
	return c.inters.PriceType
}

func (c *PriceTypeClient) mutate(ctx context.Context, m *PriceTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PriceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PriceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PriceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PriceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PriceType mutation op: %q", m.Op())
	}
}

// ProductHasFeatureClient is a client for the ProductHasFeature schema.
type ProductHasFeatureClient struct {
	config
}

// NewProductHasFeatureClient returns a client for the ProductHasFeature from the given config.
func NewProductHasFeatureClient(c config) *ProductHasFeatureClient {
	return &ProductHasFeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producthasfeature.Hooks(f(g(h())))`.
func (c *ProductHasFeatureClient) Use(hooks ...Hook) {
	c.hooks.ProductHasFeature = append(c.hooks.ProductHasFeature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producthasfeature.Intercept(f(g(h())))`.
func (c *ProductHasFeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductHasFeature = append(c.inters.ProductHasFeature, interceptors...)
}

// Create returns a builder for creating a ProductHasFeature entity.
func (c *ProductHasFeatureClient) Create() *ProductHasFeatureCreate {
	mutation := newProductHasFeatureMutation(c.config, OpCreate)
	return &ProductHasFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductHasFeature entities.
func (c *ProductHasFeatureClient) CreateBulk(builders ...*ProductHasFeatureCreate) *ProductHasFeatureCreateBulk {
	return &ProductHasFeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductHasFeatureClient) MapCreateBulk(slice any, setFunc func(*ProductHasFeatureCreate, int)) *ProductHasFeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductHasFeatureCreateBulk{err: fmt.Errorf("calling to ProductHasFeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductHasFeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductHasFeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductHasFeature.
func (c *ProductHasFeatureClient) Update() *ProductHasFeatureUpdate {
	mutation := newProductHasFeatureMutation(c.config, OpUpdate)
	return &ProductHasFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductHasFeatureClient) UpdateOne(phf *ProductHasFeature) *ProductHasFeatureUpdateOne {
	mutation := newProductHasFeatureMutation(c.config, OpUpdateOne, withProductHasFeature(phf))
	return &ProductHasFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductHasFeatureClient) UpdateOneID(id int) *ProductHasFeatureUpdateOne {
	mutation := newProductHasFeatureMutation(c.config, OpUpdateOne, withProductHasFeatureID(id))
	return &ProductHasFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductHasFeature.
func (c *ProductHasFeatureClient) Delete() *ProductHasFeatureDelete {
	mutation := newProductHasFeatureMutation(c.config, OpDelete)
	return &ProductHasFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductHasFeatureClient) DeleteOne(phf *ProductHasFeature) *ProductHasFeatureDeleteOne {
	return c.DeleteOneID(phf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductHasFeatureClient) DeleteOneID(id int) *ProductHasFeatureDeleteOne {
	builder := c.Delete().Where(producthasfeature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductHasFeatureDeleteOne{builder}
}

// Query returns a query builder for ProductHasFeature.
func (c *ProductHasFeatureClient) Query() *ProductHasFeatureQuery {
	return &ProductHasFeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductHasFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductHasFeature entity by its id.
func (c *ProductHasFeatureClient) Get(ctx context.Context, id int) (*ProductHasFeature, error) {
	return c.Query().Where(producthasfeature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductHasFeatureClient) GetX(ctx context.Context, id int) *ProductHasFeature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a ProductHasFeature.
func (c *ProductHasFeatureClient) QueryProducts(phf *ProductHasFeature) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasfeature.Table, producthasfeature.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasfeature.ProductsTable, producthasfeature.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(phf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatures queries the features edge of a ProductHasFeature.
func (c *ProductHasFeatureClient) QueryFeatures(phf *ProductHasFeature) *FeaturesQuery {
	query := (&FeaturesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasfeature.Table, producthasfeature.FieldID, id),
			sqlgraph.To(features.Table, features.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasfeature.FeaturesTable, producthasfeature.FeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(phf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductHasFeatureClient) Hooks() []Hook {
	return c.hooks.ProductHasFeature
}

// Interceptors returns the client interceptors.
func (c *ProductHasFeatureClient) Interceptors() []Interceptor {
	return c.inters.ProductHasFeature
}

func (c *ProductHasFeatureClient) mutate(ctx context.Context, m *ProductHasFeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductHasFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductHasFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductHasFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductHasFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductHasFeature mutation op: %q", m.Op())
	}
}

// ProductHasImageClient is a client for the ProductHasImage schema.
type ProductHasImageClient struct {
	config
}

// NewProductHasImageClient returns a client for the ProductHasImage from the given config.
func NewProductHasImageClient(c config) *ProductHasImageClient {
	return &ProductHasImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producthasimage.Hooks(f(g(h())))`.
func (c *ProductHasImageClient) Use(hooks ...Hook) {
	c.hooks.ProductHasImage = append(c.hooks.ProductHasImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producthasimage.Intercept(f(g(h())))`.
func (c *ProductHasImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductHasImage = append(c.inters.ProductHasImage, interceptors...)
}

// Create returns a builder for creating a ProductHasImage entity.
func (c *ProductHasImageClient) Create() *ProductHasImageCreate {
	mutation := newProductHasImageMutation(c.config, OpCreate)
	return &ProductHasImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductHasImage entities.
func (c *ProductHasImageClient) CreateBulk(builders ...*ProductHasImageCreate) *ProductHasImageCreateBulk {
	return &ProductHasImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductHasImageClient) MapCreateBulk(slice any, setFunc func(*ProductHasImageCreate, int)) *ProductHasImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductHasImageCreateBulk{err: fmt.Errorf("calling to ProductHasImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductHasImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductHasImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductHasImage.
func (c *ProductHasImageClient) Update() *ProductHasImageUpdate {
	mutation := newProductHasImageMutation(c.config, OpUpdate)
	return &ProductHasImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductHasImageClient) UpdateOne(phi *ProductHasImage) *ProductHasImageUpdateOne {
	mutation := newProductHasImageMutation(c.config, OpUpdateOne, withProductHasImage(phi))
	return &ProductHasImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductHasImageClient) UpdateOneID(id int) *ProductHasImageUpdateOne {
	mutation := newProductHasImageMutation(c.config, OpUpdateOne, withProductHasImageID(id))
	return &ProductHasImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductHasImage.
func (c *ProductHasImageClient) Delete() *ProductHasImageDelete {
	mutation := newProductHasImageMutation(c.config, OpDelete)
	return &ProductHasImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductHasImageClient) DeleteOne(phi *ProductHasImage) *ProductHasImageDeleteOne {
	return c.DeleteOneID(phi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductHasImageClient) DeleteOneID(id int) *ProductHasImageDeleteOne {
	builder := c.Delete().Where(producthasimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductHasImageDeleteOne{builder}
}

// Query returns a query builder for ProductHasImage.
func (c *ProductHasImageClient) Query() *ProductHasImageQuery {
	return &ProductHasImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductHasImage},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductHasImage entity by its id.
func (c *ProductHasImageClient) Get(ctx context.Context, id int) (*ProductHasImage, error) {
	return c.Query().Where(producthasimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductHasImageClient) GetX(ctx context.Context, id int) *ProductHasImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductHasImage.
func (c *ProductHasImageClient) QueryProduct(phi *ProductHasImage) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasimage.Table, producthasimage.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasimage.ProductTable, producthasimage.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(phi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImage queries the image edge of a ProductHasImage.
func (c *ProductHasImageClient) QueryImage(phi *ProductHasImage) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasimage.Table, producthasimage.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasimage.ImageTable, producthasimage.ImageColumn),
		)
		fromV = sqlgraph.Neighbors(phi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductHasImageClient) Hooks() []Hook {
	return c.hooks.ProductHasImage
}

// Interceptors returns the client interceptors.
func (c *ProductHasImageClient) Interceptors() []Interceptor {
	return c.inters.ProductHasImage
}

func (c *ProductHasImageClient) mutate(ctx context.Context, m *ProductHasImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductHasImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductHasImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductHasImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductHasImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductHasImage mutation op: %q", m.Op())
	}
}

// ProductHasInfoClient is a client for the ProductHasInfo schema.
type ProductHasInfoClient struct {
	config
}

// NewProductHasInfoClient returns a client for the ProductHasInfo from the given config.
func NewProductHasInfoClient(c config) *ProductHasInfoClient {
	return &ProductHasInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producthasinfo.Hooks(f(g(h())))`.
func (c *ProductHasInfoClient) Use(hooks ...Hook) {
	c.hooks.ProductHasInfo = append(c.hooks.ProductHasInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producthasinfo.Intercept(f(g(h())))`.
func (c *ProductHasInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductHasInfo = append(c.inters.ProductHasInfo, interceptors...)
}

// Create returns a builder for creating a ProductHasInfo entity.
func (c *ProductHasInfoClient) Create() *ProductHasInfoCreate {
	mutation := newProductHasInfoMutation(c.config, OpCreate)
	return &ProductHasInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductHasInfo entities.
func (c *ProductHasInfoClient) CreateBulk(builders ...*ProductHasInfoCreate) *ProductHasInfoCreateBulk {
	return &ProductHasInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductHasInfoClient) MapCreateBulk(slice any, setFunc func(*ProductHasInfoCreate, int)) *ProductHasInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductHasInfoCreateBulk{err: fmt.Errorf("calling to ProductHasInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductHasInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductHasInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductHasInfo.
func (c *ProductHasInfoClient) Update() *ProductHasInfoUpdate {
	mutation := newProductHasInfoMutation(c.config, OpUpdate)
	return &ProductHasInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductHasInfoClient) UpdateOne(phi *ProductHasInfo) *ProductHasInfoUpdateOne {
	mutation := newProductHasInfoMutation(c.config, OpUpdateOne, withProductHasInfo(phi))
	return &ProductHasInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductHasInfoClient) UpdateOneID(id int) *ProductHasInfoUpdateOne {
	mutation := newProductHasInfoMutation(c.config, OpUpdateOne, withProductHasInfoID(id))
	return &ProductHasInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductHasInfo.
func (c *ProductHasInfoClient) Delete() *ProductHasInfoDelete {
	mutation := newProductHasInfoMutation(c.config, OpDelete)
	return &ProductHasInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductHasInfoClient) DeleteOne(phi *ProductHasInfo) *ProductHasInfoDeleteOne {
	return c.DeleteOneID(phi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductHasInfoClient) DeleteOneID(id int) *ProductHasInfoDeleteOne {
	builder := c.Delete().Where(producthasinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductHasInfoDeleteOne{builder}
}

// Query returns a query builder for ProductHasInfo.
func (c *ProductHasInfoClient) Query() *ProductHasInfoQuery {
	return &ProductHasInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductHasInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductHasInfo entity by its id.
func (c *ProductHasInfoClient) Get(ctx context.Context, id int) (*ProductHasInfo, error) {
	return c.Query().Where(producthasinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductHasInfoClient) GetX(ctx context.Context, id int) *ProductHasInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a ProductHasInfo.
func (c *ProductHasInfoClient) QueryProducts(phi *ProductHasInfo) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasinfo.Table, producthasinfo.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasinfo.ProductsTable, producthasinfo.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(phi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductInfo queries the product_info edge of a ProductHasInfo.
func (c *ProductHasInfoClient) QueryProductInfo(phi *ProductHasInfo) *ProductInfoQuery {
	query := (&ProductInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasinfo.Table, producthasinfo.FieldID, id),
			sqlgraph.To(productinfo.Table, productinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasinfo.ProductInfoTable, producthasinfo.ProductInfoColumn),
		)
		fromV = sqlgraph.Neighbors(phi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductHasInfoClient) Hooks() []Hook {
	return c.hooks.ProductHasInfo
}

// Interceptors returns the client interceptors.
func (c *ProductHasInfoClient) Interceptors() []Interceptor {
	return c.inters.ProductHasInfo
}

func (c *ProductHasInfoClient) mutate(ctx context.Context, m *ProductHasInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductHasInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductHasInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductHasInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductHasInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductHasInfo mutation op: %q", m.Op())
	}
}

// ProductHasProductReferenceClient is a client for the ProductHasProductReference schema.
type ProductHasProductReferenceClient struct {
	config
}

// NewProductHasProductReferenceClient returns a client for the ProductHasProductReference from the given config.
func NewProductHasProductReferenceClient(c config) *ProductHasProductReferenceClient {
	return &ProductHasProductReferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producthasproductreference.Hooks(f(g(h())))`.
func (c *ProductHasProductReferenceClient) Use(hooks ...Hook) {
	c.hooks.ProductHasProductReference = append(c.hooks.ProductHasProductReference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producthasproductreference.Intercept(f(g(h())))`.
func (c *ProductHasProductReferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductHasProductReference = append(c.inters.ProductHasProductReference, interceptors...)
}

// Create returns a builder for creating a ProductHasProductReference entity.
func (c *ProductHasProductReferenceClient) Create() *ProductHasProductReferenceCreate {
	mutation := newProductHasProductReferenceMutation(c.config, OpCreate)
	return &ProductHasProductReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductHasProductReference entities.
func (c *ProductHasProductReferenceClient) CreateBulk(builders ...*ProductHasProductReferenceCreate) *ProductHasProductReferenceCreateBulk {
	return &ProductHasProductReferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductHasProductReferenceClient) MapCreateBulk(slice any, setFunc func(*ProductHasProductReferenceCreate, int)) *ProductHasProductReferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductHasProductReferenceCreateBulk{err: fmt.Errorf("calling to ProductHasProductReferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductHasProductReferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductHasProductReferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductHasProductReference.
func (c *ProductHasProductReferenceClient) Update() *ProductHasProductReferenceUpdate {
	mutation := newProductHasProductReferenceMutation(c.config, OpUpdate)
	return &ProductHasProductReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductHasProductReferenceClient) UpdateOne(phpr *ProductHasProductReference) *ProductHasProductReferenceUpdateOne {
	mutation := newProductHasProductReferenceMutation(c.config, OpUpdateOne, withProductHasProductReference(phpr))
	return &ProductHasProductReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductHasProductReferenceClient) UpdateOneID(id int) *ProductHasProductReferenceUpdateOne {
	mutation := newProductHasProductReferenceMutation(c.config, OpUpdateOne, withProductHasProductReferenceID(id))
	return &ProductHasProductReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductHasProductReference.
func (c *ProductHasProductReferenceClient) Delete() *ProductHasProductReferenceDelete {
	mutation := newProductHasProductReferenceMutation(c.config, OpDelete)
	return &ProductHasProductReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductHasProductReferenceClient) DeleteOne(phpr *ProductHasProductReference) *ProductHasProductReferenceDeleteOne {
	return c.DeleteOneID(phpr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductHasProductReferenceClient) DeleteOneID(id int) *ProductHasProductReferenceDeleteOne {
	builder := c.Delete().Where(producthasproductreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductHasProductReferenceDeleteOne{builder}
}

// Query returns a query builder for ProductHasProductReference.
func (c *ProductHasProductReferenceClient) Query() *ProductHasProductReferenceQuery {
	return &ProductHasProductReferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductHasProductReference},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductHasProductReference entity by its id.
func (c *ProductHasProductReferenceClient) Get(ctx context.Context, id int) (*ProductHasProductReference, error) {
	return c.Query().Where(producthasproductreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductHasProductReferenceClient) GetX(ctx context.Context, id int) *ProductHasProductReference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductReference queries the product_reference edge of a ProductHasProductReference.
func (c *ProductHasProductReferenceClient) QueryProductReference(phpr *ProductHasProductReference) *ProductReferencesQuery {
	query := (&ProductReferencesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phpr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasproductreference.Table, producthasproductreference.FieldID, id),
			sqlgraph.To(productreferences.Table, productreferences.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasproductreference.ProductReferenceTable, producthasproductreference.ProductReferenceColumn),
		)
		fromV = sqlgraph.Neighbors(phpr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a ProductHasProductReference.
func (c *ProductHasProductReferenceClient) QueryProduct(phpr *ProductHasProductReference) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := phpr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(producthasproductreference.Table, producthasproductreference.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, producthasproductreference.ProductTable, producthasproductreference.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(phpr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductHasProductReferenceClient) Hooks() []Hook {
	return c.hooks.ProductHasProductReference
}

// Interceptors returns the client interceptors.
func (c *ProductHasProductReferenceClient) Interceptors() []Interceptor {
	return c.inters.ProductHasProductReference
}

func (c *ProductHasProductReferenceClient) mutate(ctx context.Context, m *ProductHasProductReferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductHasProductReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductHasProductReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductHasProductReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductHasProductReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductHasProductReference mutation op: %q", m.Op())
	}
}

// ProductInfoClient is a client for the ProductInfo schema.
type ProductInfoClient struct {
	config
}

// NewProductInfoClient returns a client for the ProductInfo from the given config.
func NewProductInfoClient(c config) *ProductInfoClient {
	return &ProductInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productinfo.Hooks(f(g(h())))`.
func (c *ProductInfoClient) Use(hooks ...Hook) {
	c.hooks.ProductInfo = append(c.hooks.ProductInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productinfo.Intercept(f(g(h())))`.
func (c *ProductInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductInfo = append(c.inters.ProductInfo, interceptors...)
}

// Create returns a builder for creating a ProductInfo entity.
func (c *ProductInfoClient) Create() *ProductInfoCreate {
	mutation := newProductInfoMutation(c.config, OpCreate)
	return &ProductInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductInfo entities.
func (c *ProductInfoClient) CreateBulk(builders ...*ProductInfoCreate) *ProductInfoCreateBulk {
	return &ProductInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductInfoClient) MapCreateBulk(slice any, setFunc func(*ProductInfoCreate, int)) *ProductInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductInfoCreateBulk{err: fmt.Errorf("calling to ProductInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductInfo.
func (c *ProductInfoClient) Update() *ProductInfoUpdate {
	mutation := newProductInfoMutation(c.config, OpUpdate)
	return &ProductInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductInfoClient) UpdateOne(pi *ProductInfo) *ProductInfoUpdateOne {
	mutation := newProductInfoMutation(c.config, OpUpdateOne, withProductInfo(pi))
	return &ProductInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductInfoClient) UpdateOneID(id int) *ProductInfoUpdateOne {
	mutation := newProductInfoMutation(c.config, OpUpdateOne, withProductInfoID(id))
	return &ProductInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductInfo.
func (c *ProductInfoClient) Delete() *ProductInfoDelete {
	mutation := newProductInfoMutation(c.config, OpDelete)
	return &ProductInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductInfoClient) DeleteOne(pi *ProductInfo) *ProductInfoDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductInfoClient) DeleteOneID(id int) *ProductInfoDeleteOne {
	builder := c.Delete().Where(productinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductInfoDeleteOne{builder}
}

// Query returns a query builder for ProductInfo.
func (c *ProductInfoClient) Query() *ProductInfoQuery {
	return &ProductInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductInfo entity by its id.
func (c *ProductInfoClient) Get(ctx context.Context, id int) (*ProductInfo, error) {
	return c.Query().Where(productinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductInfoClient) GetX(ctx context.Context, id int) *ProductInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInfoType queries the info_type edge of a ProductInfo.
func (c *ProductInfoClient) QueryInfoType(pi *ProductInfo) *InfoTypesQuery {
	query := (&InfoTypesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productinfo.Table, productinfo.FieldID, id),
			sqlgraph.To(infotypes.Table, infotypes.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productinfo.InfoTypeTable, productinfo.InfoTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a ProductInfo.
func (c *ProductInfoClient) QueryProducts(pi *ProductInfo) *ProductHasInfoQuery {
	query := (&ProductHasInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productinfo.Table, productinfo.FieldID, id),
			sqlgraph.To(producthasinfo.Table, producthasinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, productinfo.ProductsTable, productinfo.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasInfo queries the product_has_info edge of a ProductInfo.
func (c *ProductInfoClient) QueryProductHasInfo(pi *ProductInfo) *ProductHasInfoQuery {
	query := (&ProductHasInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productinfo.Table, productinfo.FieldID, id),
			sqlgraph.To(producthasinfo.Table, producthasinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, productinfo.ProductHasInfoTable, productinfo.ProductHasInfoColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductInfoClient) Hooks() []Hook {
	return c.hooks.ProductInfo
}

// Interceptors returns the client interceptors.
func (c *ProductInfoClient) Interceptors() []Interceptor {
	return c.inters.ProductInfo
}

func (c *ProductInfoClient) mutate(ctx context.Context, m *ProductInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductInfo mutation op: %q", m.Op())
	}
}

// ProductPricesClient is a client for the ProductPrices schema.
type ProductPricesClient struct {
	config
}

// NewProductPricesClient returns a client for the ProductPrices from the given config.
func NewProductPricesClient(c config) *ProductPricesClient {
	return &ProductPricesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productprices.Hooks(f(g(h())))`.
func (c *ProductPricesClient) Use(hooks ...Hook) {
	c.hooks.ProductPrices = append(c.hooks.ProductPrices, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productprices.Intercept(f(g(h())))`.
func (c *ProductPricesClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductPrices = append(c.inters.ProductPrices, interceptors...)
}

// Create returns a builder for creating a ProductPrices entity.
func (c *ProductPricesClient) Create() *ProductPricesCreate {
	mutation := newProductPricesMutation(c.config, OpCreate)
	return &ProductPricesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductPrices entities.
func (c *ProductPricesClient) CreateBulk(builders ...*ProductPricesCreate) *ProductPricesCreateBulk {
	return &ProductPricesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductPricesClient) MapCreateBulk(slice any, setFunc func(*ProductPricesCreate, int)) *ProductPricesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductPricesCreateBulk{err: fmt.Errorf("calling to ProductPricesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductPricesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductPricesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductPrices.
func (c *ProductPricesClient) Update() *ProductPricesUpdate {
	mutation := newProductPricesMutation(c.config, OpUpdate)
	return &ProductPricesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductPricesClient) UpdateOne(pp *ProductPrices) *ProductPricesUpdateOne {
	mutation := newProductPricesMutation(c.config, OpUpdateOne, withProductPrices(pp))
	return &ProductPricesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductPricesClient) UpdateOneID(id int) *ProductPricesUpdateOne {
	mutation := newProductPricesMutation(c.config, OpUpdateOne, withProductPricesID(id))
	return &ProductPricesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductPrices.
func (c *ProductPricesClient) Delete() *ProductPricesDelete {
	mutation := newProductPricesMutation(c.config, OpDelete)
	return &ProductPricesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductPricesClient) DeleteOne(pp *ProductPrices) *ProductPricesDeleteOne {
	return c.DeleteOneID(pp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductPricesClient) DeleteOneID(id int) *ProductPricesDeleteOne {
	builder := c.Delete().Where(productprices.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductPricesDeleteOne{builder}
}

// Query returns a query builder for ProductPrices.
func (c *ProductPricesClient) Query() *ProductPricesQuery {
	return &ProductPricesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductPrices},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductPrices entity by its id.
func (c *ProductPricesClient) Get(ctx context.Context, id int) (*ProductPrices, error) {
	return c.Query().Where(productprices.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductPricesClient) GetX(ctx context.Context, id int) *ProductPrices {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductPrices.
func (c *ProductPricesClient) QueryProduct(pp *ProductPrices) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productprices.Table, productprices.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productprices.ProductTable, productprices.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPriceType queries the price_type edge of a ProductPrices.
func (c *ProductPricesClient) QueryPriceType(pp *ProductPrices) *PriceTypeQuery {
	query := (&PriceTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productprices.Table, productprices.FieldID, id),
			sqlgraph.To(pricetype.Table, pricetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productprices.PriceTypeTable, productprices.PriceTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductPricesClient) Hooks() []Hook {
	return c.hooks.ProductPrices
}

// Interceptors returns the client interceptors.
func (c *ProductPricesClient) Interceptors() []Interceptor {
	return c.inters.ProductPrices
}

func (c *ProductPricesClient) mutate(ctx context.Context, m *ProductPricesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductPricesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductPricesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductPricesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductPricesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductPrices mutation op: %q", m.Op())
	}
}

// ProductReferencesClient is a client for the ProductReferences schema.
type ProductReferencesClient struct {
	config
}

// NewProductReferencesClient returns a client for the ProductReferences from the given config.
func NewProductReferencesClient(c config) *ProductReferencesClient {
	return &ProductReferencesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productreferences.Hooks(f(g(h())))`.
func (c *ProductReferencesClient) Use(hooks ...Hook) {
	c.hooks.ProductReferences = append(c.hooks.ProductReferences, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productreferences.Intercept(f(g(h())))`.
func (c *ProductReferencesClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductReferences = append(c.inters.ProductReferences, interceptors...)
}

// Create returns a builder for creating a ProductReferences entity.
func (c *ProductReferencesClient) Create() *ProductReferencesCreate {
	mutation := newProductReferencesMutation(c.config, OpCreate)
	return &ProductReferencesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductReferences entities.
func (c *ProductReferencesClient) CreateBulk(builders ...*ProductReferencesCreate) *ProductReferencesCreateBulk {
	return &ProductReferencesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductReferencesClient) MapCreateBulk(slice any, setFunc func(*ProductReferencesCreate, int)) *ProductReferencesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductReferencesCreateBulk{err: fmt.Errorf("calling to ProductReferencesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductReferencesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductReferencesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductReferences.
func (c *ProductReferencesClient) Update() *ProductReferencesUpdate {
	mutation := newProductReferencesMutation(c.config, OpUpdate)
	return &ProductReferencesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductReferencesClient) UpdateOne(pr *ProductReferences) *ProductReferencesUpdateOne {
	mutation := newProductReferencesMutation(c.config, OpUpdateOne, withProductReferences(pr))
	return &ProductReferencesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductReferencesClient) UpdateOneID(id int) *ProductReferencesUpdateOne {
	mutation := newProductReferencesMutation(c.config, OpUpdateOne, withProductReferencesID(id))
	return &ProductReferencesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductReferences.
func (c *ProductReferencesClient) Delete() *ProductReferencesDelete {
	mutation := newProductReferencesMutation(c.config, OpDelete)
	return &ProductReferencesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductReferencesClient) DeleteOne(pr *ProductReferences) *ProductReferencesDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductReferencesClient) DeleteOneID(id int) *ProductReferencesDeleteOne {
	builder := c.Delete().Where(productreferences.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductReferencesDeleteOne{builder}
}

// Query returns a query builder for ProductReferences.
func (c *ProductReferencesClient) Query() *ProductReferencesQuery {
	return &ProductReferencesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductReferences},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductReferences entity by its id.
func (c *ProductReferencesClient) Get(ctx context.Context, id int) (*ProductReferences, error) {
	return c.Query().Where(productreferences.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductReferencesClient) GetX(ctx context.Context, id int) *ProductReferences {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductReferences.
func (c *ProductReferencesClient) QueryProduct(pr *ProductReferences) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productreferences.Table, productreferences.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productreferences.ProductTable, productreferences.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReferenceSources queries the reference_sources edge of a ProductReferences.
func (c *ProductReferencesClient) QueryReferenceSources(pr *ProductReferences) *ReferenceSourcesQuery {
	query := (&ReferenceSourcesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productreferences.Table, productreferences.FieldID, id),
			sqlgraph.To(referencesources.Table, referencesources.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productreferences.ReferenceSourcesTable, productreferences.ReferenceSourcesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasProductReference queries the product_has_product_reference edge of a ProductReferences.
func (c *ProductReferencesClient) QueryProductHasProductReference(pr *ProductReferences) *ProductHasProductReferenceQuery {
	query := (&ProductHasProductReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productreferences.Table, productreferences.FieldID, id),
			sqlgraph.To(producthasproductreference.Table, producthasproductreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, productreferences.ProductHasProductReferenceTable, productreferences.ProductHasProductReferenceColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductReferencesClient) Hooks() []Hook {
	return c.hooks.ProductReferences
}

// Interceptors returns the client interceptors.
func (c *ProductReferencesClient) Interceptors() []Interceptor {
	return c.inters.ProductReferences
}

func (c *ProductReferencesClient) mutate(ctx context.Context, m *ProductReferencesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductReferencesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductReferencesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductReferencesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductReferencesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductReferences mutation op: %q", m.Op())
	}
}

// ProductsClient is a client for the Products schema.
type ProductsClient struct {
	config
}

// NewProductsClient returns a client for the Products from the given config.
func NewProductsClient(c config) *ProductsClient {
	return &ProductsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `products.Hooks(f(g(h())))`.
func (c *ProductsClient) Use(hooks ...Hook) {
	c.hooks.Products = append(c.hooks.Products, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `products.Intercept(f(g(h())))`.
func (c *ProductsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Products = append(c.inters.Products, interceptors...)
}

// Create returns a builder for creating a Products entity.
func (c *ProductsClient) Create() *ProductsCreate {
	mutation := newProductsMutation(c.config, OpCreate)
	return &ProductsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Products entities.
func (c *ProductsClient) CreateBulk(builders ...*ProductsCreate) *ProductsCreateBulk {
	return &ProductsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductsClient) MapCreateBulk(slice any, setFunc func(*ProductsCreate, int)) *ProductsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductsCreateBulk{err: fmt.Errorf("calling to ProductsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Products.
func (c *ProductsClient) Update() *ProductsUpdate {
	mutation := newProductsMutation(c.config, OpUpdate)
	return &ProductsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductsClient) UpdateOne(pr *Products) *ProductsUpdateOne {
	mutation := newProductsMutation(c.config, OpUpdateOne, withProducts(pr))
	return &ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductsClient) UpdateOneID(id int) *ProductsUpdateOne {
	mutation := newProductsMutation(c.config, OpUpdateOne, withProductsID(id))
	return &ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Products.
func (c *ProductsClient) Delete() *ProductsDelete {
	mutation := newProductsMutation(c.config, OpDelete)
	return &ProductsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductsClient) DeleteOne(pr *Products) *ProductsDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductsClient) DeleteOneID(id int) *ProductsDeleteOne {
	builder := c.Delete().Where(products.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductsDeleteOne{builder}
}

// Query returns a query builder for Products.
func (c *ProductsClient) Query() *ProductsQuery {
	return &ProductsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProducts},
		inters: c.Interceptors(),
	}
}

// Get returns a Products entity by its id.
func (c *ProductsClient) Get(ctx context.Context, id int) (*Products, error) {
	return c.Query().Where(products.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductsClient) GetX(ctx context.Context, id int) *Products {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Products.
func (c *ProductsClient) QueryCategory(pr *Products) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, products.CategoryTable, products.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrand queries the brand edge of a Products.
func (c *ProductsClient) QueryBrand(pr *Products) *BrandQuery {
	query := (&BrandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, products.BrandTable, products.BrandColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariantType queries the variant_type edge of a Products.
func (c *ProductsClient) QueryVariantType(pr *Products) *VariantTypeQuery {
	query := (&VariantTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(varianttype.Table, varianttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, products.VariantTypeTable, products.VariantTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductReferences queries the product_references edge of a Products.
func (c *ProductsClient) QueryProductReferences(pr *Products) *ProductReferencesQuery {
	query := (&ProductReferencesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(productreferences.Table, productreferences.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductReferencesTable, products.ProductReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a Products.
func (c *ProductsClient) QueryImages(pr *Products) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ImagesTable, products.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasImage queries the product_has_image edge of a Products.
func (c *ProductsClient) QueryProductHasImage(pr *Products) *ProductHasImageQuery {
	query := (&ProductHasImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(producthasimage.Table, producthasimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductHasImageTable, products.ProductHasImageColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPromotionHasProduct queries the promotion_has_product edge of a Products.
func (c *ProductsClient) QueryPromotionHasProduct(pr *Products) *PromotionHasProductQuery {
	query := (&PromotionHasProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(promotionhasproduct.Table, promotionhasproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.PromotionHasProductTable, products.PromotionHasProductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToolHasProduct queries the tool_has_product edge of a Products.
func (c *ProductsClient) QueryToolHasProduct(pr *Products) *ToolHasProductQuery {
	query := (&ToolHasProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(toolhasproduct.Table, toolhasproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ToolHasProductTable, products.ToolHasProductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasFeature queries the product_has_feature edge of a Products.
func (c *ProductsClient) QueryProductHasFeature(pr *Products) *ProductHasFeatureQuery {
	query := (&ProductHasFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(producthasfeature.Table, producthasfeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductHasFeatureTable, products.ProductHasFeatureColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasInfo queries the product_has_info edge of a Products.
func (c *ProductsClient) QueryProductHasInfo(pr *Products) *ProductHasInfoQuery {
	query := (&ProductHasInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(producthasinfo.Table, producthasinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductHasInfoTable, products.ProductHasInfoColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductHasProductReference queries the product_has_product_reference edge of a Products.
func (c *ProductsClient) QueryProductHasProductReference(pr *Products) *ProductHasProductReferenceQuery {
	query := (&ProductHasProductReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(producthasproductreference.Table, producthasproductreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductHasProductReferenceTable, products.ProductHasProductReferenceColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductPrices queries the product_prices edge of a Products.
func (c *ProductsClient) QueryProductPrices(pr *Products) *ProductPricesQuery {
	query := (&ProductPricesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(products.Table, products.FieldID, id),
			sqlgraph.To(productprices.Table, productprices.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, products.ProductPricesTable, products.ProductPricesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductsClient) Hooks() []Hook {
	return c.hooks.Products
}

// Interceptors returns the client interceptors.
func (c *ProductsClient) Interceptors() []Interceptor {
	return c.inters.Products
}

func (c *ProductsClient) mutate(ctx context.Context, m *ProductsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Products mutation op: %q", m.Op())
	}
}

// PromotionHasProductClient is a client for the PromotionHasProduct schema.
type PromotionHasProductClient struct {
	config
}

// NewPromotionHasProductClient returns a client for the PromotionHasProduct from the given config.
func NewPromotionHasProductClient(c config) *PromotionHasProductClient {
	return &PromotionHasProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promotionhasproduct.Hooks(f(g(h())))`.
func (c *PromotionHasProductClient) Use(hooks ...Hook) {
	c.hooks.PromotionHasProduct = append(c.hooks.PromotionHasProduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promotionhasproduct.Intercept(f(g(h())))`.
func (c *PromotionHasProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.PromotionHasProduct = append(c.inters.PromotionHasProduct, interceptors...)
}

// Create returns a builder for creating a PromotionHasProduct entity.
func (c *PromotionHasProductClient) Create() *PromotionHasProductCreate {
	mutation := newPromotionHasProductMutation(c.config, OpCreate)
	return &PromotionHasProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PromotionHasProduct entities.
func (c *PromotionHasProductClient) CreateBulk(builders ...*PromotionHasProductCreate) *PromotionHasProductCreateBulk {
	return &PromotionHasProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromotionHasProductClient) MapCreateBulk(slice any, setFunc func(*PromotionHasProductCreate, int)) *PromotionHasProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromotionHasProductCreateBulk{err: fmt.Errorf("calling to PromotionHasProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromotionHasProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromotionHasProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PromotionHasProduct.
func (c *PromotionHasProductClient) Update() *PromotionHasProductUpdate {
	mutation := newPromotionHasProductMutation(c.config, OpUpdate)
	return &PromotionHasProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromotionHasProductClient) UpdateOne(php *PromotionHasProduct) *PromotionHasProductUpdateOne {
	mutation := newPromotionHasProductMutation(c.config, OpUpdateOne, withPromotionHasProduct(php))
	return &PromotionHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromotionHasProductClient) UpdateOneID(id int) *PromotionHasProductUpdateOne {
	mutation := newPromotionHasProductMutation(c.config, OpUpdateOne, withPromotionHasProductID(id))
	return &PromotionHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PromotionHasProduct.
func (c *PromotionHasProductClient) Delete() *PromotionHasProductDelete {
	mutation := newPromotionHasProductMutation(c.config, OpDelete)
	return &PromotionHasProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromotionHasProductClient) DeleteOne(php *PromotionHasProduct) *PromotionHasProductDeleteOne {
	return c.DeleteOneID(php.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromotionHasProductClient) DeleteOneID(id int) *PromotionHasProductDeleteOne {
	builder := c.Delete().Where(promotionhasproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromotionHasProductDeleteOne{builder}
}

// Query returns a query builder for PromotionHasProduct.
func (c *PromotionHasProductClient) Query() *PromotionHasProductQuery {
	return &PromotionHasProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromotionHasProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a PromotionHasProduct entity by its id.
func (c *PromotionHasProductClient) Get(ctx context.Context, id int) (*PromotionHasProduct, error) {
	return c.Query().Where(promotionhasproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromotionHasProductClient) GetX(ctx context.Context, id int) *PromotionHasProduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a PromotionHasProduct.
func (c *PromotionHasProductClient) QueryProduct(php *PromotionHasProduct) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := php.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promotionhasproduct.Table, promotionhasproduct.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, promotionhasproduct.ProductTable, promotionhasproduct.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(php.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPromotion queries the promotion edge of a PromotionHasProduct.
func (c *PromotionHasProductClient) QueryPromotion(php *PromotionHasProduct) *PromotionsQuery {
	query := (&PromotionsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := php.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promotionhasproduct.Table, promotionhasproduct.FieldID, id),
			sqlgraph.To(promotions.Table, promotions.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, promotionhasproduct.PromotionTable, promotionhasproduct.PromotionColumn),
		)
		fromV = sqlgraph.Neighbors(php.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromotionHasProductClient) Hooks() []Hook {
	return c.hooks.PromotionHasProduct
}

// Interceptors returns the client interceptors.
func (c *PromotionHasProductClient) Interceptors() []Interceptor {
	return c.inters.PromotionHasProduct
}

func (c *PromotionHasProductClient) mutate(ctx context.Context, m *PromotionHasProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromotionHasProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromotionHasProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromotionHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromotionHasProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PromotionHasProduct mutation op: %q", m.Op())
	}
}

// PromotionsClient is a client for the Promotions schema.
type PromotionsClient struct {
	config
}

// NewPromotionsClient returns a client for the Promotions from the given config.
func NewPromotionsClient(c config) *PromotionsClient {
	return &PromotionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promotions.Hooks(f(g(h())))`.
func (c *PromotionsClient) Use(hooks ...Hook) {
	c.hooks.Promotions = append(c.hooks.Promotions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promotions.Intercept(f(g(h())))`.
func (c *PromotionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Promotions = append(c.inters.Promotions, interceptors...)
}

// Create returns a builder for creating a Promotions entity.
func (c *PromotionsClient) Create() *PromotionsCreate {
	mutation := newPromotionsMutation(c.config, OpCreate)
	return &PromotionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Promotions entities.
func (c *PromotionsClient) CreateBulk(builders ...*PromotionsCreate) *PromotionsCreateBulk {
	return &PromotionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromotionsClient) MapCreateBulk(slice any, setFunc func(*PromotionsCreate, int)) *PromotionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromotionsCreateBulk{err: fmt.Errorf("calling to PromotionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromotionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromotionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Promotions.
func (c *PromotionsClient) Update() *PromotionsUpdate {
	mutation := newPromotionsMutation(c.config, OpUpdate)
	return &PromotionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromotionsClient) UpdateOne(pr *Promotions) *PromotionsUpdateOne {
	mutation := newPromotionsMutation(c.config, OpUpdateOne, withPromotions(pr))
	return &PromotionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromotionsClient) UpdateOneID(id int) *PromotionsUpdateOne {
	mutation := newPromotionsMutation(c.config, OpUpdateOne, withPromotionsID(id))
	return &PromotionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Promotions.
func (c *PromotionsClient) Delete() *PromotionsDelete {
	mutation := newPromotionsMutation(c.config, OpDelete)
	return &PromotionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromotionsClient) DeleteOne(pr *Promotions) *PromotionsDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromotionsClient) DeleteOneID(id int) *PromotionsDeleteOne {
	builder := c.Delete().Where(promotions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromotionsDeleteOne{builder}
}

// Query returns a query builder for Promotions.
func (c *PromotionsClient) Query() *PromotionsQuery {
	return &PromotionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromotions},
		inters: c.Interceptors(),
	}
}

// Get returns a Promotions entity by its id.
func (c *PromotionsClient) Get(ctx context.Context, id int) (*Promotions, error) {
	return c.Query().Where(promotions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromotionsClient) GetX(ctx context.Context, id int) *Promotions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPromotionHasProduct queries the promotion_has_product edge of a Promotions.
func (c *PromotionsClient) QueryPromotionHasProduct(pr *Promotions) *PromotionHasProductQuery {
	query := (&PromotionHasProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promotions.Table, promotions.FieldID, id),
			sqlgraph.To(promotionhasproduct.Table, promotionhasproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, promotions.PromotionHasProductTable, promotions.PromotionHasProductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromotionsClient) Hooks() []Hook {
	return c.hooks.Promotions
}

// Interceptors returns the client interceptors.
func (c *PromotionsClient) Interceptors() []Interceptor {
	return c.inters.Promotions
}

func (c *PromotionsClient) mutate(ctx context.Context, m *PromotionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromotionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromotionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromotionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromotionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Promotions mutation op: %q", m.Op())
	}
}

// ReferenceSourcesClient is a client for the ReferenceSources schema.
type ReferenceSourcesClient struct {
	config
}

// NewReferenceSourcesClient returns a client for the ReferenceSources from the given config.
func NewReferenceSourcesClient(c config) *ReferenceSourcesClient {
	return &ReferenceSourcesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `referencesources.Hooks(f(g(h())))`.
func (c *ReferenceSourcesClient) Use(hooks ...Hook) {
	c.hooks.ReferenceSources = append(c.hooks.ReferenceSources, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `referencesources.Intercept(f(g(h())))`.
func (c *ReferenceSourcesClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReferenceSources = append(c.inters.ReferenceSources, interceptors...)
}

// Create returns a builder for creating a ReferenceSources entity.
func (c *ReferenceSourcesClient) Create() *ReferenceSourcesCreate {
	mutation := newReferenceSourcesMutation(c.config, OpCreate)
	return &ReferenceSourcesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReferenceSources entities.
func (c *ReferenceSourcesClient) CreateBulk(builders ...*ReferenceSourcesCreate) *ReferenceSourcesCreateBulk {
	return &ReferenceSourcesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReferenceSourcesClient) MapCreateBulk(slice any, setFunc func(*ReferenceSourcesCreate, int)) *ReferenceSourcesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReferenceSourcesCreateBulk{err: fmt.Errorf("calling to ReferenceSourcesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReferenceSourcesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReferenceSourcesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReferenceSources.
func (c *ReferenceSourcesClient) Update() *ReferenceSourcesUpdate {
	mutation := newReferenceSourcesMutation(c.config, OpUpdate)
	return &ReferenceSourcesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReferenceSourcesClient) UpdateOne(rs *ReferenceSources) *ReferenceSourcesUpdateOne {
	mutation := newReferenceSourcesMutation(c.config, OpUpdateOne, withReferenceSources(rs))
	return &ReferenceSourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReferenceSourcesClient) UpdateOneID(id int) *ReferenceSourcesUpdateOne {
	mutation := newReferenceSourcesMutation(c.config, OpUpdateOne, withReferenceSourcesID(id))
	return &ReferenceSourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReferenceSources.
func (c *ReferenceSourcesClient) Delete() *ReferenceSourcesDelete {
	mutation := newReferenceSourcesMutation(c.config, OpDelete)
	return &ReferenceSourcesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReferenceSourcesClient) DeleteOne(rs *ReferenceSources) *ReferenceSourcesDeleteOne {
	return c.DeleteOneID(rs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReferenceSourcesClient) DeleteOneID(id int) *ReferenceSourcesDeleteOne {
	builder := c.Delete().Where(referencesources.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReferenceSourcesDeleteOne{builder}
}

// Query returns a query builder for ReferenceSources.
func (c *ReferenceSourcesClient) Query() *ReferenceSourcesQuery {
	return &ReferenceSourcesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReferenceSources},
		inters: c.Interceptors(),
	}
}

// Get returns a ReferenceSources entity by its id.
func (c *ReferenceSourcesClient) Get(ctx context.Context, id int) (*ReferenceSources, error) {
	return c.Query().Where(referencesources.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReferenceSourcesClient) GetX(ctx context.Context, id int) *ReferenceSources {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductReferences queries the product_references edge of a ReferenceSources.
func (c *ReferenceSourcesClient) QueryProductReferences(rs *ReferenceSources) *ProductReferencesQuery {
	query := (&ProductReferencesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(referencesources.Table, referencesources.FieldID, id),
			sqlgraph.To(productreferences.Table, productreferences.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, referencesources.ProductReferencesTable, referencesources.ProductReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(rs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReferenceSourcesClient) Hooks() []Hook {
	return c.hooks.ReferenceSources
}

// Interceptors returns the client interceptors.
func (c *ReferenceSourcesClient) Interceptors() []Interceptor {
	return c.inters.ReferenceSources
}

func (c *ReferenceSourcesClient) mutate(ctx context.Context, m *ReferenceSourcesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReferenceSourcesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReferenceSourcesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReferenceSourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReferenceSourcesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReferenceSources mutation op: %q", m.Op())
	}
}

// ToolHasProductClient is a client for the ToolHasProduct schema.
type ToolHasProductClient struct {
	config
}

// NewToolHasProductClient returns a client for the ToolHasProduct from the given config.
func NewToolHasProductClient(c config) *ToolHasProductClient {
	return &ToolHasProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `toolhasproduct.Hooks(f(g(h())))`.
func (c *ToolHasProductClient) Use(hooks ...Hook) {
	c.hooks.ToolHasProduct = append(c.hooks.ToolHasProduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `toolhasproduct.Intercept(f(g(h())))`.
func (c *ToolHasProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.ToolHasProduct = append(c.inters.ToolHasProduct, interceptors...)
}

// Create returns a builder for creating a ToolHasProduct entity.
func (c *ToolHasProductClient) Create() *ToolHasProductCreate {
	mutation := newToolHasProductMutation(c.config, OpCreate)
	return &ToolHasProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ToolHasProduct entities.
func (c *ToolHasProductClient) CreateBulk(builders ...*ToolHasProductCreate) *ToolHasProductCreateBulk {
	return &ToolHasProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolHasProductClient) MapCreateBulk(slice any, setFunc func(*ToolHasProductCreate, int)) *ToolHasProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolHasProductCreateBulk{err: fmt.Errorf("calling to ToolHasProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolHasProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolHasProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ToolHasProduct.
func (c *ToolHasProductClient) Update() *ToolHasProductUpdate {
	mutation := newToolHasProductMutation(c.config, OpUpdate)
	return &ToolHasProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolHasProductClient) UpdateOne(thp *ToolHasProduct) *ToolHasProductUpdateOne {
	mutation := newToolHasProductMutation(c.config, OpUpdateOne, withToolHasProduct(thp))
	return &ToolHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolHasProductClient) UpdateOneID(id int) *ToolHasProductUpdateOne {
	mutation := newToolHasProductMutation(c.config, OpUpdateOne, withToolHasProductID(id))
	return &ToolHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ToolHasProduct.
func (c *ToolHasProductClient) Delete() *ToolHasProductDelete {
	mutation := newToolHasProductMutation(c.config, OpDelete)
	return &ToolHasProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolHasProductClient) DeleteOne(thp *ToolHasProduct) *ToolHasProductDeleteOne {
	return c.DeleteOneID(thp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolHasProductClient) DeleteOneID(id int) *ToolHasProductDeleteOne {
	builder := c.Delete().Where(toolhasproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolHasProductDeleteOne{builder}
}

// Query returns a query builder for ToolHasProduct.
func (c *ToolHasProductClient) Query() *ToolHasProductQuery {
	return &ToolHasProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToolHasProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a ToolHasProduct entity by its id.
func (c *ToolHasProductClient) Get(ctx context.Context, id int) (*ToolHasProduct, error) {
	return c.Query().Where(toolhasproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolHasProductClient) GetX(ctx context.Context, id int) *ToolHasProduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ToolHasProduct.
func (c *ToolHasProductClient) QueryProduct(thp *ToolHasProduct) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := thp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(toolhasproduct.Table, toolhasproduct.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, toolhasproduct.ProductTable, toolhasproduct.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(thp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTool queries the tool edge of a ToolHasProduct.
func (c *ToolHasProductClient) QueryTool(thp *ToolHasProduct) *ToolsQuery {
	query := (&ToolsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := thp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(toolhasproduct.Table, toolhasproduct.FieldID, id),
			sqlgraph.To(tools.Table, tools.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, toolhasproduct.ToolTable, toolhasproduct.ToolColumn),
		)
		fromV = sqlgraph.Neighbors(thp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolHasProductClient) Hooks() []Hook {
	return c.hooks.ToolHasProduct
}

// Interceptors returns the client interceptors.
func (c *ToolHasProductClient) Interceptors() []Interceptor {
	return c.inters.ToolHasProduct
}

func (c *ToolHasProductClient) mutate(ctx context.Context, m *ToolHasProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolHasProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolHasProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolHasProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolHasProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ToolHasProduct mutation op: %q", m.Op())
	}
}

// ToolsClient is a client for the Tools schema.
type ToolsClient struct {
	config
}

// NewToolsClient returns a client for the Tools from the given config.
func NewToolsClient(c config) *ToolsClient {
	return &ToolsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tools.Hooks(f(g(h())))`.
func (c *ToolsClient) Use(hooks ...Hook) {
	c.hooks.Tools = append(c.hooks.Tools, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tools.Intercept(f(g(h())))`.
func (c *ToolsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tools = append(c.inters.Tools, interceptors...)
}

// Create returns a builder for creating a Tools entity.
func (c *ToolsClient) Create() *ToolsCreate {
	mutation := newToolsMutation(c.config, OpCreate)
	return &ToolsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tools entities.
func (c *ToolsClient) CreateBulk(builders ...*ToolsCreate) *ToolsCreateBulk {
	return &ToolsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolsClient) MapCreateBulk(slice any, setFunc func(*ToolsCreate, int)) *ToolsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolsCreateBulk{err: fmt.Errorf("calling to ToolsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tools.
func (c *ToolsClient) Update() *ToolsUpdate {
	mutation := newToolsMutation(c.config, OpUpdate)
	return &ToolsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolsClient) UpdateOne(t *Tools) *ToolsUpdateOne {
	mutation := newToolsMutation(c.config, OpUpdateOne, withTools(t))
	return &ToolsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolsClient) UpdateOneID(id int) *ToolsUpdateOne {
	mutation := newToolsMutation(c.config, OpUpdateOne, withToolsID(id))
	return &ToolsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tools.
func (c *ToolsClient) Delete() *ToolsDelete {
	mutation := newToolsMutation(c.config, OpDelete)
	return &ToolsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolsClient) DeleteOne(t *Tools) *ToolsDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolsClient) DeleteOneID(id int) *ToolsDeleteOne {
	builder := c.Delete().Where(tools.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolsDeleteOne{builder}
}

// Query returns a query builder for Tools.
func (c *ToolsClient) Query() *ToolsQuery {
	return &ToolsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTools},
		inters: c.Interceptors(),
	}
}

// Get returns a Tools entity by its id.
func (c *ToolsClient) Get(ctx context.Context, id int) (*Tools, error) {
	return c.Query().Where(tools.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolsClient) GetX(ctx context.Context, id int) *Tools {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryToolHasProduct queries the tool_has_product edge of a Tools.
func (c *ToolsClient) QueryToolHasProduct(t *Tools) *ToolHasProductQuery {
	query := (&ToolHasProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tools.Table, tools.FieldID, id),
			sqlgraph.To(toolhasproduct.Table, toolhasproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tools.ToolHasProductTable, tools.ToolHasProductColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolsClient) Hooks() []Hook {
	return c.hooks.Tools
}

// Interceptors returns the client interceptors.
func (c *ToolsClient) Interceptors() []Interceptor {
	return c.inters.Tools
}

func (c *ToolsClient) mutate(ctx context.Context, m *ToolsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tools mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a User.
func (c *UserClient) QueryProducts(u *User) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProductsTable, user.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedProducts queries the created_products edge of a User.
func (c *UserClient) QueryCreatedProducts(u *User) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedProductsTable, user.CreatedProductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedProducts queries the updated_products edge of a User.
func (c *UserClient) QueryUpdatedProducts(u *User) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UpdatedProductsTable, user.UpdatedProductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeletedProducts queries the deleted_products edge of a User.
func (c *UserClient) QueryDeletedProducts(u *User) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DeletedProductsTable, user.DeletedProductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VariantTypeClient is a client for the VariantType schema.
type VariantTypeClient struct {
	config
}

// NewVariantTypeClient returns a client for the VariantType from the given config.
func NewVariantTypeClient(c config) *VariantTypeClient {
	return &VariantTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `varianttype.Hooks(f(g(h())))`.
func (c *VariantTypeClient) Use(hooks ...Hook) {
	c.hooks.VariantType = append(c.hooks.VariantType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `varianttype.Intercept(f(g(h())))`.
func (c *VariantTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.VariantType = append(c.inters.VariantType, interceptors...)
}

// Create returns a builder for creating a VariantType entity.
func (c *VariantTypeClient) Create() *VariantTypeCreate {
	mutation := newVariantTypeMutation(c.config, OpCreate)
	return &VariantTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VariantType entities.
func (c *VariantTypeClient) CreateBulk(builders ...*VariantTypeCreate) *VariantTypeCreateBulk {
	return &VariantTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VariantTypeClient) MapCreateBulk(slice any, setFunc func(*VariantTypeCreate, int)) *VariantTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VariantTypeCreateBulk{err: fmt.Errorf("calling to VariantTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VariantTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VariantTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VariantType.
func (c *VariantTypeClient) Update() *VariantTypeUpdate {
	mutation := newVariantTypeMutation(c.config, OpUpdate)
	return &VariantTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VariantTypeClient) UpdateOne(vt *VariantType) *VariantTypeUpdateOne {
	mutation := newVariantTypeMutation(c.config, OpUpdateOne, withVariantType(vt))
	return &VariantTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VariantTypeClient) UpdateOneID(id int) *VariantTypeUpdateOne {
	mutation := newVariantTypeMutation(c.config, OpUpdateOne, withVariantTypeID(id))
	return &VariantTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VariantType.
func (c *VariantTypeClient) Delete() *VariantTypeDelete {
	mutation := newVariantTypeMutation(c.config, OpDelete)
	return &VariantTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VariantTypeClient) DeleteOne(vt *VariantType) *VariantTypeDeleteOne {
	return c.DeleteOneID(vt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VariantTypeClient) DeleteOneID(id int) *VariantTypeDeleteOne {
	builder := c.Delete().Where(varianttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VariantTypeDeleteOne{builder}
}

// Query returns a query builder for VariantType.
func (c *VariantTypeClient) Query() *VariantTypeQuery {
	return &VariantTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVariantType},
		inters: c.Interceptors(),
	}
}

// Get returns a VariantType entity by its id.
func (c *VariantTypeClient) Get(ctx context.Context, id int) (*VariantType, error) {
	return c.Query().Where(varianttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VariantTypeClient) GetX(ctx context.Context, id int) *VariantType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a VariantType.
func (c *VariantTypeClient) QueryProducts(vt *VariantType) *ProductsQuery {
	query := (&ProductsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varianttype.Table, varianttype.FieldID, id),
			sqlgraph.To(products.Table, products.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, varianttype.ProductsTable, varianttype.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(vt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VariantTypeClient) Hooks() []Hook {
	return c.hooks.VariantType
}

// Interceptors returns the client interceptors.
func (c *VariantTypeClient) Interceptors() []Interceptor {
	return c.inters.VariantType
}

func (c *VariantTypeClient) mutate(ctx context.Context, m *VariantTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VariantTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VariantTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VariantTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VariantTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VariantType mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Brand, Category, Features, FeaturesUnitValues, FeaturesValues,
		FeaturesValuesTypes, ImageFolderPath, ImageFolderSource, Images, InfoTypes,
		PriceType, ProductHasFeature, ProductHasImage, ProductHasInfo,
		ProductHasProductReference, ProductInfo, ProductPrices, ProductReferences,
		Products, PromotionHasProduct, Promotions, ReferenceSources, ToolHasProduct,
		Tools, User, VariantType []ent.Hook
	}
	inters struct {
		Brand, Category, Features, FeaturesUnitValues, FeaturesValues,
		FeaturesValuesTypes, ImageFolderPath, ImageFolderSource, Images, InfoTypes,
		PriceType, ProductHasFeature, ProductHasImage, ProductHasInfo,
		ProductHasProductReference, ProductInfo, ProductPrices, ProductReferences,
		Products, PromotionHasProduct, Promotions, ReferenceSources, ToolHasProduct,
		Tools, User, VariantType []ent.Interceptor
	}
)
