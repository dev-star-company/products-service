// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"products-service/internal/app/ent/brand"
	"products-service/internal/app/ent/category"
	"products-service/internal/app/ent/images"
	"products-service/internal/app/ent/predicate"
	"products-service/internal/app/ent/producthasfeature"
	"products-service/internal/app/ent/producthasimage"
	"products-service/internal/app/ent/producthasinfo"
	"products-service/internal/app/ent/producthasproductreference"
	"products-service/internal/app/ent/productprices"
	"products-service/internal/app/ent/productreferences"
	"products-service/internal/app/ent/products"
	"products-service/internal/app/ent/promotionhasproduct"
	"products-service/internal/app/ent/toolhasproduct"
	"products-service/internal/app/ent/varianttype"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ProductsUpdate is the builder for updating Products entities.
type ProductsUpdate struct {
	config
	hooks    []Hook
	mutation *ProductsMutation
}

// Where appends a list predicates to the ProductsUpdate builder.
func (pu *ProductsUpdate) Where(ps ...predicate.Products) *ProductsUpdate {
	pu.mutation.Where(ps...)
	return pu
}

// SetUpdatedAt sets the "updated_at" field.
func (pu *ProductsUpdate) SetUpdatedAt(t time.Time) *ProductsUpdate {
	pu.mutation.SetUpdatedAt(t)
	return pu
}

// SetDeletedAt sets the "deleted_at" field.
func (pu *ProductsUpdate) SetDeletedAt(t time.Time) *ProductsUpdate {
	pu.mutation.SetDeletedAt(t)
	return pu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableDeletedAt(t *time.Time) *ProductsUpdate {
	if t != nil {
		pu.SetDeletedAt(*t)
	}
	return pu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (pu *ProductsUpdate) ClearDeletedAt() *ProductsUpdate {
	pu.mutation.ClearDeletedAt()
	return pu
}

// SetUpdatedBy sets the "updated_by" field.
func (pu *ProductsUpdate) SetUpdatedBy(i int) *ProductsUpdate {
	pu.mutation.ResetUpdatedBy()
	pu.mutation.SetUpdatedBy(i)
	return pu
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableUpdatedBy(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetUpdatedBy(*i)
	}
	return pu
}

// AddUpdatedBy adds i to the "updated_by" field.
func (pu *ProductsUpdate) AddUpdatedBy(i int) *ProductsUpdate {
	pu.mutation.AddUpdatedBy(i)
	return pu
}

// SetDeletedBy sets the "deleted_by" field.
func (pu *ProductsUpdate) SetDeletedBy(i int) *ProductsUpdate {
	pu.mutation.ResetDeletedBy()
	pu.mutation.SetDeletedBy(i)
	return pu
}

// SetNillableDeletedBy sets the "deleted_by" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableDeletedBy(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetDeletedBy(*i)
	}
	return pu
}

// AddDeletedBy adds i to the "deleted_by" field.
func (pu *ProductsUpdate) AddDeletedBy(i int) *ProductsUpdate {
	pu.mutation.AddDeletedBy(i)
	return pu
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (pu *ProductsUpdate) ClearDeletedBy() *ProductsUpdate {
	pu.mutation.ClearDeletedBy()
	return pu
}

// SetCategoryID sets the "category_id" field.
func (pu *ProductsUpdate) SetCategoryID(i int) *ProductsUpdate {
	pu.mutation.ResetCategoryID()
	pu.mutation.SetCategoryID(i)
	return pu
}

// SetNillableCategoryID sets the "category_id" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableCategoryID(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetCategoryID(*i)
	}
	return pu
}

// AddCategoryID adds i to the "category_id" field.
func (pu *ProductsUpdate) AddCategoryID(i int) *ProductsUpdate {
	pu.mutation.AddCategoryID(i)
	return pu
}

// ClearCategoryID clears the value of the "category_id" field.
func (pu *ProductsUpdate) ClearCategoryID() *ProductsUpdate {
	pu.mutation.ClearCategoryID()
	return pu
}

// SetBrandID sets the "brand_id" field.
func (pu *ProductsUpdate) SetBrandID(i int) *ProductsUpdate {
	pu.mutation.ResetBrandID()
	pu.mutation.SetBrandID(i)
	return pu
}

// SetNillableBrandID sets the "brand_id" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableBrandID(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetBrandID(*i)
	}
	return pu
}

// AddBrandID adds i to the "brand_id" field.
func (pu *ProductsUpdate) AddBrandID(i int) *ProductsUpdate {
	pu.mutation.AddBrandID(i)
	return pu
}

// ClearBrandID clears the value of the "brand_id" field.
func (pu *ProductsUpdate) ClearBrandID() *ProductsUpdate {
	pu.mutation.ClearBrandID()
	return pu
}

// SetVariantTypeID sets the "variant_type_id" field.
func (pu *ProductsUpdate) SetVariantTypeID(i int) *ProductsUpdate {
	pu.mutation.ResetVariantTypeID()
	pu.mutation.SetVariantTypeID(i)
	return pu
}

// SetNillableVariantTypeID sets the "variant_type_id" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableVariantTypeID(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetVariantTypeID(*i)
	}
	return pu
}

// AddVariantTypeID adds i to the "variant_type_id" field.
func (pu *ProductsUpdate) AddVariantTypeID(i int) *ProductsUpdate {
	pu.mutation.AddVariantTypeID(i)
	return pu
}

// ClearVariantTypeID clears the value of the "variant_type_id" field.
func (pu *ProductsUpdate) ClearVariantTypeID() *ProductsUpdate {
	pu.mutation.ClearVariantTypeID()
	return pu
}

// SetProductReferencesID sets the "product_references_id" field.
func (pu *ProductsUpdate) SetProductReferencesID(i int) *ProductsUpdate {
	pu.mutation.ResetProductReferencesID()
	pu.mutation.SetProductReferencesID(i)
	return pu
}

// SetNillableProductReferencesID sets the "product_references_id" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableProductReferencesID(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetProductReferencesID(*i)
	}
	return pu
}

// AddProductReferencesID adds i to the "product_references_id" field.
func (pu *ProductsUpdate) AddProductReferencesID(i int) *ProductsUpdate {
	pu.mutation.AddProductReferencesID(i)
	return pu
}

// ClearProductReferencesID clears the value of the "product_references_id" field.
func (pu *ProductsUpdate) ClearProductReferencesID() *ProductsUpdate {
	pu.mutation.ClearProductReferencesID()
	return pu
}

// SetImageID sets the "image_id" field.
func (pu *ProductsUpdate) SetImageID(i int) *ProductsUpdate {
	pu.mutation.ResetImageID()
	pu.mutation.SetImageID(i)
	return pu
}

// SetNillableImageID sets the "image_id" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableImageID(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetImageID(*i)
	}
	return pu
}

// AddImageID adds i to the "image_id" field.
func (pu *ProductsUpdate) AddImageID(i int) *ProductsUpdate {
	pu.mutation.AddImageID(i)
	return pu
}

// SetName sets the "name" field.
func (pu *ProductsUpdate) SetName(s string) *ProductsUpdate {
	pu.mutation.SetName(s)
	return pu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableName(s *string) *ProductsUpdate {
	if s != nil {
		pu.SetName(*s)
	}
	return pu
}

// SetStock sets the "stock" field.
func (pu *ProductsUpdate) SetStock(i int) *ProductsUpdate {
	pu.mutation.ResetStock()
	pu.mutation.SetStock(i)
	return pu
}

// SetNillableStock sets the "stock" field if the given value is not nil.
func (pu *ProductsUpdate) SetNillableStock(i *int) *ProductsUpdate {
	if i != nil {
		pu.SetStock(*i)
	}
	return pu
}

// AddStock adds i to the "stock" field.
func (pu *ProductsUpdate) AddStock(i int) *ProductsUpdate {
	pu.mutation.AddStock(i)
	return pu
}

// SetCategory sets the "category" edge to the Category entity.
func (pu *ProductsUpdate) SetCategory(c *Category) *ProductsUpdate {
	return pu.SetCategoryID(c.ID)
}

// SetBrand sets the "brand" edge to the Brand entity.
func (pu *ProductsUpdate) SetBrand(b *Brand) *ProductsUpdate {
	return pu.SetBrandID(b.ID)
}

// SetVariantType sets the "variant_type" edge to the VariantType entity.
func (pu *ProductsUpdate) SetVariantType(v *VariantType) *ProductsUpdate {
	return pu.SetVariantTypeID(v.ID)
}

// AddProductReferenceIDs adds the "product_references" edge to the ProductReferences entity by IDs.
func (pu *ProductsUpdate) AddProductReferenceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductReferenceIDs(ids...)
	return pu
}

// AddProductReferences adds the "product_references" edges to the ProductReferences entity.
func (pu *ProductsUpdate) AddProductReferences(p ...*ProductReferences) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductReferenceIDs(ids...)
}

// AddImageIDs adds the "images" edge to the Images entity by IDs.
func (pu *ProductsUpdate) AddImageIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddImageIDs(ids...)
	return pu
}

// AddImages adds the "images" edges to the Images entity.
func (pu *ProductsUpdate) AddImages(i ...*Images) *ProductsUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return pu.AddImageIDs(ids...)
}

// AddProductHasImageIDs adds the "product_has_image" edge to the ProductHasImage entity by IDs.
func (pu *ProductsUpdate) AddProductHasImageIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductHasImageIDs(ids...)
	return pu
}

// AddProductHasImage adds the "product_has_image" edges to the ProductHasImage entity.
func (pu *ProductsUpdate) AddProductHasImage(p ...*ProductHasImage) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductHasImageIDs(ids...)
}

// AddPromotionHasProductIDs adds the "promotion_has_product" edge to the PromotionHasProduct entity by IDs.
func (pu *ProductsUpdate) AddPromotionHasProductIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddPromotionHasProductIDs(ids...)
	return pu
}

// AddPromotionHasProduct adds the "promotion_has_product" edges to the PromotionHasProduct entity.
func (pu *ProductsUpdate) AddPromotionHasProduct(p ...*PromotionHasProduct) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddPromotionHasProductIDs(ids...)
}

// AddToolHasProductIDs adds the "tool_has_product" edge to the ToolHasProduct entity by IDs.
func (pu *ProductsUpdate) AddToolHasProductIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddToolHasProductIDs(ids...)
	return pu
}

// AddToolHasProduct adds the "tool_has_product" edges to the ToolHasProduct entity.
func (pu *ProductsUpdate) AddToolHasProduct(t ...*ToolHasProduct) *ProductsUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return pu.AddToolHasProductIDs(ids...)
}

// AddProductHasFeatureIDs adds the "product_has_feature" edge to the ProductHasFeature entity by IDs.
func (pu *ProductsUpdate) AddProductHasFeatureIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductHasFeatureIDs(ids...)
	return pu
}

// AddProductHasFeature adds the "product_has_feature" edges to the ProductHasFeature entity.
func (pu *ProductsUpdate) AddProductHasFeature(p ...*ProductHasFeature) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductHasFeatureIDs(ids...)
}

// AddProductHasInfoIDs adds the "product_has_info" edge to the ProductHasInfo entity by IDs.
func (pu *ProductsUpdate) AddProductHasInfoIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductHasInfoIDs(ids...)
	return pu
}

// AddProductHasInfo adds the "product_has_info" edges to the ProductHasInfo entity.
func (pu *ProductsUpdate) AddProductHasInfo(p ...*ProductHasInfo) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductHasInfoIDs(ids...)
}

// AddProductHasProductReferenceIDs adds the "product_has_product_reference" edge to the ProductHasProductReference entity by IDs.
func (pu *ProductsUpdate) AddProductHasProductReferenceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductHasProductReferenceIDs(ids...)
	return pu
}

// AddProductHasProductReference adds the "product_has_product_reference" edges to the ProductHasProductReference entity.
func (pu *ProductsUpdate) AddProductHasProductReference(p ...*ProductHasProductReference) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductHasProductReferenceIDs(ids...)
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrices entity by IDs.
func (pu *ProductsUpdate) AddProductPriceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.AddProductPriceIDs(ids...)
	return pu
}

// AddProductPrices adds the "product_prices" edges to the ProductPrices entity.
func (pu *ProductsUpdate) AddProductPrices(p ...*ProductPrices) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.AddProductPriceIDs(ids...)
}

// Mutation returns the ProductsMutation object of the builder.
func (pu *ProductsUpdate) Mutation() *ProductsMutation {
	return pu.mutation
}

// ClearCategory clears the "category" edge to the Category entity.
func (pu *ProductsUpdate) ClearCategory() *ProductsUpdate {
	pu.mutation.ClearCategory()
	return pu
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (pu *ProductsUpdate) ClearBrand() *ProductsUpdate {
	pu.mutation.ClearBrand()
	return pu
}

// ClearVariantType clears the "variant_type" edge to the VariantType entity.
func (pu *ProductsUpdate) ClearVariantType() *ProductsUpdate {
	pu.mutation.ClearVariantType()
	return pu
}

// ClearProductReferences clears all "product_references" edges to the ProductReferences entity.
func (pu *ProductsUpdate) ClearProductReferences() *ProductsUpdate {
	pu.mutation.ClearProductReferences()
	return pu
}

// RemoveProductReferenceIDs removes the "product_references" edge to ProductReferences entities by IDs.
func (pu *ProductsUpdate) RemoveProductReferenceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductReferenceIDs(ids...)
	return pu
}

// RemoveProductReferences removes "product_references" edges to ProductReferences entities.
func (pu *ProductsUpdate) RemoveProductReferences(p ...*ProductReferences) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductReferenceIDs(ids...)
}

// ClearImages clears all "images" edges to the Images entity.
func (pu *ProductsUpdate) ClearImages() *ProductsUpdate {
	pu.mutation.ClearImages()
	return pu
}

// RemoveImageIDs removes the "images" edge to Images entities by IDs.
func (pu *ProductsUpdate) RemoveImageIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveImageIDs(ids...)
	return pu
}

// RemoveImages removes "images" edges to Images entities.
func (pu *ProductsUpdate) RemoveImages(i ...*Images) *ProductsUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return pu.RemoveImageIDs(ids...)
}

// ClearProductHasImage clears all "product_has_image" edges to the ProductHasImage entity.
func (pu *ProductsUpdate) ClearProductHasImage() *ProductsUpdate {
	pu.mutation.ClearProductHasImage()
	return pu
}

// RemoveProductHasImageIDs removes the "product_has_image" edge to ProductHasImage entities by IDs.
func (pu *ProductsUpdate) RemoveProductHasImageIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductHasImageIDs(ids...)
	return pu
}

// RemoveProductHasImage removes "product_has_image" edges to ProductHasImage entities.
func (pu *ProductsUpdate) RemoveProductHasImage(p ...*ProductHasImage) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductHasImageIDs(ids...)
}

// ClearPromotionHasProduct clears all "promotion_has_product" edges to the PromotionHasProduct entity.
func (pu *ProductsUpdate) ClearPromotionHasProduct() *ProductsUpdate {
	pu.mutation.ClearPromotionHasProduct()
	return pu
}

// RemovePromotionHasProductIDs removes the "promotion_has_product" edge to PromotionHasProduct entities by IDs.
func (pu *ProductsUpdate) RemovePromotionHasProductIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemovePromotionHasProductIDs(ids...)
	return pu
}

// RemovePromotionHasProduct removes "promotion_has_product" edges to PromotionHasProduct entities.
func (pu *ProductsUpdate) RemovePromotionHasProduct(p ...*PromotionHasProduct) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemovePromotionHasProductIDs(ids...)
}

// ClearToolHasProduct clears all "tool_has_product" edges to the ToolHasProduct entity.
func (pu *ProductsUpdate) ClearToolHasProduct() *ProductsUpdate {
	pu.mutation.ClearToolHasProduct()
	return pu
}

// RemoveToolHasProductIDs removes the "tool_has_product" edge to ToolHasProduct entities by IDs.
func (pu *ProductsUpdate) RemoveToolHasProductIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveToolHasProductIDs(ids...)
	return pu
}

// RemoveToolHasProduct removes "tool_has_product" edges to ToolHasProduct entities.
func (pu *ProductsUpdate) RemoveToolHasProduct(t ...*ToolHasProduct) *ProductsUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return pu.RemoveToolHasProductIDs(ids...)
}

// ClearProductHasFeature clears all "product_has_feature" edges to the ProductHasFeature entity.
func (pu *ProductsUpdate) ClearProductHasFeature() *ProductsUpdate {
	pu.mutation.ClearProductHasFeature()
	return pu
}

// RemoveProductHasFeatureIDs removes the "product_has_feature" edge to ProductHasFeature entities by IDs.
func (pu *ProductsUpdate) RemoveProductHasFeatureIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductHasFeatureIDs(ids...)
	return pu
}

// RemoveProductHasFeature removes "product_has_feature" edges to ProductHasFeature entities.
func (pu *ProductsUpdate) RemoveProductHasFeature(p ...*ProductHasFeature) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductHasFeatureIDs(ids...)
}

// ClearProductHasInfo clears all "product_has_info" edges to the ProductHasInfo entity.
func (pu *ProductsUpdate) ClearProductHasInfo() *ProductsUpdate {
	pu.mutation.ClearProductHasInfo()
	return pu
}

// RemoveProductHasInfoIDs removes the "product_has_info" edge to ProductHasInfo entities by IDs.
func (pu *ProductsUpdate) RemoveProductHasInfoIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductHasInfoIDs(ids...)
	return pu
}

// RemoveProductHasInfo removes "product_has_info" edges to ProductHasInfo entities.
func (pu *ProductsUpdate) RemoveProductHasInfo(p ...*ProductHasInfo) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductHasInfoIDs(ids...)
}

// ClearProductHasProductReference clears all "product_has_product_reference" edges to the ProductHasProductReference entity.
func (pu *ProductsUpdate) ClearProductHasProductReference() *ProductsUpdate {
	pu.mutation.ClearProductHasProductReference()
	return pu
}

// RemoveProductHasProductReferenceIDs removes the "product_has_product_reference" edge to ProductHasProductReference entities by IDs.
func (pu *ProductsUpdate) RemoveProductHasProductReferenceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductHasProductReferenceIDs(ids...)
	return pu
}

// RemoveProductHasProductReference removes "product_has_product_reference" edges to ProductHasProductReference entities.
func (pu *ProductsUpdate) RemoveProductHasProductReference(p ...*ProductHasProductReference) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductHasProductReferenceIDs(ids...)
}

// ClearProductPrices clears all "product_prices" edges to the ProductPrices entity.
func (pu *ProductsUpdate) ClearProductPrices() *ProductsUpdate {
	pu.mutation.ClearProductPrices()
	return pu
}

// RemoveProductPriceIDs removes the "product_prices" edge to ProductPrices entities by IDs.
func (pu *ProductsUpdate) RemoveProductPriceIDs(ids ...int) *ProductsUpdate {
	pu.mutation.RemoveProductPriceIDs(ids...)
	return pu
}

// RemoveProductPrices removes "product_prices" edges to ProductPrices entities.
func (pu *ProductsUpdate) RemoveProductPrices(p ...*ProductPrices) *ProductsUpdate {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pu.RemoveProductPriceIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (pu *ProductsUpdate) Save(ctx context.Context) (int, error) {
	pu.defaults()
	return withHooks(ctx, pu.sqlSave, pu.mutation, pu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (pu *ProductsUpdate) SaveX(ctx context.Context) int {
	affected, err := pu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (pu *ProductsUpdate) Exec(ctx context.Context) error {
	_, err := pu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (pu *ProductsUpdate) ExecX(ctx context.Context) {
	if err := pu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (pu *ProductsUpdate) defaults() {
	if _, ok := pu.mutation.UpdatedAt(); !ok {
		v := products.UpdateDefaultUpdatedAt()
		pu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (pu *ProductsUpdate) check() error {
	if v, ok := pu.mutation.UpdatedBy(); ok {
		if err := products.UpdatedByValidator(v); err != nil {
			return &ValidationError{Name: "updated_by", err: fmt.Errorf(`ent: validator failed for field "Products.updated_by": %w`, err)}
		}
	}
	return nil
}

func (pu *ProductsUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := pu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(products.Table, products.Columns, sqlgraph.NewFieldSpec(products.FieldID, field.TypeInt))
	if ps := pu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := pu.mutation.UpdatedAt(); ok {
		_spec.SetField(products.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := pu.mutation.DeletedAt(); ok {
		_spec.SetField(products.FieldDeletedAt, field.TypeTime, value)
	}
	if pu.mutation.DeletedAtCleared() {
		_spec.ClearField(products.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := pu.mutation.UpdatedBy(); ok {
		_spec.SetField(products.FieldUpdatedBy, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedUpdatedBy(); ok {
		_spec.AddField(products.FieldUpdatedBy, field.TypeInt, value)
	}
	if value, ok := pu.mutation.DeletedBy(); ok {
		_spec.SetField(products.FieldDeletedBy, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedDeletedBy(); ok {
		_spec.AddField(products.FieldDeletedBy, field.TypeInt, value)
	}
	if pu.mutation.DeletedByCleared() {
		_spec.ClearField(products.FieldDeletedBy, field.TypeInt)
	}
	if value, ok := pu.mutation.CategoryID(); ok {
		_spec.SetField(products.FieldCategoryID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedCategoryID(); ok {
		_spec.AddField(products.FieldCategoryID, field.TypeInt, value)
	}
	if pu.mutation.CategoryIDCleared() {
		_spec.ClearField(products.FieldCategoryID, field.TypeInt)
	}
	if value, ok := pu.mutation.BrandID(); ok {
		_spec.SetField(products.FieldBrandID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedBrandID(); ok {
		_spec.AddField(products.FieldBrandID, field.TypeInt, value)
	}
	if pu.mutation.BrandIDCleared() {
		_spec.ClearField(products.FieldBrandID, field.TypeInt)
	}
	if value, ok := pu.mutation.VariantTypeID(); ok {
		_spec.SetField(products.FieldVariantTypeID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedVariantTypeID(); ok {
		_spec.AddField(products.FieldVariantTypeID, field.TypeInt, value)
	}
	if pu.mutation.VariantTypeIDCleared() {
		_spec.ClearField(products.FieldVariantTypeID, field.TypeInt)
	}
	if value, ok := pu.mutation.ProductReferencesID(); ok {
		_spec.SetField(products.FieldProductReferencesID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedProductReferencesID(); ok {
		_spec.AddField(products.FieldProductReferencesID, field.TypeInt, value)
	}
	if pu.mutation.ProductReferencesIDCleared() {
		_spec.ClearField(products.FieldProductReferencesID, field.TypeInt)
	}
	if value, ok := pu.mutation.ImageID(); ok {
		_spec.SetField(products.FieldImageID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedImageID(); ok {
		_spec.AddField(products.FieldImageID, field.TypeInt, value)
	}
	if value, ok := pu.mutation.Name(); ok {
		_spec.SetField(products.FieldName, field.TypeString, value)
	}
	if value, ok := pu.mutation.Stock(); ok {
		_spec.SetField(products.FieldStock, field.TypeInt, value)
	}
	if value, ok := pu.mutation.AddedStock(); ok {
		_spec.AddField(products.FieldStock, field.TypeInt, value)
	}
	if pu.mutation.CategoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.CategoryTable,
			Columns: []string{products.CategoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(category.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.CategoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.CategoryTable,
			Columns: []string{products.CategoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(category.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.BrandCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.BrandTable,
			Columns: []string{products.BrandColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(brand.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.BrandIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.BrandTable,
			Columns: []string{products.BrandColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(brand.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.VariantTypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.VariantTypeTable,
			Columns: []string{products.VariantTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(varianttype.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.VariantTypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.VariantTypeTable,
			Columns: []string{products.VariantTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(varianttype.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductReferencesIDs(); len(nodes) > 0 && !pu.mutation.ProductReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedImagesIDs(); len(nodes) > 0 && !pu.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ImagesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductHasImageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductHasImageIDs(); len(nodes) > 0 && !pu.mutation.ProductHasImageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductHasImageIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.PromotionHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedPromotionHasProductIDs(); len(nodes) > 0 && !pu.mutation.PromotionHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.PromotionHasProductIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ToolHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedToolHasProductIDs(); len(nodes) > 0 && !pu.mutation.ToolHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ToolHasProductIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductHasFeatureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductHasFeatureIDs(); len(nodes) > 0 && !pu.mutation.ProductHasFeatureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductHasFeatureIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductHasInfoCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductHasInfoIDs(); len(nodes) > 0 && !pu.mutation.ProductHasInfoCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductHasInfoIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductHasProductReferenceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductHasProductReferenceIDs(); len(nodes) > 0 && !pu.mutation.ProductHasProductReferenceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductHasProductReferenceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pu.mutation.ProductPricesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.RemovedProductPricesIDs(); len(nodes) > 0 && !pu.mutation.ProductPricesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pu.mutation.ProductPricesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, pu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{products.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	pu.mutation.done = true
	return n, nil
}

// ProductsUpdateOne is the builder for updating a single Products entity.
type ProductsUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ProductsMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (puo *ProductsUpdateOne) SetUpdatedAt(t time.Time) *ProductsUpdateOne {
	puo.mutation.SetUpdatedAt(t)
	return puo
}

// SetDeletedAt sets the "deleted_at" field.
func (puo *ProductsUpdateOne) SetDeletedAt(t time.Time) *ProductsUpdateOne {
	puo.mutation.SetDeletedAt(t)
	return puo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableDeletedAt(t *time.Time) *ProductsUpdateOne {
	if t != nil {
		puo.SetDeletedAt(*t)
	}
	return puo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (puo *ProductsUpdateOne) ClearDeletedAt() *ProductsUpdateOne {
	puo.mutation.ClearDeletedAt()
	return puo
}

// SetUpdatedBy sets the "updated_by" field.
func (puo *ProductsUpdateOne) SetUpdatedBy(i int) *ProductsUpdateOne {
	puo.mutation.ResetUpdatedBy()
	puo.mutation.SetUpdatedBy(i)
	return puo
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableUpdatedBy(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetUpdatedBy(*i)
	}
	return puo
}

// AddUpdatedBy adds i to the "updated_by" field.
func (puo *ProductsUpdateOne) AddUpdatedBy(i int) *ProductsUpdateOne {
	puo.mutation.AddUpdatedBy(i)
	return puo
}

// SetDeletedBy sets the "deleted_by" field.
func (puo *ProductsUpdateOne) SetDeletedBy(i int) *ProductsUpdateOne {
	puo.mutation.ResetDeletedBy()
	puo.mutation.SetDeletedBy(i)
	return puo
}

// SetNillableDeletedBy sets the "deleted_by" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableDeletedBy(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetDeletedBy(*i)
	}
	return puo
}

// AddDeletedBy adds i to the "deleted_by" field.
func (puo *ProductsUpdateOne) AddDeletedBy(i int) *ProductsUpdateOne {
	puo.mutation.AddDeletedBy(i)
	return puo
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (puo *ProductsUpdateOne) ClearDeletedBy() *ProductsUpdateOne {
	puo.mutation.ClearDeletedBy()
	return puo
}

// SetCategoryID sets the "category_id" field.
func (puo *ProductsUpdateOne) SetCategoryID(i int) *ProductsUpdateOne {
	puo.mutation.ResetCategoryID()
	puo.mutation.SetCategoryID(i)
	return puo
}

// SetNillableCategoryID sets the "category_id" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableCategoryID(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetCategoryID(*i)
	}
	return puo
}

// AddCategoryID adds i to the "category_id" field.
func (puo *ProductsUpdateOne) AddCategoryID(i int) *ProductsUpdateOne {
	puo.mutation.AddCategoryID(i)
	return puo
}

// ClearCategoryID clears the value of the "category_id" field.
func (puo *ProductsUpdateOne) ClearCategoryID() *ProductsUpdateOne {
	puo.mutation.ClearCategoryID()
	return puo
}

// SetBrandID sets the "brand_id" field.
func (puo *ProductsUpdateOne) SetBrandID(i int) *ProductsUpdateOne {
	puo.mutation.ResetBrandID()
	puo.mutation.SetBrandID(i)
	return puo
}

// SetNillableBrandID sets the "brand_id" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableBrandID(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetBrandID(*i)
	}
	return puo
}

// AddBrandID adds i to the "brand_id" field.
func (puo *ProductsUpdateOne) AddBrandID(i int) *ProductsUpdateOne {
	puo.mutation.AddBrandID(i)
	return puo
}

// ClearBrandID clears the value of the "brand_id" field.
func (puo *ProductsUpdateOne) ClearBrandID() *ProductsUpdateOne {
	puo.mutation.ClearBrandID()
	return puo
}

// SetVariantTypeID sets the "variant_type_id" field.
func (puo *ProductsUpdateOne) SetVariantTypeID(i int) *ProductsUpdateOne {
	puo.mutation.ResetVariantTypeID()
	puo.mutation.SetVariantTypeID(i)
	return puo
}

// SetNillableVariantTypeID sets the "variant_type_id" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableVariantTypeID(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetVariantTypeID(*i)
	}
	return puo
}

// AddVariantTypeID adds i to the "variant_type_id" field.
func (puo *ProductsUpdateOne) AddVariantTypeID(i int) *ProductsUpdateOne {
	puo.mutation.AddVariantTypeID(i)
	return puo
}

// ClearVariantTypeID clears the value of the "variant_type_id" field.
func (puo *ProductsUpdateOne) ClearVariantTypeID() *ProductsUpdateOne {
	puo.mutation.ClearVariantTypeID()
	return puo
}

// SetProductReferencesID sets the "product_references_id" field.
func (puo *ProductsUpdateOne) SetProductReferencesID(i int) *ProductsUpdateOne {
	puo.mutation.ResetProductReferencesID()
	puo.mutation.SetProductReferencesID(i)
	return puo
}

// SetNillableProductReferencesID sets the "product_references_id" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableProductReferencesID(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetProductReferencesID(*i)
	}
	return puo
}

// AddProductReferencesID adds i to the "product_references_id" field.
func (puo *ProductsUpdateOne) AddProductReferencesID(i int) *ProductsUpdateOne {
	puo.mutation.AddProductReferencesID(i)
	return puo
}

// ClearProductReferencesID clears the value of the "product_references_id" field.
func (puo *ProductsUpdateOne) ClearProductReferencesID() *ProductsUpdateOne {
	puo.mutation.ClearProductReferencesID()
	return puo
}

// SetImageID sets the "image_id" field.
func (puo *ProductsUpdateOne) SetImageID(i int) *ProductsUpdateOne {
	puo.mutation.ResetImageID()
	puo.mutation.SetImageID(i)
	return puo
}

// SetNillableImageID sets the "image_id" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableImageID(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetImageID(*i)
	}
	return puo
}

// AddImageID adds i to the "image_id" field.
func (puo *ProductsUpdateOne) AddImageID(i int) *ProductsUpdateOne {
	puo.mutation.AddImageID(i)
	return puo
}

// SetName sets the "name" field.
func (puo *ProductsUpdateOne) SetName(s string) *ProductsUpdateOne {
	puo.mutation.SetName(s)
	return puo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableName(s *string) *ProductsUpdateOne {
	if s != nil {
		puo.SetName(*s)
	}
	return puo
}

// SetStock sets the "stock" field.
func (puo *ProductsUpdateOne) SetStock(i int) *ProductsUpdateOne {
	puo.mutation.ResetStock()
	puo.mutation.SetStock(i)
	return puo
}

// SetNillableStock sets the "stock" field if the given value is not nil.
func (puo *ProductsUpdateOne) SetNillableStock(i *int) *ProductsUpdateOne {
	if i != nil {
		puo.SetStock(*i)
	}
	return puo
}

// AddStock adds i to the "stock" field.
func (puo *ProductsUpdateOne) AddStock(i int) *ProductsUpdateOne {
	puo.mutation.AddStock(i)
	return puo
}

// SetCategory sets the "category" edge to the Category entity.
func (puo *ProductsUpdateOne) SetCategory(c *Category) *ProductsUpdateOne {
	return puo.SetCategoryID(c.ID)
}

// SetBrand sets the "brand" edge to the Brand entity.
func (puo *ProductsUpdateOne) SetBrand(b *Brand) *ProductsUpdateOne {
	return puo.SetBrandID(b.ID)
}

// SetVariantType sets the "variant_type" edge to the VariantType entity.
func (puo *ProductsUpdateOne) SetVariantType(v *VariantType) *ProductsUpdateOne {
	return puo.SetVariantTypeID(v.ID)
}

// AddProductReferenceIDs adds the "product_references" edge to the ProductReferences entity by IDs.
func (puo *ProductsUpdateOne) AddProductReferenceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductReferenceIDs(ids...)
	return puo
}

// AddProductReferences adds the "product_references" edges to the ProductReferences entity.
func (puo *ProductsUpdateOne) AddProductReferences(p ...*ProductReferences) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductReferenceIDs(ids...)
}

// AddImageIDs adds the "images" edge to the Images entity by IDs.
func (puo *ProductsUpdateOne) AddImageIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddImageIDs(ids...)
	return puo
}

// AddImages adds the "images" edges to the Images entity.
func (puo *ProductsUpdateOne) AddImages(i ...*Images) *ProductsUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return puo.AddImageIDs(ids...)
}

// AddProductHasImageIDs adds the "product_has_image" edge to the ProductHasImage entity by IDs.
func (puo *ProductsUpdateOne) AddProductHasImageIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductHasImageIDs(ids...)
	return puo
}

// AddProductHasImage adds the "product_has_image" edges to the ProductHasImage entity.
func (puo *ProductsUpdateOne) AddProductHasImage(p ...*ProductHasImage) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductHasImageIDs(ids...)
}

// AddPromotionHasProductIDs adds the "promotion_has_product" edge to the PromotionHasProduct entity by IDs.
func (puo *ProductsUpdateOne) AddPromotionHasProductIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddPromotionHasProductIDs(ids...)
	return puo
}

// AddPromotionHasProduct adds the "promotion_has_product" edges to the PromotionHasProduct entity.
func (puo *ProductsUpdateOne) AddPromotionHasProduct(p ...*PromotionHasProduct) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddPromotionHasProductIDs(ids...)
}

// AddToolHasProductIDs adds the "tool_has_product" edge to the ToolHasProduct entity by IDs.
func (puo *ProductsUpdateOne) AddToolHasProductIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddToolHasProductIDs(ids...)
	return puo
}

// AddToolHasProduct adds the "tool_has_product" edges to the ToolHasProduct entity.
func (puo *ProductsUpdateOne) AddToolHasProduct(t ...*ToolHasProduct) *ProductsUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return puo.AddToolHasProductIDs(ids...)
}

// AddProductHasFeatureIDs adds the "product_has_feature" edge to the ProductHasFeature entity by IDs.
func (puo *ProductsUpdateOne) AddProductHasFeatureIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductHasFeatureIDs(ids...)
	return puo
}

// AddProductHasFeature adds the "product_has_feature" edges to the ProductHasFeature entity.
func (puo *ProductsUpdateOne) AddProductHasFeature(p ...*ProductHasFeature) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductHasFeatureIDs(ids...)
}

// AddProductHasInfoIDs adds the "product_has_info" edge to the ProductHasInfo entity by IDs.
func (puo *ProductsUpdateOne) AddProductHasInfoIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductHasInfoIDs(ids...)
	return puo
}

// AddProductHasInfo adds the "product_has_info" edges to the ProductHasInfo entity.
func (puo *ProductsUpdateOne) AddProductHasInfo(p ...*ProductHasInfo) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductHasInfoIDs(ids...)
}

// AddProductHasProductReferenceIDs adds the "product_has_product_reference" edge to the ProductHasProductReference entity by IDs.
func (puo *ProductsUpdateOne) AddProductHasProductReferenceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductHasProductReferenceIDs(ids...)
	return puo
}

// AddProductHasProductReference adds the "product_has_product_reference" edges to the ProductHasProductReference entity.
func (puo *ProductsUpdateOne) AddProductHasProductReference(p ...*ProductHasProductReference) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductHasProductReferenceIDs(ids...)
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrices entity by IDs.
func (puo *ProductsUpdateOne) AddProductPriceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.AddProductPriceIDs(ids...)
	return puo
}

// AddProductPrices adds the "product_prices" edges to the ProductPrices entity.
func (puo *ProductsUpdateOne) AddProductPrices(p ...*ProductPrices) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.AddProductPriceIDs(ids...)
}

// Mutation returns the ProductsMutation object of the builder.
func (puo *ProductsUpdateOne) Mutation() *ProductsMutation {
	return puo.mutation
}

// ClearCategory clears the "category" edge to the Category entity.
func (puo *ProductsUpdateOne) ClearCategory() *ProductsUpdateOne {
	puo.mutation.ClearCategory()
	return puo
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (puo *ProductsUpdateOne) ClearBrand() *ProductsUpdateOne {
	puo.mutation.ClearBrand()
	return puo
}

// ClearVariantType clears the "variant_type" edge to the VariantType entity.
func (puo *ProductsUpdateOne) ClearVariantType() *ProductsUpdateOne {
	puo.mutation.ClearVariantType()
	return puo
}

// ClearProductReferences clears all "product_references" edges to the ProductReferences entity.
func (puo *ProductsUpdateOne) ClearProductReferences() *ProductsUpdateOne {
	puo.mutation.ClearProductReferences()
	return puo
}

// RemoveProductReferenceIDs removes the "product_references" edge to ProductReferences entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductReferenceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductReferenceIDs(ids...)
	return puo
}

// RemoveProductReferences removes "product_references" edges to ProductReferences entities.
func (puo *ProductsUpdateOne) RemoveProductReferences(p ...*ProductReferences) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductReferenceIDs(ids...)
}

// ClearImages clears all "images" edges to the Images entity.
func (puo *ProductsUpdateOne) ClearImages() *ProductsUpdateOne {
	puo.mutation.ClearImages()
	return puo
}

// RemoveImageIDs removes the "images" edge to Images entities by IDs.
func (puo *ProductsUpdateOne) RemoveImageIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveImageIDs(ids...)
	return puo
}

// RemoveImages removes "images" edges to Images entities.
func (puo *ProductsUpdateOne) RemoveImages(i ...*Images) *ProductsUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return puo.RemoveImageIDs(ids...)
}

// ClearProductHasImage clears all "product_has_image" edges to the ProductHasImage entity.
func (puo *ProductsUpdateOne) ClearProductHasImage() *ProductsUpdateOne {
	puo.mutation.ClearProductHasImage()
	return puo
}

// RemoveProductHasImageIDs removes the "product_has_image" edge to ProductHasImage entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductHasImageIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductHasImageIDs(ids...)
	return puo
}

// RemoveProductHasImage removes "product_has_image" edges to ProductHasImage entities.
func (puo *ProductsUpdateOne) RemoveProductHasImage(p ...*ProductHasImage) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductHasImageIDs(ids...)
}

// ClearPromotionHasProduct clears all "promotion_has_product" edges to the PromotionHasProduct entity.
func (puo *ProductsUpdateOne) ClearPromotionHasProduct() *ProductsUpdateOne {
	puo.mutation.ClearPromotionHasProduct()
	return puo
}

// RemovePromotionHasProductIDs removes the "promotion_has_product" edge to PromotionHasProduct entities by IDs.
func (puo *ProductsUpdateOne) RemovePromotionHasProductIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemovePromotionHasProductIDs(ids...)
	return puo
}

// RemovePromotionHasProduct removes "promotion_has_product" edges to PromotionHasProduct entities.
func (puo *ProductsUpdateOne) RemovePromotionHasProduct(p ...*PromotionHasProduct) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemovePromotionHasProductIDs(ids...)
}

// ClearToolHasProduct clears all "tool_has_product" edges to the ToolHasProduct entity.
func (puo *ProductsUpdateOne) ClearToolHasProduct() *ProductsUpdateOne {
	puo.mutation.ClearToolHasProduct()
	return puo
}

// RemoveToolHasProductIDs removes the "tool_has_product" edge to ToolHasProduct entities by IDs.
func (puo *ProductsUpdateOne) RemoveToolHasProductIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveToolHasProductIDs(ids...)
	return puo
}

// RemoveToolHasProduct removes "tool_has_product" edges to ToolHasProduct entities.
func (puo *ProductsUpdateOne) RemoveToolHasProduct(t ...*ToolHasProduct) *ProductsUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return puo.RemoveToolHasProductIDs(ids...)
}

// ClearProductHasFeature clears all "product_has_feature" edges to the ProductHasFeature entity.
func (puo *ProductsUpdateOne) ClearProductHasFeature() *ProductsUpdateOne {
	puo.mutation.ClearProductHasFeature()
	return puo
}

// RemoveProductHasFeatureIDs removes the "product_has_feature" edge to ProductHasFeature entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductHasFeatureIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductHasFeatureIDs(ids...)
	return puo
}

// RemoveProductHasFeature removes "product_has_feature" edges to ProductHasFeature entities.
func (puo *ProductsUpdateOne) RemoveProductHasFeature(p ...*ProductHasFeature) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductHasFeatureIDs(ids...)
}

// ClearProductHasInfo clears all "product_has_info" edges to the ProductHasInfo entity.
func (puo *ProductsUpdateOne) ClearProductHasInfo() *ProductsUpdateOne {
	puo.mutation.ClearProductHasInfo()
	return puo
}

// RemoveProductHasInfoIDs removes the "product_has_info" edge to ProductHasInfo entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductHasInfoIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductHasInfoIDs(ids...)
	return puo
}

// RemoveProductHasInfo removes "product_has_info" edges to ProductHasInfo entities.
func (puo *ProductsUpdateOne) RemoveProductHasInfo(p ...*ProductHasInfo) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductHasInfoIDs(ids...)
}

// ClearProductHasProductReference clears all "product_has_product_reference" edges to the ProductHasProductReference entity.
func (puo *ProductsUpdateOne) ClearProductHasProductReference() *ProductsUpdateOne {
	puo.mutation.ClearProductHasProductReference()
	return puo
}

// RemoveProductHasProductReferenceIDs removes the "product_has_product_reference" edge to ProductHasProductReference entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductHasProductReferenceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductHasProductReferenceIDs(ids...)
	return puo
}

// RemoveProductHasProductReference removes "product_has_product_reference" edges to ProductHasProductReference entities.
func (puo *ProductsUpdateOne) RemoveProductHasProductReference(p ...*ProductHasProductReference) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductHasProductReferenceIDs(ids...)
}

// ClearProductPrices clears all "product_prices" edges to the ProductPrices entity.
func (puo *ProductsUpdateOne) ClearProductPrices() *ProductsUpdateOne {
	puo.mutation.ClearProductPrices()
	return puo
}

// RemoveProductPriceIDs removes the "product_prices" edge to ProductPrices entities by IDs.
func (puo *ProductsUpdateOne) RemoveProductPriceIDs(ids ...int) *ProductsUpdateOne {
	puo.mutation.RemoveProductPriceIDs(ids...)
	return puo
}

// RemoveProductPrices removes "product_prices" edges to ProductPrices entities.
func (puo *ProductsUpdateOne) RemoveProductPrices(p ...*ProductPrices) *ProductsUpdateOne {
	ids := make([]int, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return puo.RemoveProductPriceIDs(ids...)
}

// Where appends a list predicates to the ProductsUpdate builder.
func (puo *ProductsUpdateOne) Where(ps ...predicate.Products) *ProductsUpdateOne {
	puo.mutation.Where(ps...)
	return puo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (puo *ProductsUpdateOne) Select(field string, fields ...string) *ProductsUpdateOne {
	puo.fields = append([]string{field}, fields...)
	return puo
}

// Save executes the query and returns the updated Products entity.
func (puo *ProductsUpdateOne) Save(ctx context.Context) (*Products, error) {
	puo.defaults()
	return withHooks(ctx, puo.sqlSave, puo.mutation, puo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (puo *ProductsUpdateOne) SaveX(ctx context.Context) *Products {
	node, err := puo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (puo *ProductsUpdateOne) Exec(ctx context.Context) error {
	_, err := puo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (puo *ProductsUpdateOne) ExecX(ctx context.Context) {
	if err := puo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (puo *ProductsUpdateOne) defaults() {
	if _, ok := puo.mutation.UpdatedAt(); !ok {
		v := products.UpdateDefaultUpdatedAt()
		puo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (puo *ProductsUpdateOne) check() error {
	if v, ok := puo.mutation.UpdatedBy(); ok {
		if err := products.UpdatedByValidator(v); err != nil {
			return &ValidationError{Name: "updated_by", err: fmt.Errorf(`ent: validator failed for field "Products.updated_by": %w`, err)}
		}
	}
	return nil
}

func (puo *ProductsUpdateOne) sqlSave(ctx context.Context) (_node *Products, err error) {
	if err := puo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(products.Table, products.Columns, sqlgraph.NewFieldSpec(products.FieldID, field.TypeInt))
	id, ok := puo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Products.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := puo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, products.FieldID)
		for _, f := range fields {
			if !products.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != products.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := puo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := puo.mutation.UpdatedAt(); ok {
		_spec.SetField(products.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := puo.mutation.DeletedAt(); ok {
		_spec.SetField(products.FieldDeletedAt, field.TypeTime, value)
	}
	if puo.mutation.DeletedAtCleared() {
		_spec.ClearField(products.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := puo.mutation.UpdatedBy(); ok {
		_spec.SetField(products.FieldUpdatedBy, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedUpdatedBy(); ok {
		_spec.AddField(products.FieldUpdatedBy, field.TypeInt, value)
	}
	if value, ok := puo.mutation.DeletedBy(); ok {
		_spec.SetField(products.FieldDeletedBy, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedDeletedBy(); ok {
		_spec.AddField(products.FieldDeletedBy, field.TypeInt, value)
	}
	if puo.mutation.DeletedByCleared() {
		_spec.ClearField(products.FieldDeletedBy, field.TypeInt)
	}
	if value, ok := puo.mutation.CategoryID(); ok {
		_spec.SetField(products.FieldCategoryID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedCategoryID(); ok {
		_spec.AddField(products.FieldCategoryID, field.TypeInt, value)
	}
	if puo.mutation.CategoryIDCleared() {
		_spec.ClearField(products.FieldCategoryID, field.TypeInt)
	}
	if value, ok := puo.mutation.BrandID(); ok {
		_spec.SetField(products.FieldBrandID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedBrandID(); ok {
		_spec.AddField(products.FieldBrandID, field.TypeInt, value)
	}
	if puo.mutation.BrandIDCleared() {
		_spec.ClearField(products.FieldBrandID, field.TypeInt)
	}
	if value, ok := puo.mutation.VariantTypeID(); ok {
		_spec.SetField(products.FieldVariantTypeID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedVariantTypeID(); ok {
		_spec.AddField(products.FieldVariantTypeID, field.TypeInt, value)
	}
	if puo.mutation.VariantTypeIDCleared() {
		_spec.ClearField(products.FieldVariantTypeID, field.TypeInt)
	}
	if value, ok := puo.mutation.ProductReferencesID(); ok {
		_spec.SetField(products.FieldProductReferencesID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedProductReferencesID(); ok {
		_spec.AddField(products.FieldProductReferencesID, field.TypeInt, value)
	}
	if puo.mutation.ProductReferencesIDCleared() {
		_spec.ClearField(products.FieldProductReferencesID, field.TypeInt)
	}
	if value, ok := puo.mutation.ImageID(); ok {
		_spec.SetField(products.FieldImageID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedImageID(); ok {
		_spec.AddField(products.FieldImageID, field.TypeInt, value)
	}
	if value, ok := puo.mutation.Name(); ok {
		_spec.SetField(products.FieldName, field.TypeString, value)
	}
	if value, ok := puo.mutation.Stock(); ok {
		_spec.SetField(products.FieldStock, field.TypeInt, value)
	}
	if value, ok := puo.mutation.AddedStock(); ok {
		_spec.AddField(products.FieldStock, field.TypeInt, value)
	}
	if puo.mutation.CategoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.CategoryTable,
			Columns: []string{products.CategoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(category.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.CategoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.CategoryTable,
			Columns: []string{products.CategoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(category.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.BrandCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.BrandTable,
			Columns: []string{products.BrandColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(brand.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.BrandIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.BrandTable,
			Columns: []string{products.BrandColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(brand.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.VariantTypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.VariantTypeTable,
			Columns: []string{products.VariantTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(varianttype.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.VariantTypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   products.VariantTypeTable,
			Columns: []string{products.VariantTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(varianttype.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductReferencesIDs(); len(nodes) > 0 && !puo.mutation.ProductReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductReferencesTable,
			Columns: []string{products.ProductReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productreferences.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedImagesIDs(); len(nodes) > 0 && !puo.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ImagesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ImagesTable,
			Columns: []string{products.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(images.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductHasImageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductHasImageIDs(); len(nodes) > 0 && !puo.mutation.ProductHasImageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductHasImageIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasImageTable,
			Columns: []string{products.ProductHasImageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasimage.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.PromotionHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedPromotionHasProductIDs(); len(nodes) > 0 && !puo.mutation.PromotionHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.PromotionHasProductIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.PromotionHasProductTable,
			Columns: []string{products.PromotionHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(promotionhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ToolHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedToolHasProductIDs(); len(nodes) > 0 && !puo.mutation.ToolHasProductCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ToolHasProductIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ToolHasProductTable,
			Columns: []string{products.ToolHasProductColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(toolhasproduct.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductHasFeatureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductHasFeatureIDs(); len(nodes) > 0 && !puo.mutation.ProductHasFeatureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductHasFeatureIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasFeatureTable,
			Columns: []string{products.ProductHasFeatureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasfeature.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductHasInfoCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductHasInfoIDs(); len(nodes) > 0 && !puo.mutation.ProductHasInfoCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductHasInfoIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasInfoTable,
			Columns: []string{products.ProductHasInfoColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasinfo.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductHasProductReferenceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductHasProductReferenceIDs(); len(nodes) > 0 && !puo.mutation.ProductHasProductReferenceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductHasProductReferenceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductHasProductReferenceTable,
			Columns: []string{products.ProductHasProductReferenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(producthasproductreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if puo.mutation.ProductPricesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.RemovedProductPricesIDs(); len(nodes) > 0 && !puo.mutation.ProductPricesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := puo.mutation.ProductPricesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   products.ProductPricesTable,
			Columns: []string{products.ProductPricesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productprices.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Products{config: puo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, puo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{products.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	puo.mutation.done = true
	return _node, nil
}
