// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"products-service/internal/app/ent/brand"
	"products-service/internal/app/ent/category"
	"products-service/internal/app/ent/features"
	"products-service/internal/app/ent/featuresunitvalues"
	"products-service/internal/app/ent/featuresvalues"
	"products-service/internal/app/ent/featuresvaluestypes"
	"products-service/internal/app/ent/imagefolderpath"
	"products-service/internal/app/ent/imagefoldersource"
	"products-service/internal/app/ent/images"
	"products-service/internal/app/ent/infotypes"
	"products-service/internal/app/ent/predicate"
	"products-service/internal/app/ent/pricetype"
	"products-service/internal/app/ent/producthasfeature"
	"products-service/internal/app/ent/producthasimage"
	"products-service/internal/app/ent/producthasinfo"
	"products-service/internal/app/ent/producthasproductreference"
	"products-service/internal/app/ent/productinfo"
	"products-service/internal/app/ent/productprices"
	"products-service/internal/app/ent/productreferences"
	"products-service/internal/app/ent/products"
	"products-service/internal/app/ent/promotionhasproduct"
	"products-service/internal/app/ent/promotions"
	"products-service/internal/app/ent/referencesources"
	"products-service/internal/app/ent/toolhasproduct"
	"products-service/internal/app/ent/tools"
	"products-service/internal/app/ent/user"
	"products-service/internal/app/ent/varianttype"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBrand                      = "Brand"
	TypeCategory                   = "Category"
	TypeFeatures                   = "Features"
	TypeFeaturesUnitValues         = "FeaturesUnitValues"
	TypeFeaturesValues             = "FeaturesValues"
	TypeFeaturesValuesTypes        = "FeaturesValuesTypes"
	TypeImageFolderPath            = "ImageFolderPath"
	TypeImageFolderSource          = "ImageFolderSource"
	TypeImages                     = "Images"
	TypeInfoTypes                  = "InfoTypes"
	TypePriceType                  = "PriceType"
	TypeProductHasFeature          = "ProductHasFeature"
	TypeProductHasImage            = "ProductHasImage"
	TypeProductHasInfo             = "ProductHasInfo"
	TypeProductHasProductReference = "ProductHasProductReference"
	TypeProductInfo                = "ProductInfo"
	TypeProductPrices              = "ProductPrices"
	TypeProductReferences          = "ProductReferences"
	TypeProducts                   = "Products"
	TypePromotionHasProduct        = "PromotionHasProduct"
	TypePromotions                 = "Promotions"
	TypeReferenceSources           = "ReferenceSources"
	TypeToolHasProduct             = "ToolHasProduct"
	TypeTools                      = "Tools"
	TypeUser                       = "User"
	TypeVariantType                = "VariantType"
)

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	deleted_at      *time.Time
	name            *string
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Brand, error)
	predicates      []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Brand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BrandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BrandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BrandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BrandMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BrandMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BrandMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[brand.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BrandMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[brand.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, brand.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// AddProductIDs adds the "products" edge to the Products entity by ids.
func (m *BrandMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *BrandMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *BrandMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Products entity by IDs.
func (m *BrandMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Products entity.
func (m *BrandMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *BrandMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *BrandMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Brand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, brand.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, brand.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCreatedAt:
		return m.CreatedAt()
	case brand.FieldDeletedAt:
		return m.DeletedAt()
	case brand.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case brand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case brand.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brand.FieldDeletedAt) {
		fields = append(fields, brand.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	switch name {
	case brand.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case brand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	deleted_at      *time.Time
	category_id     *int
	addcategory_id  *int
	name            *string
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetCategoryID sets the "category_id" field.
func (m *CategoryMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CategoryMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCategoryID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *CategoryMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *CategoryMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *CategoryMutation) ClearCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	m.clearedFields[category.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *CategoryMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[category.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CategoryMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	delete(m.clearedFields, category.FieldCategoryID)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// AddProductIDs adds the "products" edge to the Products entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Products entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Products entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// SetParentID sets the "parent" edge to the Category entity by id.
func (m *CategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.category_id != nil {
		fields = append(fields, category.FieldCategoryID)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldCategoryID:
		return m.CategoryID()
	case category.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, category.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.FieldCleared(category.FieldCategoryID) {
		fields = append(fields, category.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case category.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeProducts:
		return m.clearedproducts
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// FeaturesMutation represents an operation that mutates the Features nodes in the graph.
type FeaturesMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	deleted_at                 *time.Time
	feature_value_id           *int
	addfeature_value_id        *int
	name                       *string
	clearedFields              map[string]struct{}
	feature_values             map[int]struct{}
	removedfeature_values      map[int]struct{}
	clearedfeature_values      bool
	product_has_feature        map[int]struct{}
	removedproduct_has_feature map[int]struct{}
	clearedproduct_has_feature bool
	done                       bool
	oldValue                   func(context.Context) (*Features, error)
	predicates                 []predicate.Features
}

var _ ent.Mutation = (*FeaturesMutation)(nil)

// featuresOption allows management of the mutation configuration using functional options.
type featuresOption func(*FeaturesMutation)

// newFeaturesMutation creates new mutation for the Features entity.
func newFeaturesMutation(c config, op Op, opts ...featuresOption) *FeaturesMutation {
	m := &FeaturesMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatures,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeaturesID sets the ID field of the mutation.
func withFeaturesID(id int) featuresOption {
	return func(m *FeaturesMutation) {
		var (
			err   error
			once  sync.Once
			value *Features
		)
		m.oldValue = func(ctx context.Context) (*Features, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Features.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatures sets the old Features of the mutation.
func withFeatures(node *Features) featuresOption {
	return func(m *FeaturesMutation) {
		m.oldValue = func(context.Context) (*Features, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeaturesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeaturesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeaturesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeaturesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Features.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeaturesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeaturesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Features entity.
// If the Features object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeaturesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeaturesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeaturesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Features entity.
// If the Features object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeaturesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[features.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeaturesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[features.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeaturesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, features.FieldDeletedAt)
}

// SetFeatureValueID sets the "feature_value_id" field.
func (m *FeaturesMutation) SetFeatureValueID(i int) {
	m.feature_value_id = &i
	m.addfeature_value_id = nil
}

// FeatureValueID returns the value of the "feature_value_id" field in the mutation.
func (m *FeaturesMutation) FeatureValueID() (r int, exists bool) {
	v := m.feature_value_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureValueID returns the old "feature_value_id" field's value of the Features entity.
// If the Features object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesMutation) OldFeatureValueID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureValueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureValueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureValueID: %w", err)
	}
	return oldValue.FeatureValueID, nil
}

// AddFeatureValueID adds i to the "feature_value_id" field.
func (m *FeaturesMutation) AddFeatureValueID(i int) {
	if m.addfeature_value_id != nil {
		*m.addfeature_value_id += i
	} else {
		m.addfeature_value_id = &i
	}
}

// AddedFeatureValueID returns the value that was added to the "feature_value_id" field in this mutation.
func (m *FeaturesMutation) AddedFeatureValueID() (r int, exists bool) {
	v := m.addfeature_value_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeatureValueID resets all changes to the "feature_value_id" field.
func (m *FeaturesMutation) ResetFeatureValueID() {
	m.feature_value_id = nil
	m.addfeature_value_id = nil
}

// SetName sets the "name" field.
func (m *FeaturesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeaturesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Features entity.
// If the Features object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeaturesMutation) ResetName() {
	m.name = nil
}

// AddFeatureValueIDs adds the "feature_values" edge to the FeaturesValues entity by ids.
func (m *FeaturesMutation) AddFeatureValueIDs(ids ...int) {
	if m.feature_values == nil {
		m.feature_values = make(map[int]struct{})
	}
	for i := range ids {
		m.feature_values[ids[i]] = struct{}{}
	}
}

// ClearFeatureValues clears the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesMutation) ClearFeatureValues() {
	m.clearedfeature_values = true
}

// FeatureValuesCleared reports if the "feature_values" edge to the FeaturesValues entity was cleared.
func (m *FeaturesMutation) FeatureValuesCleared() bool {
	return m.clearedfeature_values
}

// RemoveFeatureValueIDs removes the "feature_values" edge to the FeaturesValues entity by IDs.
func (m *FeaturesMutation) RemoveFeatureValueIDs(ids ...int) {
	if m.removedfeature_values == nil {
		m.removedfeature_values = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feature_values, ids[i])
		m.removedfeature_values[ids[i]] = struct{}{}
	}
}

// RemovedFeatureValues returns the removed IDs of the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesMutation) RemovedFeatureValuesIDs() (ids []int) {
	for id := range m.removedfeature_values {
		ids = append(ids, id)
	}
	return
}

// FeatureValuesIDs returns the "feature_values" edge IDs in the mutation.
func (m *FeaturesMutation) FeatureValuesIDs() (ids []int) {
	for id := range m.feature_values {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureValues resets all changes to the "feature_values" edge.
func (m *FeaturesMutation) ResetFeatureValues() {
	m.feature_values = nil
	m.clearedfeature_values = false
	m.removedfeature_values = nil
}

// AddProductHasFeatureIDs adds the "product_has_feature" edge to the ProductHasFeature entity by ids.
func (m *FeaturesMutation) AddProductHasFeatureIDs(ids ...int) {
	if m.product_has_feature == nil {
		m.product_has_feature = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_feature[ids[i]] = struct{}{}
	}
}

// ClearProductHasFeature clears the "product_has_feature" edge to the ProductHasFeature entity.
func (m *FeaturesMutation) ClearProductHasFeature() {
	m.clearedproduct_has_feature = true
}

// ProductHasFeatureCleared reports if the "product_has_feature" edge to the ProductHasFeature entity was cleared.
func (m *FeaturesMutation) ProductHasFeatureCleared() bool {
	return m.clearedproduct_has_feature
}

// RemoveProductHasFeatureIDs removes the "product_has_feature" edge to the ProductHasFeature entity by IDs.
func (m *FeaturesMutation) RemoveProductHasFeatureIDs(ids ...int) {
	if m.removedproduct_has_feature == nil {
		m.removedproduct_has_feature = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_feature, ids[i])
		m.removedproduct_has_feature[ids[i]] = struct{}{}
	}
}

// RemovedProductHasFeature returns the removed IDs of the "product_has_feature" edge to the ProductHasFeature entity.
func (m *FeaturesMutation) RemovedProductHasFeatureIDs() (ids []int) {
	for id := range m.removedproduct_has_feature {
		ids = append(ids, id)
	}
	return
}

// ProductHasFeatureIDs returns the "product_has_feature" edge IDs in the mutation.
func (m *FeaturesMutation) ProductHasFeatureIDs() (ids []int) {
	for id := range m.product_has_feature {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasFeature resets all changes to the "product_has_feature" edge.
func (m *FeaturesMutation) ResetProductHasFeature() {
	m.product_has_feature = nil
	m.clearedproduct_has_feature = false
	m.removedproduct_has_feature = nil
}

// Where appends a list predicates to the FeaturesMutation builder.
func (m *FeaturesMutation) Where(ps ...predicate.Features) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeaturesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeaturesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Features, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeaturesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeaturesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Features).
func (m *FeaturesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeaturesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, features.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, features.FieldDeletedAt)
	}
	if m.feature_value_id != nil {
		fields = append(fields, features.FieldFeatureValueID)
	}
	if m.name != nil {
		fields = append(fields, features.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeaturesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case features.FieldCreatedAt:
		return m.CreatedAt()
	case features.FieldDeletedAt:
		return m.DeletedAt()
	case features.FieldFeatureValueID:
		return m.FeatureValueID()
	case features.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeaturesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case features.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case features.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case features.FieldFeatureValueID:
		return m.OldFeatureValueID(ctx)
	case features.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Features field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case features.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case features.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case features.FieldFeatureValueID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureValueID(v)
		return nil
	case features.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Features field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeaturesMutation) AddedFields() []string {
	var fields []string
	if m.addfeature_value_id != nil {
		fields = append(fields, features.FieldFeatureValueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeaturesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case features.FieldFeatureValueID:
		return m.AddedFeatureValueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case features.FieldFeatureValueID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeatureValueID(v)
		return nil
	}
	return fmt.Errorf("unknown Features numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeaturesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(features.FieldDeletedAt) {
		fields = append(fields, features.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeaturesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeaturesMutation) ClearField(name string) error {
	switch name {
	case features.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Features nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeaturesMutation) ResetField(name string) error {
	switch name {
	case features.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case features.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case features.FieldFeatureValueID:
		m.ResetFeatureValueID()
		return nil
	case features.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Features field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeaturesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feature_values != nil {
		edges = append(edges, features.EdgeFeatureValues)
	}
	if m.product_has_feature != nil {
		edges = append(edges, features.EdgeProductHasFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeaturesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case features.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.feature_values))
		for id := range m.feature_values {
			ids = append(ids, id)
		}
		return ids
	case features.EdgeProductHasFeature:
		ids := make([]ent.Value, 0, len(m.product_has_feature))
		for id := range m.product_has_feature {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeaturesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfeature_values != nil {
		edges = append(edges, features.EdgeFeatureValues)
	}
	if m.removedproduct_has_feature != nil {
		edges = append(edges, features.EdgeProductHasFeature)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeaturesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case features.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.removedfeature_values))
		for id := range m.removedfeature_values {
			ids = append(ids, id)
		}
		return ids
	case features.EdgeProductHasFeature:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_feature))
		for id := range m.removedproduct_has_feature {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeaturesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeature_values {
		edges = append(edges, features.EdgeFeatureValues)
	}
	if m.clearedproduct_has_feature {
		edges = append(edges, features.EdgeProductHasFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeaturesMutation) EdgeCleared(name string) bool {
	switch name {
	case features.EdgeFeatureValues:
		return m.clearedfeature_values
	case features.EdgeProductHasFeature:
		return m.clearedproduct_has_feature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeaturesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Features unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeaturesMutation) ResetEdge(name string) error {
	switch name {
	case features.EdgeFeatureValues:
		m.ResetFeatureValues()
		return nil
	case features.EdgeProductHasFeature:
		m.ResetProductHasFeature()
		return nil
	}
	return fmt.Errorf("unknown Features edge %s", name)
}

// FeaturesUnitValuesMutation represents an operation that mutates the FeaturesUnitValues nodes in the graph.
type FeaturesUnitValuesMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	decimals              *int
	adddecimals           *int
	clearedFields         map[string]struct{}
	feature_values        map[int]struct{}
	removedfeature_values map[int]struct{}
	clearedfeature_values bool
	done                  bool
	oldValue              func(context.Context) (*FeaturesUnitValues, error)
	predicates            []predicate.FeaturesUnitValues
}

var _ ent.Mutation = (*FeaturesUnitValuesMutation)(nil)

// featuresunitvaluesOption allows management of the mutation configuration using functional options.
type featuresunitvaluesOption func(*FeaturesUnitValuesMutation)

// newFeaturesUnitValuesMutation creates new mutation for the FeaturesUnitValues entity.
func newFeaturesUnitValuesMutation(c config, op Op, opts ...featuresunitvaluesOption) *FeaturesUnitValuesMutation {
	m := &FeaturesUnitValuesMutation{
		config:        c,
		op:            op,
		typ:           TypeFeaturesUnitValues,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeaturesUnitValuesID sets the ID field of the mutation.
func withFeaturesUnitValuesID(id int) featuresunitvaluesOption {
	return func(m *FeaturesUnitValuesMutation) {
		var (
			err   error
			once  sync.Once
			value *FeaturesUnitValues
		)
		m.oldValue = func(ctx context.Context) (*FeaturesUnitValues, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeaturesUnitValues.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeaturesUnitValues sets the old FeaturesUnitValues of the mutation.
func withFeaturesUnitValues(node *FeaturesUnitValues) featuresunitvaluesOption {
	return func(m *FeaturesUnitValuesMutation) {
		m.oldValue = func(context.Context) (*FeaturesUnitValues, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeaturesUnitValuesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeaturesUnitValuesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeaturesUnitValuesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeaturesUnitValuesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeaturesUnitValues.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeaturesUnitValuesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeaturesUnitValuesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeaturesUnitValues entity.
// If the FeaturesUnitValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesUnitValuesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeaturesUnitValuesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeaturesUnitValuesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeaturesUnitValuesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeaturesUnitValues entity.
// If the FeaturesUnitValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesUnitValuesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeaturesUnitValuesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featuresunitvalues.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeaturesUnitValuesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featuresunitvalues.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeaturesUnitValuesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featuresunitvalues.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *FeaturesUnitValuesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeaturesUnitValuesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeaturesUnitValues entity.
// If the FeaturesUnitValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesUnitValuesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeaturesUnitValuesMutation) ResetName() {
	m.name = nil
}

// SetDecimals sets the "decimals" field.
func (m *FeaturesUnitValuesMutation) SetDecimals(i int) {
	m.decimals = &i
	m.adddecimals = nil
}

// Decimals returns the value of the "decimals" field in the mutation.
func (m *FeaturesUnitValuesMutation) Decimals() (r int, exists bool) {
	v := m.decimals
	if v == nil {
		return
	}
	return *v, true
}

// OldDecimals returns the old "decimals" field's value of the FeaturesUnitValues entity.
// If the FeaturesUnitValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesUnitValuesMutation) OldDecimals(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecimals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecimals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecimals: %w", err)
	}
	return oldValue.Decimals, nil
}

// AddDecimals adds i to the "decimals" field.
func (m *FeaturesUnitValuesMutation) AddDecimals(i int) {
	if m.adddecimals != nil {
		*m.adddecimals += i
	} else {
		m.adddecimals = &i
	}
}

// AddedDecimals returns the value that was added to the "decimals" field in this mutation.
func (m *FeaturesUnitValuesMutation) AddedDecimals() (r int, exists bool) {
	v := m.adddecimals
	if v == nil {
		return
	}
	return *v, true
}

// ClearDecimals clears the value of the "decimals" field.
func (m *FeaturesUnitValuesMutation) ClearDecimals() {
	m.decimals = nil
	m.adddecimals = nil
	m.clearedFields[featuresunitvalues.FieldDecimals] = struct{}{}
}

// DecimalsCleared returns if the "decimals" field was cleared in this mutation.
func (m *FeaturesUnitValuesMutation) DecimalsCleared() bool {
	_, ok := m.clearedFields[featuresunitvalues.FieldDecimals]
	return ok
}

// ResetDecimals resets all changes to the "decimals" field.
func (m *FeaturesUnitValuesMutation) ResetDecimals() {
	m.decimals = nil
	m.adddecimals = nil
	delete(m.clearedFields, featuresunitvalues.FieldDecimals)
}

// AddFeatureValueIDs adds the "feature_values" edge to the FeaturesValues entity by ids.
func (m *FeaturesUnitValuesMutation) AddFeatureValueIDs(ids ...int) {
	if m.feature_values == nil {
		m.feature_values = make(map[int]struct{})
	}
	for i := range ids {
		m.feature_values[ids[i]] = struct{}{}
	}
}

// ClearFeatureValues clears the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesUnitValuesMutation) ClearFeatureValues() {
	m.clearedfeature_values = true
}

// FeatureValuesCleared reports if the "feature_values" edge to the FeaturesValues entity was cleared.
func (m *FeaturesUnitValuesMutation) FeatureValuesCleared() bool {
	return m.clearedfeature_values
}

// RemoveFeatureValueIDs removes the "feature_values" edge to the FeaturesValues entity by IDs.
func (m *FeaturesUnitValuesMutation) RemoveFeatureValueIDs(ids ...int) {
	if m.removedfeature_values == nil {
		m.removedfeature_values = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feature_values, ids[i])
		m.removedfeature_values[ids[i]] = struct{}{}
	}
}

// RemovedFeatureValues returns the removed IDs of the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesUnitValuesMutation) RemovedFeatureValuesIDs() (ids []int) {
	for id := range m.removedfeature_values {
		ids = append(ids, id)
	}
	return
}

// FeatureValuesIDs returns the "feature_values" edge IDs in the mutation.
func (m *FeaturesUnitValuesMutation) FeatureValuesIDs() (ids []int) {
	for id := range m.feature_values {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureValues resets all changes to the "feature_values" edge.
func (m *FeaturesUnitValuesMutation) ResetFeatureValues() {
	m.feature_values = nil
	m.clearedfeature_values = false
	m.removedfeature_values = nil
}

// Where appends a list predicates to the FeaturesUnitValuesMutation builder.
func (m *FeaturesUnitValuesMutation) Where(ps ...predicate.FeaturesUnitValues) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeaturesUnitValuesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeaturesUnitValuesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeaturesUnitValues, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeaturesUnitValuesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeaturesUnitValuesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeaturesUnitValues).
func (m *FeaturesUnitValuesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeaturesUnitValuesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, featuresunitvalues.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featuresunitvalues.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, featuresunitvalues.FieldName)
	}
	if m.decimals != nil {
		fields = append(fields, featuresunitvalues.FieldDecimals)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeaturesUnitValuesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuresunitvalues.FieldCreatedAt:
		return m.CreatedAt()
	case featuresunitvalues.FieldDeletedAt:
		return m.DeletedAt()
	case featuresunitvalues.FieldName:
		return m.Name()
	case featuresunitvalues.FieldDecimals:
		return m.Decimals()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeaturesUnitValuesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuresunitvalues.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featuresunitvalues.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case featuresunitvalues.FieldName:
		return m.OldName(ctx)
	case featuresunitvalues.FieldDecimals:
		return m.OldDecimals(ctx)
	}
	return nil, fmt.Errorf("unknown FeaturesUnitValues field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesUnitValuesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuresunitvalues.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featuresunitvalues.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case featuresunitvalues.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case featuresunitvalues.FieldDecimals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecimals(v)
		return nil
	}
	return fmt.Errorf("unknown FeaturesUnitValues field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeaturesUnitValuesMutation) AddedFields() []string {
	var fields []string
	if m.adddecimals != nil {
		fields = append(fields, featuresunitvalues.FieldDecimals)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeaturesUnitValuesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case featuresunitvalues.FieldDecimals:
		return m.AddedDecimals()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesUnitValuesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case featuresunitvalues.FieldDecimals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDecimals(v)
		return nil
	}
	return fmt.Errorf("unknown FeaturesUnitValues numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeaturesUnitValuesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuresunitvalues.FieldDeletedAt) {
		fields = append(fields, featuresunitvalues.FieldDeletedAt)
	}
	if m.FieldCleared(featuresunitvalues.FieldDecimals) {
		fields = append(fields, featuresunitvalues.FieldDecimals)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeaturesUnitValuesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeaturesUnitValuesMutation) ClearField(name string) error {
	switch name {
	case featuresunitvalues.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case featuresunitvalues.FieldDecimals:
		m.ClearDecimals()
		return nil
	}
	return fmt.Errorf("unknown FeaturesUnitValues nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeaturesUnitValuesMutation) ResetField(name string) error {
	switch name {
	case featuresunitvalues.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featuresunitvalues.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case featuresunitvalues.FieldName:
		m.ResetName()
		return nil
	case featuresunitvalues.FieldDecimals:
		m.ResetDecimals()
		return nil
	}
	return fmt.Errorf("unknown FeaturesUnitValues field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeaturesUnitValuesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.feature_values != nil {
		edges = append(edges, featuresunitvalues.EdgeFeatureValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeaturesUnitValuesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuresunitvalues.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.feature_values))
		for id := range m.feature_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeaturesUnitValuesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfeature_values != nil {
		edges = append(edges, featuresunitvalues.EdgeFeatureValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeaturesUnitValuesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featuresunitvalues.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.removedfeature_values))
		for id := range m.removedfeature_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeaturesUnitValuesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfeature_values {
		edges = append(edges, featuresunitvalues.EdgeFeatureValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeaturesUnitValuesMutation) EdgeCleared(name string) bool {
	switch name {
	case featuresunitvalues.EdgeFeatureValues:
		return m.clearedfeature_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeaturesUnitValuesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeaturesUnitValues unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeaturesUnitValuesMutation) ResetEdge(name string) error {
	switch name {
	case featuresunitvalues.EdgeFeatureValues:
		m.ResetFeatureValues()
		return nil
	}
	return fmt.Errorf("unknown FeaturesUnitValues edge %s", name)
}

// FeaturesValuesMutation represents an operation that mutates the FeaturesValues nodes in the graph.
type FeaturesValuesMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	deleted_at                  *time.Time
	value                       *string
	clearedFields               map[string]struct{}
	features                    *int
	clearedfeatures             bool
	feature_unit_values         *int
	clearedfeature_unit_values  bool
	feature_values_types        *int
	clearedfeature_values_types bool
	done                        bool
	oldValue                    func(context.Context) (*FeaturesValues, error)
	predicates                  []predicate.FeaturesValues
}

var _ ent.Mutation = (*FeaturesValuesMutation)(nil)

// featuresvaluesOption allows management of the mutation configuration using functional options.
type featuresvaluesOption func(*FeaturesValuesMutation)

// newFeaturesValuesMutation creates new mutation for the FeaturesValues entity.
func newFeaturesValuesMutation(c config, op Op, opts ...featuresvaluesOption) *FeaturesValuesMutation {
	m := &FeaturesValuesMutation{
		config:        c,
		op:            op,
		typ:           TypeFeaturesValues,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeaturesValuesID sets the ID field of the mutation.
func withFeaturesValuesID(id int) featuresvaluesOption {
	return func(m *FeaturesValuesMutation) {
		var (
			err   error
			once  sync.Once
			value *FeaturesValues
		)
		m.oldValue = func(ctx context.Context) (*FeaturesValues, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeaturesValues.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeaturesValues sets the old FeaturesValues of the mutation.
func withFeaturesValues(node *FeaturesValues) featuresvaluesOption {
	return func(m *FeaturesValuesMutation) {
		m.oldValue = func(context.Context) (*FeaturesValues, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeaturesValuesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeaturesValuesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeaturesValuesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeaturesValuesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeaturesValues.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeaturesValuesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeaturesValuesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeaturesValuesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeaturesValuesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeaturesValuesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeaturesValuesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featuresvalues.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeaturesValuesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featuresvalues.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeaturesValuesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featuresvalues.FieldDeletedAt)
}

// SetFeaturesID sets the "features_id" field.
func (m *FeaturesValuesMutation) SetFeaturesID(i int) {
	m.features = &i
}

// FeaturesID returns the value of the "features_id" field in the mutation.
func (m *FeaturesValuesMutation) FeaturesID() (r int, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturesID returns the old "features_id" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldFeaturesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturesID: %w", err)
	}
	return oldValue.FeaturesID, nil
}

// ResetFeaturesID resets all changes to the "features_id" field.
func (m *FeaturesValuesMutation) ResetFeaturesID() {
	m.features = nil
}

// SetFeatureUnitValuesID sets the "feature_unit_values_id" field.
func (m *FeaturesValuesMutation) SetFeatureUnitValuesID(i int) {
	m.feature_unit_values = &i
}

// FeatureUnitValuesID returns the value of the "feature_unit_values_id" field in the mutation.
func (m *FeaturesValuesMutation) FeatureUnitValuesID() (r int, exists bool) {
	v := m.feature_unit_values
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureUnitValuesID returns the old "feature_unit_values_id" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldFeatureUnitValuesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureUnitValuesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureUnitValuesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureUnitValuesID: %w", err)
	}
	return oldValue.FeatureUnitValuesID, nil
}

// ClearFeatureUnitValuesID clears the value of the "feature_unit_values_id" field.
func (m *FeaturesValuesMutation) ClearFeatureUnitValuesID() {
	m.feature_unit_values = nil
	m.clearedFields[featuresvalues.FieldFeatureUnitValuesID] = struct{}{}
}

// FeatureUnitValuesIDCleared returns if the "feature_unit_values_id" field was cleared in this mutation.
func (m *FeaturesValuesMutation) FeatureUnitValuesIDCleared() bool {
	_, ok := m.clearedFields[featuresvalues.FieldFeatureUnitValuesID]
	return ok
}

// ResetFeatureUnitValuesID resets all changes to the "feature_unit_values_id" field.
func (m *FeaturesValuesMutation) ResetFeatureUnitValuesID() {
	m.feature_unit_values = nil
	delete(m.clearedFields, featuresvalues.FieldFeatureUnitValuesID)
}

// SetFeatureValuesTypesID sets the "feature_values_types_id" field.
func (m *FeaturesValuesMutation) SetFeatureValuesTypesID(i int) {
	m.feature_values_types = &i
}

// FeatureValuesTypesID returns the value of the "feature_values_types_id" field in the mutation.
func (m *FeaturesValuesMutation) FeatureValuesTypesID() (r int, exists bool) {
	v := m.feature_values_types
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureValuesTypesID returns the old "feature_values_types_id" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldFeatureValuesTypesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureValuesTypesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureValuesTypesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureValuesTypesID: %w", err)
	}
	return oldValue.FeatureValuesTypesID, nil
}

// ClearFeatureValuesTypesID clears the value of the "feature_values_types_id" field.
func (m *FeaturesValuesMutation) ClearFeatureValuesTypesID() {
	m.feature_values_types = nil
	m.clearedFields[featuresvalues.FieldFeatureValuesTypesID] = struct{}{}
}

// FeatureValuesTypesIDCleared returns if the "feature_values_types_id" field was cleared in this mutation.
func (m *FeaturesValuesMutation) FeatureValuesTypesIDCleared() bool {
	_, ok := m.clearedFields[featuresvalues.FieldFeatureValuesTypesID]
	return ok
}

// ResetFeatureValuesTypesID resets all changes to the "feature_values_types_id" field.
func (m *FeaturesValuesMutation) ResetFeatureValuesTypesID() {
	m.feature_values_types = nil
	delete(m.clearedFields, featuresvalues.FieldFeatureValuesTypesID)
}

// SetValue sets the "value" field.
func (m *FeaturesValuesMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *FeaturesValuesMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the FeaturesValues entity.
// If the FeaturesValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *FeaturesValuesMutation) ResetValue() {
	m.value = nil
}

// ClearFeatures clears the "features" edge to the Features entity.
func (m *FeaturesValuesMutation) ClearFeatures() {
	m.clearedfeatures = true
	m.clearedFields[featuresvalues.FieldFeaturesID] = struct{}{}
}

// FeaturesCleared reports if the "features" edge to the Features entity was cleared.
func (m *FeaturesValuesMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *FeaturesValuesMutation) FeaturesIDs() (ids []int) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *FeaturesValuesMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// ClearFeatureUnitValues clears the "feature_unit_values" edge to the FeaturesUnitValues entity.
func (m *FeaturesValuesMutation) ClearFeatureUnitValues() {
	m.clearedfeature_unit_values = true
	m.clearedFields[featuresvalues.FieldFeatureUnitValuesID] = struct{}{}
}

// FeatureUnitValuesCleared reports if the "feature_unit_values" edge to the FeaturesUnitValues entity was cleared.
func (m *FeaturesValuesMutation) FeatureUnitValuesCleared() bool {
	return m.FeatureUnitValuesIDCleared() || m.clearedfeature_unit_values
}

// FeatureUnitValuesIDs returns the "feature_unit_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureUnitValuesID instead. It exists only for internal usage by the builders.
func (m *FeaturesValuesMutation) FeatureUnitValuesIDs() (ids []int) {
	if id := m.feature_unit_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatureUnitValues resets all changes to the "feature_unit_values" edge.
func (m *FeaturesValuesMutation) ResetFeatureUnitValues() {
	m.feature_unit_values = nil
	m.clearedfeature_unit_values = false
}

// ClearFeatureValuesTypes clears the "feature_values_types" edge to the FeaturesValuesTypes entity.
func (m *FeaturesValuesMutation) ClearFeatureValuesTypes() {
	m.clearedfeature_values_types = true
	m.clearedFields[featuresvalues.FieldFeatureValuesTypesID] = struct{}{}
}

// FeatureValuesTypesCleared reports if the "feature_values_types" edge to the FeaturesValuesTypes entity was cleared.
func (m *FeaturesValuesMutation) FeatureValuesTypesCleared() bool {
	return m.FeatureValuesTypesIDCleared() || m.clearedfeature_values_types
}

// FeatureValuesTypesIDs returns the "feature_values_types" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureValuesTypesID instead. It exists only for internal usage by the builders.
func (m *FeaturesValuesMutation) FeatureValuesTypesIDs() (ids []int) {
	if id := m.feature_values_types; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatureValuesTypes resets all changes to the "feature_values_types" edge.
func (m *FeaturesValuesMutation) ResetFeatureValuesTypes() {
	m.feature_values_types = nil
	m.clearedfeature_values_types = false
}

// Where appends a list predicates to the FeaturesValuesMutation builder.
func (m *FeaturesValuesMutation) Where(ps ...predicate.FeaturesValues) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeaturesValuesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeaturesValuesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeaturesValues, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeaturesValuesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeaturesValuesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeaturesValues).
func (m *FeaturesValuesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeaturesValuesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, featuresvalues.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featuresvalues.FieldDeletedAt)
	}
	if m.features != nil {
		fields = append(fields, featuresvalues.FieldFeaturesID)
	}
	if m.feature_unit_values != nil {
		fields = append(fields, featuresvalues.FieldFeatureUnitValuesID)
	}
	if m.feature_values_types != nil {
		fields = append(fields, featuresvalues.FieldFeatureValuesTypesID)
	}
	if m.value != nil {
		fields = append(fields, featuresvalues.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeaturesValuesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuresvalues.FieldCreatedAt:
		return m.CreatedAt()
	case featuresvalues.FieldDeletedAt:
		return m.DeletedAt()
	case featuresvalues.FieldFeaturesID:
		return m.FeaturesID()
	case featuresvalues.FieldFeatureUnitValuesID:
		return m.FeatureUnitValuesID()
	case featuresvalues.FieldFeatureValuesTypesID:
		return m.FeatureValuesTypesID()
	case featuresvalues.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeaturesValuesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuresvalues.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featuresvalues.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case featuresvalues.FieldFeaturesID:
		return m.OldFeaturesID(ctx)
	case featuresvalues.FieldFeatureUnitValuesID:
		return m.OldFeatureUnitValuesID(ctx)
	case featuresvalues.FieldFeatureValuesTypesID:
		return m.OldFeatureValuesTypesID(ctx)
	case featuresvalues.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown FeaturesValues field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesValuesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuresvalues.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featuresvalues.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case featuresvalues.FieldFeaturesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturesID(v)
		return nil
	case featuresvalues.FieldFeatureUnitValuesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureUnitValuesID(v)
		return nil
	case featuresvalues.FieldFeatureValuesTypesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureValuesTypesID(v)
		return nil
	case featuresvalues.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeaturesValues field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeaturesValuesMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeaturesValuesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesValuesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeaturesValues numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeaturesValuesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuresvalues.FieldDeletedAt) {
		fields = append(fields, featuresvalues.FieldDeletedAt)
	}
	if m.FieldCleared(featuresvalues.FieldFeatureUnitValuesID) {
		fields = append(fields, featuresvalues.FieldFeatureUnitValuesID)
	}
	if m.FieldCleared(featuresvalues.FieldFeatureValuesTypesID) {
		fields = append(fields, featuresvalues.FieldFeatureValuesTypesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeaturesValuesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeaturesValuesMutation) ClearField(name string) error {
	switch name {
	case featuresvalues.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case featuresvalues.FieldFeatureUnitValuesID:
		m.ClearFeatureUnitValuesID()
		return nil
	case featuresvalues.FieldFeatureValuesTypesID:
		m.ClearFeatureValuesTypesID()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValues nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeaturesValuesMutation) ResetField(name string) error {
	switch name {
	case featuresvalues.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featuresvalues.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case featuresvalues.FieldFeaturesID:
		m.ResetFeaturesID()
		return nil
	case featuresvalues.FieldFeatureUnitValuesID:
		m.ResetFeatureUnitValuesID()
		return nil
	case featuresvalues.FieldFeatureValuesTypesID:
		m.ResetFeatureValuesTypesID()
		return nil
	case featuresvalues.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValues field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeaturesValuesMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.features != nil {
		edges = append(edges, featuresvalues.EdgeFeatures)
	}
	if m.feature_unit_values != nil {
		edges = append(edges, featuresvalues.EdgeFeatureUnitValues)
	}
	if m.feature_values_types != nil {
		edges = append(edges, featuresvalues.EdgeFeatureValuesTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeaturesValuesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuresvalues.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	case featuresvalues.EdgeFeatureUnitValues:
		if id := m.feature_unit_values; id != nil {
			return []ent.Value{*id}
		}
	case featuresvalues.EdgeFeatureValuesTypes:
		if id := m.feature_values_types; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeaturesValuesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeaturesValuesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeaturesValuesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfeatures {
		edges = append(edges, featuresvalues.EdgeFeatures)
	}
	if m.clearedfeature_unit_values {
		edges = append(edges, featuresvalues.EdgeFeatureUnitValues)
	}
	if m.clearedfeature_values_types {
		edges = append(edges, featuresvalues.EdgeFeatureValuesTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeaturesValuesMutation) EdgeCleared(name string) bool {
	switch name {
	case featuresvalues.EdgeFeatures:
		return m.clearedfeatures
	case featuresvalues.EdgeFeatureUnitValues:
		return m.clearedfeature_unit_values
	case featuresvalues.EdgeFeatureValuesTypes:
		return m.clearedfeature_values_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeaturesValuesMutation) ClearEdge(name string) error {
	switch name {
	case featuresvalues.EdgeFeatures:
		m.ClearFeatures()
		return nil
	case featuresvalues.EdgeFeatureUnitValues:
		m.ClearFeatureUnitValues()
		return nil
	case featuresvalues.EdgeFeatureValuesTypes:
		m.ClearFeatureValuesTypes()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValues unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeaturesValuesMutation) ResetEdge(name string) error {
	switch name {
	case featuresvalues.EdgeFeatures:
		m.ResetFeatures()
		return nil
	case featuresvalues.EdgeFeatureUnitValues:
		m.ResetFeatureUnitValues()
		return nil
	case featuresvalues.EdgeFeatureValuesTypes:
		m.ResetFeatureValuesTypes()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValues edge %s", name)
}

// FeaturesValuesTypesMutation represents an operation that mutates the FeaturesValuesTypes nodes in the graph.
type FeaturesValuesTypesMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	clearedFields         map[string]struct{}
	product_info          map[int]struct{}
	removedproduct_info   map[int]struct{}
	clearedproduct_info   bool
	feature_values        map[int]struct{}
	removedfeature_values map[int]struct{}
	clearedfeature_values bool
	done                  bool
	oldValue              func(context.Context) (*FeaturesValuesTypes, error)
	predicates            []predicate.FeaturesValuesTypes
}

var _ ent.Mutation = (*FeaturesValuesTypesMutation)(nil)

// featuresvaluestypesOption allows management of the mutation configuration using functional options.
type featuresvaluestypesOption func(*FeaturesValuesTypesMutation)

// newFeaturesValuesTypesMutation creates new mutation for the FeaturesValuesTypes entity.
func newFeaturesValuesTypesMutation(c config, op Op, opts ...featuresvaluestypesOption) *FeaturesValuesTypesMutation {
	m := &FeaturesValuesTypesMutation{
		config:        c,
		op:            op,
		typ:           TypeFeaturesValuesTypes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeaturesValuesTypesID sets the ID field of the mutation.
func withFeaturesValuesTypesID(id int) featuresvaluestypesOption {
	return func(m *FeaturesValuesTypesMutation) {
		var (
			err   error
			once  sync.Once
			value *FeaturesValuesTypes
		)
		m.oldValue = func(ctx context.Context) (*FeaturesValuesTypes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeaturesValuesTypes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeaturesValuesTypes sets the old FeaturesValuesTypes of the mutation.
func withFeaturesValuesTypes(node *FeaturesValuesTypes) featuresvaluestypesOption {
	return func(m *FeaturesValuesTypesMutation) {
		m.oldValue = func(context.Context) (*FeaturesValuesTypes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeaturesValuesTypesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeaturesValuesTypesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeaturesValuesTypesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeaturesValuesTypesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeaturesValuesTypes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeaturesValuesTypesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeaturesValuesTypesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeaturesValuesTypes entity.
// If the FeaturesValuesTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesTypesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeaturesValuesTypesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeaturesValuesTypesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeaturesValuesTypesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeaturesValuesTypes entity.
// If the FeaturesValuesTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesTypesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeaturesValuesTypesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featuresvaluestypes.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeaturesValuesTypesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featuresvaluestypes.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeaturesValuesTypesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featuresvaluestypes.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *FeaturesValuesTypesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeaturesValuesTypesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeaturesValuesTypes entity.
// If the FeaturesValuesTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeaturesValuesTypesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeaturesValuesTypesMutation) ResetName() {
	m.name = nil
}

// AddProductInfoIDs adds the "product_info" edge to the ProductInfo entity by ids.
func (m *FeaturesValuesTypesMutation) AddProductInfoIDs(ids ...int) {
	if m.product_info == nil {
		m.product_info = make(map[int]struct{})
	}
	for i := range ids {
		m.product_info[ids[i]] = struct{}{}
	}
}

// ClearProductInfo clears the "product_info" edge to the ProductInfo entity.
func (m *FeaturesValuesTypesMutation) ClearProductInfo() {
	m.clearedproduct_info = true
}

// ProductInfoCleared reports if the "product_info" edge to the ProductInfo entity was cleared.
func (m *FeaturesValuesTypesMutation) ProductInfoCleared() bool {
	return m.clearedproduct_info
}

// RemoveProductInfoIDs removes the "product_info" edge to the ProductInfo entity by IDs.
func (m *FeaturesValuesTypesMutation) RemoveProductInfoIDs(ids ...int) {
	if m.removedproduct_info == nil {
		m.removedproduct_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_info, ids[i])
		m.removedproduct_info[ids[i]] = struct{}{}
	}
}

// RemovedProductInfo returns the removed IDs of the "product_info" edge to the ProductInfo entity.
func (m *FeaturesValuesTypesMutation) RemovedProductInfoIDs() (ids []int) {
	for id := range m.removedproduct_info {
		ids = append(ids, id)
	}
	return
}

// ProductInfoIDs returns the "product_info" edge IDs in the mutation.
func (m *FeaturesValuesTypesMutation) ProductInfoIDs() (ids []int) {
	for id := range m.product_info {
		ids = append(ids, id)
	}
	return
}

// ResetProductInfo resets all changes to the "product_info" edge.
func (m *FeaturesValuesTypesMutation) ResetProductInfo() {
	m.product_info = nil
	m.clearedproduct_info = false
	m.removedproduct_info = nil
}

// AddFeatureValueIDs adds the "feature_values" edge to the FeaturesValues entity by ids.
func (m *FeaturesValuesTypesMutation) AddFeatureValueIDs(ids ...int) {
	if m.feature_values == nil {
		m.feature_values = make(map[int]struct{})
	}
	for i := range ids {
		m.feature_values[ids[i]] = struct{}{}
	}
}

// ClearFeatureValues clears the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesValuesTypesMutation) ClearFeatureValues() {
	m.clearedfeature_values = true
}

// FeatureValuesCleared reports if the "feature_values" edge to the FeaturesValues entity was cleared.
func (m *FeaturesValuesTypesMutation) FeatureValuesCleared() bool {
	return m.clearedfeature_values
}

// RemoveFeatureValueIDs removes the "feature_values" edge to the FeaturesValues entity by IDs.
func (m *FeaturesValuesTypesMutation) RemoveFeatureValueIDs(ids ...int) {
	if m.removedfeature_values == nil {
		m.removedfeature_values = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feature_values, ids[i])
		m.removedfeature_values[ids[i]] = struct{}{}
	}
}

// RemovedFeatureValues returns the removed IDs of the "feature_values" edge to the FeaturesValues entity.
func (m *FeaturesValuesTypesMutation) RemovedFeatureValuesIDs() (ids []int) {
	for id := range m.removedfeature_values {
		ids = append(ids, id)
	}
	return
}

// FeatureValuesIDs returns the "feature_values" edge IDs in the mutation.
func (m *FeaturesValuesTypesMutation) FeatureValuesIDs() (ids []int) {
	for id := range m.feature_values {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureValues resets all changes to the "feature_values" edge.
func (m *FeaturesValuesTypesMutation) ResetFeatureValues() {
	m.feature_values = nil
	m.clearedfeature_values = false
	m.removedfeature_values = nil
}

// Where appends a list predicates to the FeaturesValuesTypesMutation builder.
func (m *FeaturesValuesTypesMutation) Where(ps ...predicate.FeaturesValuesTypes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeaturesValuesTypesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeaturesValuesTypesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeaturesValuesTypes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeaturesValuesTypesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeaturesValuesTypesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeaturesValuesTypes).
func (m *FeaturesValuesTypesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeaturesValuesTypesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, featuresvaluestypes.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featuresvaluestypes.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, featuresvaluestypes.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeaturesValuesTypesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuresvaluestypes.FieldCreatedAt:
		return m.CreatedAt()
	case featuresvaluestypes.FieldDeletedAt:
		return m.DeletedAt()
	case featuresvaluestypes.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeaturesValuesTypesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuresvaluestypes.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featuresvaluestypes.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case featuresvaluestypes.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown FeaturesValuesTypes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesValuesTypesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuresvaluestypes.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featuresvaluestypes.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case featuresvaluestypes.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown FeaturesValuesTypes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeaturesValuesTypesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeaturesValuesTypesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeaturesValuesTypesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeaturesValuesTypes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeaturesValuesTypesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuresvaluestypes.FieldDeletedAt) {
		fields = append(fields, featuresvaluestypes.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeaturesValuesTypesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeaturesValuesTypesMutation) ClearField(name string) error {
	switch name {
	case featuresvaluestypes.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValuesTypes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeaturesValuesTypesMutation) ResetField(name string) error {
	switch name {
	case featuresvaluestypes.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featuresvaluestypes.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case featuresvaluestypes.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValuesTypes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeaturesValuesTypesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product_info != nil {
		edges = append(edges, featuresvaluestypes.EdgeProductInfo)
	}
	if m.feature_values != nil {
		edges = append(edges, featuresvaluestypes.EdgeFeatureValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeaturesValuesTypesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuresvaluestypes.EdgeProductInfo:
		ids := make([]ent.Value, 0, len(m.product_info))
		for id := range m.product_info {
			ids = append(ids, id)
		}
		return ids
	case featuresvaluestypes.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.feature_values))
		for id := range m.feature_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeaturesValuesTypesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct_info != nil {
		edges = append(edges, featuresvaluestypes.EdgeProductInfo)
	}
	if m.removedfeature_values != nil {
		edges = append(edges, featuresvaluestypes.EdgeFeatureValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeaturesValuesTypesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featuresvaluestypes.EdgeProductInfo:
		ids := make([]ent.Value, 0, len(m.removedproduct_info))
		for id := range m.removedproduct_info {
			ids = append(ids, id)
		}
		return ids
	case featuresvaluestypes.EdgeFeatureValues:
		ids := make([]ent.Value, 0, len(m.removedfeature_values))
		for id := range m.removedfeature_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeaturesValuesTypesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct_info {
		edges = append(edges, featuresvaluestypes.EdgeProductInfo)
	}
	if m.clearedfeature_values {
		edges = append(edges, featuresvaluestypes.EdgeFeatureValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeaturesValuesTypesMutation) EdgeCleared(name string) bool {
	switch name {
	case featuresvaluestypes.EdgeProductInfo:
		return m.clearedproduct_info
	case featuresvaluestypes.EdgeFeatureValues:
		return m.clearedfeature_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeaturesValuesTypesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeaturesValuesTypes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeaturesValuesTypesMutation) ResetEdge(name string) error {
	switch name {
	case featuresvaluestypes.EdgeProductInfo:
		m.ResetProductInfo()
		return nil
	case featuresvaluestypes.EdgeFeatureValues:
		m.ResetFeatureValues()
		return nil
	}
	return fmt.Errorf("unknown FeaturesValuesTypes edge %s", name)
}

// ImageFolderPathMutation represents an operation that mutates the ImageFolderPath nodes in the graph.
type ImageFolderPathMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	deleted_at                 *time.Time
	clearedFields              map[string]struct{}
	image_folder_source        *int
	clearedimage_folder_source bool
	images                     map[int]struct{}
	removedimages              map[int]struct{}
	clearedimages              bool
	done                       bool
	oldValue                   func(context.Context) (*ImageFolderPath, error)
	predicates                 []predicate.ImageFolderPath
}

var _ ent.Mutation = (*ImageFolderPathMutation)(nil)

// imagefolderpathOption allows management of the mutation configuration using functional options.
type imagefolderpathOption func(*ImageFolderPathMutation)

// newImageFolderPathMutation creates new mutation for the ImageFolderPath entity.
func newImageFolderPathMutation(c config, op Op, opts ...imagefolderpathOption) *ImageFolderPathMutation {
	m := &ImageFolderPathMutation{
		config:        c,
		op:            op,
		typ:           TypeImageFolderPath,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageFolderPathID sets the ID field of the mutation.
func withImageFolderPathID(id int) imagefolderpathOption {
	return func(m *ImageFolderPathMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageFolderPath
		)
		m.oldValue = func(ctx context.Context) (*ImageFolderPath, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageFolderPath.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageFolderPath sets the old ImageFolderPath of the mutation.
func withImageFolderPath(node *ImageFolderPath) imagefolderpathOption {
	return func(m *ImageFolderPathMutation) {
		m.oldValue = func(context.Context) (*ImageFolderPath, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageFolderPathMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageFolderPathMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageFolderPathMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageFolderPathMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageFolderPath.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageFolderPathMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageFolderPathMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageFolderPath entity.
// If the ImageFolderPath object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderPathMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageFolderPathMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ImageFolderPathMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ImageFolderPathMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ImageFolderPath entity.
// If the ImageFolderPath object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderPathMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ImageFolderPathMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[imagefolderpath.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ImageFolderPathMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[imagefolderpath.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ImageFolderPathMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, imagefolderpath.FieldDeletedAt)
}

// SetImageFolderSourceID sets the "image_folder_source_id" field.
func (m *ImageFolderPathMutation) SetImageFolderSourceID(i int) {
	m.image_folder_source = &i
}

// ImageFolderSourceID returns the value of the "image_folder_source_id" field in the mutation.
func (m *ImageFolderPathMutation) ImageFolderSourceID() (r int, exists bool) {
	v := m.image_folder_source
	if v == nil {
		return
	}
	return *v, true
}

// OldImageFolderSourceID returns the old "image_folder_source_id" field's value of the ImageFolderPath entity.
// If the ImageFolderPath object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderPathMutation) OldImageFolderSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageFolderSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageFolderSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageFolderSourceID: %w", err)
	}
	return oldValue.ImageFolderSourceID, nil
}

// ResetImageFolderSourceID resets all changes to the "image_folder_source_id" field.
func (m *ImageFolderPathMutation) ResetImageFolderSourceID() {
	m.image_folder_source = nil
}

// ClearImageFolderSource clears the "image_folder_source" edge to the ImageFolderSource entity.
func (m *ImageFolderPathMutation) ClearImageFolderSource() {
	m.clearedimage_folder_source = true
	m.clearedFields[imagefolderpath.FieldImageFolderSourceID] = struct{}{}
}

// ImageFolderSourceCleared reports if the "image_folder_source" edge to the ImageFolderSource entity was cleared.
func (m *ImageFolderPathMutation) ImageFolderSourceCleared() bool {
	return m.clearedimage_folder_source
}

// ImageFolderSourceIDs returns the "image_folder_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageFolderSourceID instead. It exists only for internal usage by the builders.
func (m *ImageFolderPathMutation) ImageFolderSourceIDs() (ids []int) {
	if id := m.image_folder_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImageFolderSource resets all changes to the "image_folder_source" edge.
func (m *ImageFolderPathMutation) ResetImageFolderSource() {
	m.image_folder_source = nil
	m.clearedimage_folder_source = false
}

// AddImageIDs adds the "images" edge to the Images entity by ids.
func (m *ImageFolderPathMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Images entity.
func (m *ImageFolderPathMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Images entity was cleared.
func (m *ImageFolderPathMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Images entity by IDs.
func (m *ImageFolderPathMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Images entity.
func (m *ImageFolderPathMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ImageFolderPathMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ImageFolderPathMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ImageFolderPathMutation builder.
func (m *ImageFolderPathMutation) Where(ps ...predicate.ImageFolderPath) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageFolderPathMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageFolderPathMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageFolderPath, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageFolderPathMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageFolderPathMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageFolderPath).
func (m *ImageFolderPathMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageFolderPathMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, imagefolderpath.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, imagefolderpath.FieldDeletedAt)
	}
	if m.image_folder_source != nil {
		fields = append(fields, imagefolderpath.FieldImageFolderSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageFolderPathMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagefolderpath.FieldCreatedAt:
		return m.CreatedAt()
	case imagefolderpath.FieldDeletedAt:
		return m.DeletedAt()
	case imagefolderpath.FieldImageFolderSourceID:
		return m.ImageFolderSourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageFolderPathMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagefolderpath.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagefolderpath.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case imagefolderpath.FieldImageFolderSourceID:
		return m.OldImageFolderSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown ImageFolderPath field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageFolderPathMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagefolderpath.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagefolderpath.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case imagefolderpath.FieldImageFolderSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageFolderSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown ImageFolderPath field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageFolderPathMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageFolderPathMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageFolderPathMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageFolderPath numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageFolderPathMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(imagefolderpath.FieldDeletedAt) {
		fields = append(fields, imagefolderpath.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageFolderPathMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageFolderPathMutation) ClearField(name string) error {
	switch name {
	case imagefolderpath.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderPath nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageFolderPathMutation) ResetField(name string) error {
	switch name {
	case imagefolderpath.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagefolderpath.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case imagefolderpath.FieldImageFolderSourceID:
		m.ResetImageFolderSourceID()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderPath field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageFolderPathMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.image_folder_source != nil {
		edges = append(edges, imagefolderpath.EdgeImageFolderSource)
	}
	if m.images != nil {
		edges = append(edges, imagefolderpath.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageFolderPathMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagefolderpath.EdgeImageFolderSource:
		if id := m.image_folder_source; id != nil {
			return []ent.Value{*id}
		}
	case imagefolderpath.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageFolderPathMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedimages != nil {
		edges = append(edges, imagefolderpath.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageFolderPathMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case imagefolderpath.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageFolderPathMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedimage_folder_source {
		edges = append(edges, imagefolderpath.EdgeImageFolderSource)
	}
	if m.clearedimages {
		edges = append(edges, imagefolderpath.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageFolderPathMutation) EdgeCleared(name string) bool {
	switch name {
	case imagefolderpath.EdgeImageFolderSource:
		return m.clearedimage_folder_source
	case imagefolderpath.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageFolderPathMutation) ClearEdge(name string) error {
	switch name {
	case imagefolderpath.EdgeImageFolderSource:
		m.ClearImageFolderSource()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderPath unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageFolderPathMutation) ResetEdge(name string) error {
	switch name {
	case imagefolderpath.EdgeImageFolderSource:
		m.ResetImageFolderSource()
		return nil
	case imagefolderpath.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderPath edge %s", name)
}

// ImageFolderSourceMutation represents an operation that mutates the ImageFolderSource nodes in the graph.
type ImageFolderSourceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	base_url                 *string
	access_key               *string
	secret_key               *string
	clearedFields            map[string]struct{}
	image_folder_path        map[int]struct{}
	removedimage_folder_path map[int]struct{}
	clearedimage_folder_path bool
	done                     bool
	oldValue                 func(context.Context) (*ImageFolderSource, error)
	predicates               []predicate.ImageFolderSource
}

var _ ent.Mutation = (*ImageFolderSourceMutation)(nil)

// imagefoldersourceOption allows management of the mutation configuration using functional options.
type imagefoldersourceOption func(*ImageFolderSourceMutation)

// newImageFolderSourceMutation creates new mutation for the ImageFolderSource entity.
func newImageFolderSourceMutation(c config, op Op, opts ...imagefoldersourceOption) *ImageFolderSourceMutation {
	m := &ImageFolderSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeImageFolderSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageFolderSourceID sets the ID field of the mutation.
func withImageFolderSourceID(id int) imagefoldersourceOption {
	return func(m *ImageFolderSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageFolderSource
		)
		m.oldValue = func(ctx context.Context) (*ImageFolderSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageFolderSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageFolderSource sets the old ImageFolderSource of the mutation.
func withImageFolderSource(node *ImageFolderSource) imagefoldersourceOption {
	return func(m *ImageFolderSourceMutation) {
		m.oldValue = func(context.Context) (*ImageFolderSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageFolderSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageFolderSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageFolderSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageFolderSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageFolderSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageFolderSourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageFolderSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageFolderSourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ImageFolderSourceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ImageFolderSourceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ImageFolderSourceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[imagefoldersource.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ImageFolderSourceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[imagefoldersource.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ImageFolderSourceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, imagefoldersource.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ImageFolderSourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageFolderSourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageFolderSourceMutation) ResetName() {
	m.name = nil
}

// SetBaseURL sets the "base_url" field.
func (m *ImageFolderSourceMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ImageFolderSourceMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldBaseURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ImageFolderSourceMutation) ResetBaseURL() {
	m.base_url = nil
}

// SetAccessKey sets the "access_key" field.
func (m *ImageFolderSourceMutation) SetAccessKey(s string) {
	m.access_key = &s
}

// AccessKey returns the value of the "access_key" field in the mutation.
func (m *ImageFolderSourceMutation) AccessKey() (r string, exists bool) {
	v := m.access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "access_key" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldAccessKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ClearAccessKey clears the value of the "access_key" field.
func (m *ImageFolderSourceMutation) ClearAccessKey() {
	m.access_key = nil
	m.clearedFields[imagefoldersource.FieldAccessKey] = struct{}{}
}

// AccessKeyCleared returns if the "access_key" field was cleared in this mutation.
func (m *ImageFolderSourceMutation) AccessKeyCleared() bool {
	_, ok := m.clearedFields[imagefoldersource.FieldAccessKey]
	return ok
}

// ResetAccessKey resets all changes to the "access_key" field.
func (m *ImageFolderSourceMutation) ResetAccessKey() {
	m.access_key = nil
	delete(m.clearedFields, imagefoldersource.FieldAccessKey)
}

// SetSecretKey sets the "secret_key" field.
func (m *ImageFolderSourceMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *ImageFolderSourceMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the ImageFolderSource entity.
// If the ImageFolderSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageFolderSourceMutation) OldSecretKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secret_key" field.
func (m *ImageFolderSourceMutation) ClearSecretKey() {
	m.secret_key = nil
	m.clearedFields[imagefoldersource.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secret_key" field was cleared in this mutation.
func (m *ImageFolderSourceMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[imagefoldersource.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *ImageFolderSourceMutation) ResetSecretKey() {
	m.secret_key = nil
	delete(m.clearedFields, imagefoldersource.FieldSecretKey)
}

// AddImageFolderPathIDs adds the "image_folder_path" edge to the ImageFolderPath entity by ids.
func (m *ImageFolderSourceMutation) AddImageFolderPathIDs(ids ...int) {
	if m.image_folder_path == nil {
		m.image_folder_path = make(map[int]struct{})
	}
	for i := range ids {
		m.image_folder_path[ids[i]] = struct{}{}
	}
}

// ClearImageFolderPath clears the "image_folder_path" edge to the ImageFolderPath entity.
func (m *ImageFolderSourceMutation) ClearImageFolderPath() {
	m.clearedimage_folder_path = true
}

// ImageFolderPathCleared reports if the "image_folder_path" edge to the ImageFolderPath entity was cleared.
func (m *ImageFolderSourceMutation) ImageFolderPathCleared() bool {
	return m.clearedimage_folder_path
}

// RemoveImageFolderPathIDs removes the "image_folder_path" edge to the ImageFolderPath entity by IDs.
func (m *ImageFolderSourceMutation) RemoveImageFolderPathIDs(ids ...int) {
	if m.removedimage_folder_path == nil {
		m.removedimage_folder_path = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.image_folder_path, ids[i])
		m.removedimage_folder_path[ids[i]] = struct{}{}
	}
}

// RemovedImageFolderPath returns the removed IDs of the "image_folder_path" edge to the ImageFolderPath entity.
func (m *ImageFolderSourceMutation) RemovedImageFolderPathIDs() (ids []int) {
	for id := range m.removedimage_folder_path {
		ids = append(ids, id)
	}
	return
}

// ImageFolderPathIDs returns the "image_folder_path" edge IDs in the mutation.
func (m *ImageFolderSourceMutation) ImageFolderPathIDs() (ids []int) {
	for id := range m.image_folder_path {
		ids = append(ids, id)
	}
	return
}

// ResetImageFolderPath resets all changes to the "image_folder_path" edge.
func (m *ImageFolderSourceMutation) ResetImageFolderPath() {
	m.image_folder_path = nil
	m.clearedimage_folder_path = false
	m.removedimage_folder_path = nil
}

// Where appends a list predicates to the ImageFolderSourceMutation builder.
func (m *ImageFolderSourceMutation) Where(ps ...predicate.ImageFolderSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageFolderSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageFolderSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageFolderSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageFolderSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageFolderSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageFolderSource).
func (m *ImageFolderSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageFolderSourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, imagefoldersource.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, imagefoldersource.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, imagefoldersource.FieldName)
	}
	if m.base_url != nil {
		fields = append(fields, imagefoldersource.FieldBaseURL)
	}
	if m.access_key != nil {
		fields = append(fields, imagefoldersource.FieldAccessKey)
	}
	if m.secret_key != nil {
		fields = append(fields, imagefoldersource.FieldSecretKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageFolderSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagefoldersource.FieldCreatedAt:
		return m.CreatedAt()
	case imagefoldersource.FieldDeletedAt:
		return m.DeletedAt()
	case imagefoldersource.FieldName:
		return m.Name()
	case imagefoldersource.FieldBaseURL:
		return m.BaseURL()
	case imagefoldersource.FieldAccessKey:
		return m.AccessKey()
	case imagefoldersource.FieldSecretKey:
		return m.SecretKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageFolderSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagefoldersource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagefoldersource.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case imagefoldersource.FieldName:
		return m.OldName(ctx)
	case imagefoldersource.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case imagefoldersource.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case imagefoldersource.FieldSecretKey:
		return m.OldSecretKey(ctx)
	}
	return nil, fmt.Errorf("unknown ImageFolderSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageFolderSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagefoldersource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagefoldersource.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case imagefoldersource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case imagefoldersource.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case imagefoldersource.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case imagefoldersource.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	}
	return fmt.Errorf("unknown ImageFolderSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageFolderSourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageFolderSourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageFolderSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageFolderSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageFolderSourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(imagefoldersource.FieldDeletedAt) {
		fields = append(fields, imagefoldersource.FieldDeletedAt)
	}
	if m.FieldCleared(imagefoldersource.FieldAccessKey) {
		fields = append(fields, imagefoldersource.FieldAccessKey)
	}
	if m.FieldCleared(imagefoldersource.FieldSecretKey) {
		fields = append(fields, imagefoldersource.FieldSecretKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageFolderSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageFolderSourceMutation) ClearField(name string) error {
	switch name {
	case imagefoldersource.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case imagefoldersource.FieldAccessKey:
		m.ClearAccessKey()
		return nil
	case imagefoldersource.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageFolderSourceMutation) ResetField(name string) error {
	switch name {
	case imagefoldersource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagefoldersource.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case imagefoldersource.FieldName:
		m.ResetName()
		return nil
	case imagefoldersource.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case imagefoldersource.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case imagefoldersource.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageFolderSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.image_folder_path != nil {
		edges = append(edges, imagefoldersource.EdgeImageFolderPath)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageFolderSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagefoldersource.EdgeImageFolderPath:
		ids := make([]ent.Value, 0, len(m.image_folder_path))
		for id := range m.image_folder_path {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageFolderSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedimage_folder_path != nil {
		edges = append(edges, imagefoldersource.EdgeImageFolderPath)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageFolderSourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case imagefoldersource.EdgeImageFolderPath:
		ids := make([]ent.Value, 0, len(m.removedimage_folder_path))
		for id := range m.removedimage_folder_path {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageFolderSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimage_folder_path {
		edges = append(edges, imagefoldersource.EdgeImageFolderPath)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageFolderSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case imagefoldersource.EdgeImageFolderPath:
		return m.clearedimage_folder_path
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageFolderSourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageFolderSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageFolderSourceMutation) ResetEdge(name string) error {
	switch name {
	case imagefoldersource.EdgeImageFolderPath:
		m.ResetImageFolderPath()
		return nil
	}
	return fmt.Errorf("unknown ImageFolderSource edge %s", name)
}

// ImagesMutation represents an operation that mutates the Images nodes in the graph.
type ImagesMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	deleted_at               *time.Time
	content                  *string
	_path                    *string
	clearedFields            map[string]struct{}
	image_folder_path        *int
	clearedimage_folder_path bool
	product_has_image        map[int]struct{}
	removedproduct_has_image map[int]struct{}
	clearedproduct_has_image bool
	done                     bool
	oldValue                 func(context.Context) (*Images, error)
	predicates               []predicate.Images
}

var _ ent.Mutation = (*ImagesMutation)(nil)

// imagesOption allows management of the mutation configuration using functional options.
type imagesOption func(*ImagesMutation)

// newImagesMutation creates new mutation for the Images entity.
func newImagesMutation(c config, op Op, opts ...imagesOption) *ImagesMutation {
	m := &ImagesMutation{
		config:        c,
		op:            op,
		typ:           TypeImages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImagesID sets the ID field of the mutation.
func withImagesID(id int) imagesOption {
	return func(m *ImagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Images
		)
		m.oldValue = func(ctx context.Context) (*Images, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Images.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImages sets the old Images of the mutation.
func withImages(node *Images) imagesOption {
	return func(m *ImagesMutation) {
		m.oldValue = func(context.Context) (*Images, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImagesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImagesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Images.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Images entity.
// If the Images object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImagesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ImagesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ImagesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Images entity.
// If the Images object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImagesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ImagesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[images.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ImagesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[images.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ImagesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, images.FieldDeletedAt)
}

// SetContent sets the "content" field.
func (m *ImagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ImagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Images entity.
// If the Images object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImagesMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ImagesMutation) ResetContent() {
	m.content = nil
}

// SetPath sets the "path" field.
func (m *ImagesMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ImagesMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Images entity.
// If the Images object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImagesMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ImagesMutation) ResetPath() {
	m._path = nil
}

// SetImageFolderPathID sets the "image_folder_path" edge to the ImageFolderPath entity by id.
func (m *ImagesMutation) SetImageFolderPathID(id int) {
	m.image_folder_path = &id
}

// ClearImageFolderPath clears the "image_folder_path" edge to the ImageFolderPath entity.
func (m *ImagesMutation) ClearImageFolderPath() {
	m.clearedimage_folder_path = true
}

// ImageFolderPathCleared reports if the "image_folder_path" edge to the ImageFolderPath entity was cleared.
func (m *ImagesMutation) ImageFolderPathCleared() bool {
	return m.clearedimage_folder_path
}

// ImageFolderPathID returns the "image_folder_path" edge ID in the mutation.
func (m *ImagesMutation) ImageFolderPathID() (id int, exists bool) {
	if m.image_folder_path != nil {
		return *m.image_folder_path, true
	}
	return
}

// ImageFolderPathIDs returns the "image_folder_path" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageFolderPathID instead. It exists only for internal usage by the builders.
func (m *ImagesMutation) ImageFolderPathIDs() (ids []int) {
	if id := m.image_folder_path; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImageFolderPath resets all changes to the "image_folder_path" edge.
func (m *ImagesMutation) ResetImageFolderPath() {
	m.image_folder_path = nil
	m.clearedimage_folder_path = false
}

// AddProductHasImageIDs adds the "product_has_image" edge to the ProductHasImage entity by ids.
func (m *ImagesMutation) AddProductHasImageIDs(ids ...int) {
	if m.product_has_image == nil {
		m.product_has_image = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_image[ids[i]] = struct{}{}
	}
}

// ClearProductHasImage clears the "product_has_image" edge to the ProductHasImage entity.
func (m *ImagesMutation) ClearProductHasImage() {
	m.clearedproduct_has_image = true
}

// ProductHasImageCleared reports if the "product_has_image" edge to the ProductHasImage entity was cleared.
func (m *ImagesMutation) ProductHasImageCleared() bool {
	return m.clearedproduct_has_image
}

// RemoveProductHasImageIDs removes the "product_has_image" edge to the ProductHasImage entity by IDs.
func (m *ImagesMutation) RemoveProductHasImageIDs(ids ...int) {
	if m.removedproduct_has_image == nil {
		m.removedproduct_has_image = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_image, ids[i])
		m.removedproduct_has_image[ids[i]] = struct{}{}
	}
}

// RemovedProductHasImage returns the removed IDs of the "product_has_image" edge to the ProductHasImage entity.
func (m *ImagesMutation) RemovedProductHasImageIDs() (ids []int) {
	for id := range m.removedproduct_has_image {
		ids = append(ids, id)
	}
	return
}

// ProductHasImageIDs returns the "product_has_image" edge IDs in the mutation.
func (m *ImagesMutation) ProductHasImageIDs() (ids []int) {
	for id := range m.product_has_image {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasImage resets all changes to the "product_has_image" edge.
func (m *ImagesMutation) ResetProductHasImage() {
	m.product_has_image = nil
	m.clearedproduct_has_image = false
	m.removedproduct_has_image = nil
}

// Where appends a list predicates to the ImagesMutation builder.
func (m *ImagesMutation) Where(ps ...predicate.Images) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Images, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Images).
func (m *ImagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImagesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, images.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, images.FieldDeletedAt)
	}
	if m.content != nil {
		fields = append(fields, images.FieldContent)
	}
	if m._path != nil {
		fields = append(fields, images.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case images.FieldCreatedAt:
		return m.CreatedAt()
	case images.FieldDeletedAt:
		return m.DeletedAt()
	case images.FieldContent:
		return m.Content()
	case images.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case images.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case images.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case images.FieldContent:
		return m.OldContent(ctx)
	case images.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Images field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case images.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case images.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case images.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case images.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Images field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImagesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImagesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Images numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImagesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(images.FieldDeletedAt) {
		fields = append(fields, images.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImagesMutation) ClearField(name string) error {
	switch name {
	case images.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Images nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImagesMutation) ResetField(name string) error {
	switch name {
	case images.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case images.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case images.FieldContent:
		m.ResetContent()
		return nil
	case images.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Images field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.image_folder_path != nil {
		edges = append(edges, images.EdgeImageFolderPath)
	}
	if m.product_has_image != nil {
		edges = append(edges, images.EdgeProductHasImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImagesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case images.EdgeImageFolderPath:
		if id := m.image_folder_path; id != nil {
			return []ent.Value{*id}
		}
	case images.EdgeProductHasImage:
		ids := make([]ent.Value, 0, len(m.product_has_image))
		for id := range m.product_has_image {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct_has_image != nil {
		edges = append(edges, images.EdgeProductHasImage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImagesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case images.EdgeProductHasImage:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_image))
		for id := range m.removedproduct_has_image {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedimage_folder_path {
		edges = append(edges, images.EdgeImageFolderPath)
	}
	if m.clearedproduct_has_image {
		edges = append(edges, images.EdgeProductHasImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImagesMutation) EdgeCleared(name string) bool {
	switch name {
	case images.EdgeImageFolderPath:
		return m.clearedimage_folder_path
	case images.EdgeProductHasImage:
		return m.clearedproduct_has_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImagesMutation) ClearEdge(name string) error {
	switch name {
	case images.EdgeImageFolderPath:
		m.ClearImageFolderPath()
		return nil
	}
	return fmt.Errorf("unknown Images unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImagesMutation) ResetEdge(name string) error {
	switch name {
	case images.EdgeImageFolderPath:
		m.ResetImageFolderPath()
		return nil
	case images.EdgeProductHasImage:
		m.ResetProductHasImage()
		return nil
	}
	return fmt.Errorf("unknown Images edge %s", name)
}

// InfoTypesMutation represents an operation that mutates the InfoTypes nodes in the graph.
type InfoTypesMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	deleted_at          *time.Time
	name                *string
	clearedFields       map[string]struct{}
	product_info        map[int]struct{}
	removedproduct_info map[int]struct{}
	clearedproduct_info bool
	done                bool
	oldValue            func(context.Context) (*InfoTypes, error)
	predicates          []predicate.InfoTypes
}

var _ ent.Mutation = (*InfoTypesMutation)(nil)

// infotypesOption allows management of the mutation configuration using functional options.
type infotypesOption func(*InfoTypesMutation)

// newInfoTypesMutation creates new mutation for the InfoTypes entity.
func newInfoTypesMutation(c config, op Op, opts ...infotypesOption) *InfoTypesMutation {
	m := &InfoTypesMutation{
		config:        c,
		op:            op,
		typ:           TypeInfoTypes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInfoTypesID sets the ID field of the mutation.
func withInfoTypesID(id int) infotypesOption {
	return func(m *InfoTypesMutation) {
		var (
			err   error
			once  sync.Once
			value *InfoTypes
		)
		m.oldValue = func(ctx context.Context) (*InfoTypes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InfoTypes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInfoTypes sets the old InfoTypes of the mutation.
func withInfoTypes(node *InfoTypes) infotypesOption {
	return func(m *InfoTypesMutation) {
		m.oldValue = func(context.Context) (*InfoTypes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InfoTypesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InfoTypesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InfoTypesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InfoTypesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InfoTypes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InfoTypesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InfoTypesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InfoTypes entity.
// If the InfoTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfoTypesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InfoTypesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InfoTypesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InfoTypesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InfoTypes entity.
// If the InfoTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfoTypesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InfoTypesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[infotypes.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InfoTypesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[infotypes.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InfoTypesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, infotypes.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *InfoTypesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InfoTypesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InfoTypes entity.
// If the InfoTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfoTypesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InfoTypesMutation) ResetName() {
	m.name = nil
}

// AddProductInfoIDs adds the "product_info" edge to the ProductInfo entity by ids.
func (m *InfoTypesMutation) AddProductInfoIDs(ids ...int) {
	if m.product_info == nil {
		m.product_info = make(map[int]struct{})
	}
	for i := range ids {
		m.product_info[ids[i]] = struct{}{}
	}
}

// ClearProductInfo clears the "product_info" edge to the ProductInfo entity.
func (m *InfoTypesMutation) ClearProductInfo() {
	m.clearedproduct_info = true
}

// ProductInfoCleared reports if the "product_info" edge to the ProductInfo entity was cleared.
func (m *InfoTypesMutation) ProductInfoCleared() bool {
	return m.clearedproduct_info
}

// RemoveProductInfoIDs removes the "product_info" edge to the ProductInfo entity by IDs.
func (m *InfoTypesMutation) RemoveProductInfoIDs(ids ...int) {
	if m.removedproduct_info == nil {
		m.removedproduct_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_info, ids[i])
		m.removedproduct_info[ids[i]] = struct{}{}
	}
}

// RemovedProductInfo returns the removed IDs of the "product_info" edge to the ProductInfo entity.
func (m *InfoTypesMutation) RemovedProductInfoIDs() (ids []int) {
	for id := range m.removedproduct_info {
		ids = append(ids, id)
	}
	return
}

// ProductInfoIDs returns the "product_info" edge IDs in the mutation.
func (m *InfoTypesMutation) ProductInfoIDs() (ids []int) {
	for id := range m.product_info {
		ids = append(ids, id)
	}
	return
}

// ResetProductInfo resets all changes to the "product_info" edge.
func (m *InfoTypesMutation) ResetProductInfo() {
	m.product_info = nil
	m.clearedproduct_info = false
	m.removedproduct_info = nil
}

// Where appends a list predicates to the InfoTypesMutation builder.
func (m *InfoTypesMutation) Where(ps ...predicate.InfoTypes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InfoTypesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InfoTypesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InfoTypes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InfoTypesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InfoTypesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InfoTypes).
func (m *InfoTypesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InfoTypesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, infotypes.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, infotypes.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, infotypes.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InfoTypesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case infotypes.FieldCreatedAt:
		return m.CreatedAt()
	case infotypes.FieldDeletedAt:
		return m.DeletedAt()
	case infotypes.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InfoTypesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case infotypes.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case infotypes.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case infotypes.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown InfoTypes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InfoTypesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case infotypes.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case infotypes.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case infotypes.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown InfoTypes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InfoTypesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InfoTypesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InfoTypesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InfoTypes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InfoTypesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(infotypes.FieldDeletedAt) {
		fields = append(fields, infotypes.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InfoTypesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InfoTypesMutation) ClearField(name string) error {
	switch name {
	case infotypes.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown InfoTypes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InfoTypesMutation) ResetField(name string) error {
	switch name {
	case infotypes.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case infotypes.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case infotypes.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown InfoTypes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InfoTypesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_info != nil {
		edges = append(edges, infotypes.EdgeProductInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InfoTypesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case infotypes.EdgeProductInfo:
		ids := make([]ent.Value, 0, len(m.product_info))
		for id := range m.product_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InfoTypesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_info != nil {
		edges = append(edges, infotypes.EdgeProductInfo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InfoTypesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case infotypes.EdgeProductInfo:
		ids := make([]ent.Value, 0, len(m.removedproduct_info))
		for id := range m.removedproduct_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InfoTypesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_info {
		edges = append(edges, infotypes.EdgeProductInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InfoTypesMutation) EdgeCleared(name string) bool {
	switch name {
	case infotypes.EdgeProductInfo:
		return m.clearedproduct_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InfoTypesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InfoTypes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InfoTypesMutation) ResetEdge(name string) error {
	switch name {
	case infotypes.EdgeProductInfo:
		m.ResetProductInfo()
		return nil
	}
	return fmt.Errorf("unknown InfoTypes edge %s", name)
}

// PriceTypeMutation represents an operation that mutates the PriceType nodes in the graph.
type PriceTypeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	clearedFields         map[string]struct{}
	product_prices        map[int]struct{}
	removedproduct_prices map[int]struct{}
	clearedproduct_prices bool
	done                  bool
	oldValue              func(context.Context) (*PriceType, error)
	predicates            []predicate.PriceType
}

var _ ent.Mutation = (*PriceTypeMutation)(nil)

// pricetypeOption allows management of the mutation configuration using functional options.
type pricetypeOption func(*PriceTypeMutation)

// newPriceTypeMutation creates new mutation for the PriceType entity.
func newPriceTypeMutation(c config, op Op, opts ...pricetypeOption) *PriceTypeMutation {
	m := &PriceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePriceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceTypeID sets the ID field of the mutation.
func withPriceTypeID(id int) pricetypeOption {
	return func(m *PriceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PriceType
		)
		m.oldValue = func(ctx context.Context) (*PriceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PriceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPriceType sets the old PriceType of the mutation.
func withPriceType(node *PriceType) pricetypeOption {
	return func(m *PriceTypeMutation) {
		m.oldValue = func(context.Context) (*PriceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PriceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PriceType entity.
// If the PriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PriceTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PriceTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PriceType entity.
// If the PriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PriceTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pricetype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PriceTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pricetype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PriceTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pricetype.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PriceTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PriceTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PriceType entity.
// If the PriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceTypeMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PriceTypeMutation) ResetName() {
	m.name = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrices entity by ids.
func (m *PriceTypeMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrices entity.
func (m *PriceTypeMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrices entity was cleared.
func (m *PriceTypeMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrices entity by IDs.
func (m *PriceTypeMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_prices, ids[i])
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrices entity.
func (m *PriceTypeMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *PriceTypeMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *PriceTypeMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// Where appends a list predicates to the PriceTypeMutation builder.
func (m *PriceTypeMutation) Where(ps ...predicate.PriceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PriceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PriceType).
func (m *PriceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, pricetype.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pricetype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, pricetype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pricetype.FieldCreatedAt:
		return m.CreatedAt()
	case pricetype.FieldDeletedAt:
		return m.DeletedAt()
	case pricetype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pricetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pricetype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pricetype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PriceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pricetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pricetype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pricetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PriceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PriceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pricetype.FieldDeletedAt) {
		fields = append(fields, pricetype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceTypeMutation) ClearField(name string) error {
	switch name {
	case pricetype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PriceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceTypeMutation) ResetField(name string) error {
	switch name {
	case pricetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pricetype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pricetype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PriceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_prices != nil {
		edges = append(edges, pricetype.EdgeProductPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pricetype.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_prices != nil {
		edges = append(edges, pricetype.EdgeProductPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pricetype.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_prices {
		edges = append(edges, pricetype.EdgeProductPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case pricetype.EdgeProductPrices:
		return m.clearedproduct_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PriceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceTypeMutation) ResetEdge(name string) error {
	switch name {
	case pricetype.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	}
	return fmt.Errorf("unknown PriceType edge %s", name)
}

// ProductHasFeatureMutation represents an operation that mutates the ProductHasFeature nodes in the graph.
type ProductHasFeatureMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	products        *int
	clearedproducts bool
	features        *int
	clearedfeatures bool
	done            bool
	oldValue        func(context.Context) (*ProductHasFeature, error)
	predicates      []predicate.ProductHasFeature
}

var _ ent.Mutation = (*ProductHasFeatureMutation)(nil)

// producthasfeatureOption allows management of the mutation configuration using functional options.
type producthasfeatureOption func(*ProductHasFeatureMutation)

// newProductHasFeatureMutation creates new mutation for the ProductHasFeature entity.
func newProductHasFeatureMutation(c config, op Op, opts ...producthasfeatureOption) *ProductHasFeatureMutation {
	m := &ProductHasFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeProductHasFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductHasFeatureID sets the ID field of the mutation.
func withProductHasFeatureID(id int) producthasfeatureOption {
	return func(m *ProductHasFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductHasFeature
		)
		m.oldValue = func(ctx context.Context) (*ProductHasFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductHasFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductHasFeature sets the old ProductHasFeature of the mutation.
func withProductHasFeature(node *ProductHasFeature) producthasfeatureOption {
	return func(m *ProductHasFeatureMutation) {
		m.oldValue = func(context.Context) (*ProductHasFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductHasFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductHasFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductHasFeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductHasFeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductHasFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductHasFeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductHasFeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductHasFeature entity.
// If the ProductHasFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasFeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductHasFeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductHasFeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductHasFeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductHasFeature entity.
// If the ProductHasFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasFeatureMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductHasFeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[producthasfeature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductHasFeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[producthasfeature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductHasFeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, producthasfeature.FieldDeletedAt)
}

// SetFeatureID sets the "feature_id" field.
func (m *ProductHasFeatureMutation) SetFeatureID(i int) {
	m.features = &i
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *ProductHasFeatureMutation) FeatureID() (r int, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the ProductHasFeature entity.
// If the ProductHasFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasFeatureMutation) OldFeatureID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *ProductHasFeatureMutation) ResetFeatureID() {
	m.features = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductHasFeatureMutation) SetProductID(i int) {
	m.products = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductHasFeatureMutation) ProductID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductHasFeature entity.
// If the ProductHasFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasFeatureMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductHasFeatureMutation) ClearProductID() {
	m.products = nil
	m.clearedFields[producthasfeature.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductHasFeatureMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[producthasfeature.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductHasFeatureMutation) ResetProductID() {
	m.products = nil
	delete(m.clearedFields, producthasfeature.FieldProductID)
}

// SetProductsID sets the "products" edge to the Products entity by id.
func (m *ProductHasFeatureMutation) SetProductsID(id int) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *ProductHasFeatureMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[producthasfeature.FieldProductID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *ProductHasFeatureMutation) ProductsCleared() bool {
	return m.ProductIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ProductHasFeatureMutation) ProductsID() (id int, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ProductHasFeatureMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductHasFeatureMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// SetFeaturesID sets the "features" edge to the Features entity by id.
func (m *ProductHasFeatureMutation) SetFeaturesID(id int) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Features entity.
func (m *ProductHasFeatureMutation) ClearFeatures() {
	m.clearedfeatures = true
	m.clearedFields[producthasfeature.FieldFeatureID] = struct{}{}
}

// FeaturesCleared reports if the "features" edge to the Features entity was cleared.
func (m *ProductHasFeatureMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *ProductHasFeatureMutation) FeaturesID() (id int, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *ProductHasFeatureMutation) FeaturesIDs() (ids []int) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *ProductHasFeatureMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// Where appends a list predicates to the ProductHasFeatureMutation builder.
func (m *ProductHasFeatureMutation) Where(ps ...predicate.ProductHasFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductHasFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductHasFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductHasFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductHasFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductHasFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductHasFeature).
func (m *ProductHasFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductHasFeatureMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, producthasfeature.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, producthasfeature.FieldDeletedAt)
	}
	if m.features != nil {
		fields = append(fields, producthasfeature.FieldFeatureID)
	}
	if m.products != nil {
		fields = append(fields, producthasfeature.FieldProductID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductHasFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producthasfeature.FieldCreatedAt:
		return m.CreatedAt()
	case producthasfeature.FieldDeletedAt:
		return m.DeletedAt()
	case producthasfeature.FieldFeatureID:
		return m.FeatureID()
	case producthasfeature.FieldProductID:
		return m.ProductID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductHasFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producthasfeature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case producthasfeature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case producthasfeature.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case producthasfeature.FieldProductID:
		return m.OldProductID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductHasFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producthasfeature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producthasfeature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case producthasfeature.FieldFeatureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case producthasfeature.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductHasFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductHasFeatureMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductHasFeatureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductHasFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductHasFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producthasfeature.FieldDeletedAt) {
		fields = append(fields, producthasfeature.FieldDeletedAt)
	}
	if m.FieldCleared(producthasfeature.FieldProductID) {
		fields = append(fields, producthasfeature.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductHasFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductHasFeatureMutation) ClearField(name string) error {
	switch name {
	case producthasfeature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case producthasfeature.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductHasFeatureMutation) ResetField(name string) error {
	switch name {
	case producthasfeature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producthasfeature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case producthasfeature.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case producthasfeature.FieldProductID:
		m.ResetProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductHasFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, producthasfeature.EdgeProducts)
	}
	if m.features != nil {
		edges = append(edges, producthasfeature.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductHasFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producthasfeature.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case producthasfeature.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductHasFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductHasFeatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductHasFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, producthasfeature.EdgeProducts)
	}
	if m.clearedfeatures {
		edges = append(edges, producthasfeature.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductHasFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case producthasfeature.EdgeProducts:
		return m.clearedproducts
	case producthasfeature.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductHasFeatureMutation) ClearEdge(name string) error {
	switch name {
	case producthasfeature.EdgeProducts:
		m.ClearProducts()
		return nil
	case producthasfeature.EdgeFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown ProductHasFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductHasFeatureMutation) ResetEdge(name string) error {
	switch name {
	case producthasfeature.EdgeProducts:
		m.ResetProducts()
		return nil
	case producthasfeature.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown ProductHasFeature edge %s", name)
}

// ProductHasImageMutation represents an operation that mutates the ProductHasImage nodes in the graph.
type ProductHasImageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	priority       *int
	addpriority    *int
	clearedFields  map[string]struct{}
	product        *int
	clearedproduct bool
	image          *int
	clearedimage   bool
	done           bool
	oldValue       func(context.Context) (*ProductHasImage, error)
	predicates     []predicate.ProductHasImage
}

var _ ent.Mutation = (*ProductHasImageMutation)(nil)

// producthasimageOption allows management of the mutation configuration using functional options.
type producthasimageOption func(*ProductHasImageMutation)

// newProductHasImageMutation creates new mutation for the ProductHasImage entity.
func newProductHasImageMutation(c config, op Op, opts ...producthasimageOption) *ProductHasImageMutation {
	m := &ProductHasImageMutation{
		config:        c,
		op:            op,
		typ:           TypeProductHasImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductHasImageID sets the ID field of the mutation.
func withProductHasImageID(id int) producthasimageOption {
	return func(m *ProductHasImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductHasImage
		)
		m.oldValue = func(ctx context.Context) (*ProductHasImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductHasImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductHasImage sets the old ProductHasImage of the mutation.
func withProductHasImage(node *ProductHasImage) producthasimageOption {
	return func(m *ProductHasImageMutation) {
		m.oldValue = func(context.Context) (*ProductHasImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductHasImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductHasImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductHasImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductHasImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductHasImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductHasImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductHasImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductHasImage entity.
// If the ProductHasImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductHasImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductHasImageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductHasImageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductHasImage entity.
// If the ProductHasImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasImageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductHasImageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[producthasimage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductHasImageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[producthasimage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductHasImageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, producthasimage.FieldDeletedAt)
}

// SetImageID sets the "image_id" field.
func (m *ProductHasImageMutation) SetImageID(i int) {
	m.image = &i
}

// ImageID returns the value of the "image_id" field in the mutation.
func (m *ProductHasImageMutation) ImageID() (r int, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImageID returns the old "image_id" field's value of the ProductHasImage entity.
// If the ProductHasImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasImageMutation) OldImageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageID: %w", err)
	}
	return oldValue.ImageID, nil
}

// ResetImageID resets all changes to the "image_id" field.
func (m *ProductHasImageMutation) ResetImageID() {
	m.image = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductHasImageMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductHasImageMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductHasImage entity.
// If the ProductHasImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasImageMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductHasImageMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[producthasimage.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductHasImageMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[producthasimage.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductHasImageMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, producthasimage.FieldProductID)
}

// SetPriority sets the "priority" field.
func (m *ProductHasImageMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProductHasImageMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ProductHasImage entity.
// If the ProductHasImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasImageMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ProductHasImageMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ProductHasImageMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProductHasImageMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// ClearProduct clears the "product" edge to the Products entity.
func (m *ProductHasImageMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[producthasimage.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Products entity was cleared.
func (m *ProductHasImageMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductHasImageMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductHasImageMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearImage clears the "image" edge to the Images entity.
func (m *ProductHasImageMutation) ClearImage() {
	m.clearedimage = true
	m.clearedFields[producthasimage.FieldImageID] = struct{}{}
}

// ImageCleared reports if the "image" edge to the Images entity was cleared.
func (m *ProductHasImageMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *ProductHasImageMutation) ImageIDs() (ids []int) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *ProductHasImageMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the ProductHasImageMutation builder.
func (m *ProductHasImageMutation) Where(ps ...predicate.ProductHasImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductHasImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductHasImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductHasImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductHasImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductHasImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductHasImage).
func (m *ProductHasImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductHasImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, producthasimage.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, producthasimage.FieldDeletedAt)
	}
	if m.image != nil {
		fields = append(fields, producthasimage.FieldImageID)
	}
	if m.product != nil {
		fields = append(fields, producthasimage.FieldProductID)
	}
	if m.priority != nil {
		fields = append(fields, producthasimage.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductHasImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producthasimage.FieldCreatedAt:
		return m.CreatedAt()
	case producthasimage.FieldDeletedAt:
		return m.DeletedAt()
	case producthasimage.FieldImageID:
		return m.ImageID()
	case producthasimage.FieldProductID:
		return m.ProductID()
	case producthasimage.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductHasImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producthasimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case producthasimage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case producthasimage.FieldImageID:
		return m.OldImageID(ctx)
	case producthasimage.FieldProductID:
		return m.OldProductID(ctx)
	case producthasimage.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown ProductHasImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producthasimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producthasimage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case producthasimage.FieldImageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageID(v)
		return nil
	case producthasimage.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case producthasimage.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductHasImageMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, producthasimage.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductHasImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case producthasimage.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case producthasimage.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductHasImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producthasimage.FieldDeletedAt) {
		fields = append(fields, producthasimage.FieldDeletedAt)
	}
	if m.FieldCleared(producthasimage.FieldProductID) {
		fields = append(fields, producthasimage.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductHasImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductHasImageMutation) ClearField(name string) error {
	switch name {
	case producthasimage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case producthasimage.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductHasImageMutation) ResetField(name string) error {
	switch name {
	case producthasimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producthasimage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case producthasimage.FieldImageID:
		m.ResetImageID()
		return nil
	case producthasimage.FieldProductID:
		m.ResetProductID()
		return nil
	case producthasimage.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductHasImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, producthasimage.EdgeProduct)
	}
	if m.image != nil {
		edges = append(edges, producthasimage.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductHasImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producthasimage.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case producthasimage.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductHasImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductHasImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductHasImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, producthasimage.EdgeProduct)
	}
	if m.clearedimage {
		edges = append(edges, producthasimage.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductHasImageMutation) EdgeCleared(name string) bool {
	switch name {
	case producthasimage.EdgeProduct:
		return m.clearedproduct
	case producthasimage.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductHasImageMutation) ClearEdge(name string) error {
	switch name {
	case producthasimage.EdgeProduct:
		m.ClearProduct()
		return nil
	case producthasimage.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductHasImageMutation) ResetEdge(name string) error {
	switch name {
	case producthasimage.EdgeProduct:
		m.ResetProduct()
		return nil
	case producthasimage.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown ProductHasImage edge %s", name)
}

// ProductHasInfoMutation represents an operation that mutates the ProductHasInfo nodes in the graph.
type ProductHasInfoMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	products            *int
	clearedproducts     bool
	product_info        *int
	clearedproduct_info bool
	done                bool
	oldValue            func(context.Context) (*ProductHasInfo, error)
	predicates          []predicate.ProductHasInfo
}

var _ ent.Mutation = (*ProductHasInfoMutation)(nil)

// producthasinfoOption allows management of the mutation configuration using functional options.
type producthasinfoOption func(*ProductHasInfoMutation)

// newProductHasInfoMutation creates new mutation for the ProductHasInfo entity.
func newProductHasInfoMutation(c config, op Op, opts ...producthasinfoOption) *ProductHasInfoMutation {
	m := &ProductHasInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeProductHasInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductHasInfoID sets the ID field of the mutation.
func withProductHasInfoID(id int) producthasinfoOption {
	return func(m *ProductHasInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductHasInfo
		)
		m.oldValue = func(ctx context.Context) (*ProductHasInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductHasInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductHasInfo sets the old ProductHasInfo of the mutation.
func withProductHasInfo(node *ProductHasInfo) producthasinfoOption {
	return func(m *ProductHasInfoMutation) {
		m.oldValue = func(context.Context) (*ProductHasInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductHasInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductHasInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductHasInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductHasInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductHasInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductHasInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductHasInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductHasInfo entity.
// If the ProductHasInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductHasInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductHasInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductHasInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductHasInfo entity.
// If the ProductHasInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasInfoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductHasInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[producthasinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductHasInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[producthasinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductHasInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, producthasinfo.FieldDeletedAt)
}

// SetProductID sets the "product_id" field.
func (m *ProductHasInfoMutation) SetProductID(i int) {
	m.products = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductHasInfoMutation) ProductID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductHasInfo entity.
// If the ProductHasInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasInfoMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductHasInfoMutation) ClearProductID() {
	m.products = nil
	m.clearedFields[producthasinfo.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductHasInfoMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[producthasinfo.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductHasInfoMutation) ResetProductID() {
	m.products = nil
	delete(m.clearedFields, producthasinfo.FieldProductID)
}

// SetProductInfoID sets the "product_info_id" field.
func (m *ProductHasInfoMutation) SetProductInfoID(i int) {
	m.product_info = &i
}

// ProductInfoID returns the value of the "product_info_id" field in the mutation.
func (m *ProductHasInfoMutation) ProductInfoID() (r int, exists bool) {
	v := m.product_info
	if v == nil {
		return
	}
	return *v, true
}

// OldProductInfoID returns the old "product_info_id" field's value of the ProductHasInfo entity.
// If the ProductHasInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasInfoMutation) OldProductInfoID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductInfoID: %w", err)
	}
	return oldValue.ProductInfoID, nil
}

// ClearProductInfoID clears the value of the "product_info_id" field.
func (m *ProductHasInfoMutation) ClearProductInfoID() {
	m.product_info = nil
	m.clearedFields[producthasinfo.FieldProductInfoID] = struct{}{}
}

// ProductInfoIDCleared returns if the "product_info_id" field was cleared in this mutation.
func (m *ProductHasInfoMutation) ProductInfoIDCleared() bool {
	_, ok := m.clearedFields[producthasinfo.FieldProductInfoID]
	return ok
}

// ResetProductInfoID resets all changes to the "product_info_id" field.
func (m *ProductHasInfoMutation) ResetProductInfoID() {
	m.product_info = nil
	delete(m.clearedFields, producthasinfo.FieldProductInfoID)
}

// SetProductsID sets the "products" edge to the Products entity by id.
func (m *ProductHasInfoMutation) SetProductsID(id int) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *ProductHasInfoMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[producthasinfo.FieldProductID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *ProductHasInfoMutation) ProductsCleared() bool {
	return m.ProductIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ProductHasInfoMutation) ProductsID() (id int, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ProductHasInfoMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductHasInfoMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// ClearProductInfo clears the "product_info" edge to the ProductInfo entity.
func (m *ProductHasInfoMutation) ClearProductInfo() {
	m.clearedproduct_info = true
	m.clearedFields[producthasinfo.FieldProductInfoID] = struct{}{}
}

// ProductInfoCleared reports if the "product_info" edge to the ProductInfo entity was cleared.
func (m *ProductHasInfoMutation) ProductInfoCleared() bool {
	return m.ProductInfoIDCleared() || m.clearedproduct_info
}

// ProductInfoIDs returns the "product_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductInfoID instead. It exists only for internal usage by the builders.
func (m *ProductHasInfoMutation) ProductInfoIDs() (ids []int) {
	if id := m.product_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductInfo resets all changes to the "product_info" edge.
func (m *ProductHasInfoMutation) ResetProductInfo() {
	m.product_info = nil
	m.clearedproduct_info = false
}

// Where appends a list predicates to the ProductHasInfoMutation builder.
func (m *ProductHasInfoMutation) Where(ps ...predicate.ProductHasInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductHasInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductHasInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductHasInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductHasInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductHasInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductHasInfo).
func (m *ProductHasInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductHasInfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, producthasinfo.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, producthasinfo.FieldDeletedAt)
	}
	if m.products != nil {
		fields = append(fields, producthasinfo.FieldProductID)
	}
	if m.product_info != nil {
		fields = append(fields, producthasinfo.FieldProductInfoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductHasInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producthasinfo.FieldCreatedAt:
		return m.CreatedAt()
	case producthasinfo.FieldDeletedAt:
		return m.DeletedAt()
	case producthasinfo.FieldProductID:
		return m.ProductID()
	case producthasinfo.FieldProductInfoID:
		return m.ProductInfoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductHasInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producthasinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case producthasinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case producthasinfo.FieldProductID:
		return m.OldProductID(ctx)
	case producthasinfo.FieldProductInfoID:
		return m.OldProductInfoID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductHasInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producthasinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producthasinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case producthasinfo.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case producthasinfo.FieldProductInfoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductInfoID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductHasInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductHasInfoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductHasInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductHasInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductHasInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producthasinfo.FieldDeletedAt) {
		fields = append(fields, producthasinfo.FieldDeletedAt)
	}
	if m.FieldCleared(producthasinfo.FieldProductID) {
		fields = append(fields, producthasinfo.FieldProductID)
	}
	if m.FieldCleared(producthasinfo.FieldProductInfoID) {
		fields = append(fields, producthasinfo.FieldProductInfoID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductHasInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductHasInfoMutation) ClearField(name string) error {
	switch name {
	case producthasinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case producthasinfo.FieldProductID:
		m.ClearProductID()
		return nil
	case producthasinfo.FieldProductInfoID:
		m.ClearProductInfoID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductHasInfoMutation) ResetField(name string) error {
	switch name {
	case producthasinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producthasinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case producthasinfo.FieldProductID:
		m.ResetProductID()
		return nil
	case producthasinfo.FieldProductInfoID:
		m.ResetProductInfoID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductHasInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, producthasinfo.EdgeProducts)
	}
	if m.product_info != nil {
		edges = append(edges, producthasinfo.EdgeProductInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductHasInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producthasinfo.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case producthasinfo.EdgeProductInfo:
		if id := m.product_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductHasInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductHasInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductHasInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, producthasinfo.EdgeProducts)
	}
	if m.clearedproduct_info {
		edges = append(edges, producthasinfo.EdgeProductInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductHasInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case producthasinfo.EdgeProducts:
		return m.clearedproducts
	case producthasinfo.EdgeProductInfo:
		return m.clearedproduct_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductHasInfoMutation) ClearEdge(name string) error {
	switch name {
	case producthasinfo.EdgeProducts:
		m.ClearProducts()
		return nil
	case producthasinfo.EdgeProductInfo:
		m.ClearProductInfo()
		return nil
	}
	return fmt.Errorf("unknown ProductHasInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductHasInfoMutation) ResetEdge(name string) error {
	switch name {
	case producthasinfo.EdgeProducts:
		m.ResetProducts()
		return nil
	case producthasinfo.EdgeProductInfo:
		m.ResetProductInfo()
		return nil
	}
	return fmt.Errorf("unknown ProductHasInfo edge %s", name)
}

// ProductHasProductReferenceMutation represents an operation that mutates the ProductHasProductReference nodes in the graph.
type ProductHasProductReferenceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	product_reference        *int
	clearedproduct_reference bool
	product                  *int
	clearedproduct           bool
	done                     bool
	oldValue                 func(context.Context) (*ProductHasProductReference, error)
	predicates               []predicate.ProductHasProductReference
}

var _ ent.Mutation = (*ProductHasProductReferenceMutation)(nil)

// producthasproductreferenceOption allows management of the mutation configuration using functional options.
type producthasproductreferenceOption func(*ProductHasProductReferenceMutation)

// newProductHasProductReferenceMutation creates new mutation for the ProductHasProductReference entity.
func newProductHasProductReferenceMutation(c config, op Op, opts ...producthasproductreferenceOption) *ProductHasProductReferenceMutation {
	m := &ProductHasProductReferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeProductHasProductReference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductHasProductReferenceID sets the ID field of the mutation.
func withProductHasProductReferenceID(id int) producthasproductreferenceOption {
	return func(m *ProductHasProductReferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductHasProductReference
		)
		m.oldValue = func(ctx context.Context) (*ProductHasProductReference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductHasProductReference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductHasProductReference sets the old ProductHasProductReference of the mutation.
func withProductHasProductReference(node *ProductHasProductReference) producthasproductreferenceOption {
	return func(m *ProductHasProductReferenceMutation) {
		m.oldValue = func(context.Context) (*ProductHasProductReference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductHasProductReferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductHasProductReferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductHasProductReferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductHasProductReferenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductHasProductReference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductHasProductReferenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductHasProductReferenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductHasProductReference entity.
// If the ProductHasProductReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasProductReferenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductHasProductReferenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductHasProductReferenceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductHasProductReferenceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductHasProductReference entity.
// If the ProductHasProductReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasProductReferenceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductHasProductReferenceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[producthasproductreference.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductHasProductReferenceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[producthasproductreference.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductHasProductReferenceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, producthasproductreference.FieldDeletedAt)
}

// SetProductReferenceID sets the "product_reference_id" field.
func (m *ProductHasProductReferenceMutation) SetProductReferenceID(i int) {
	m.product_reference = &i
}

// ProductReferenceID returns the value of the "product_reference_id" field in the mutation.
func (m *ProductHasProductReferenceMutation) ProductReferenceID() (r int, exists bool) {
	v := m.product_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldProductReferenceID returns the old "product_reference_id" field's value of the ProductHasProductReference entity.
// If the ProductHasProductReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasProductReferenceMutation) OldProductReferenceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductReferenceID: %w", err)
	}
	return oldValue.ProductReferenceID, nil
}

// ResetProductReferenceID resets all changes to the "product_reference_id" field.
func (m *ProductHasProductReferenceMutation) ResetProductReferenceID() {
	m.product_reference = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductHasProductReferenceMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductHasProductReferenceMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductHasProductReference entity.
// If the ProductHasProductReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductHasProductReferenceMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductHasProductReferenceMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[producthasproductreference.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductHasProductReferenceMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[producthasproductreference.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductHasProductReferenceMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, producthasproductreference.FieldProductID)
}

// ClearProductReference clears the "product_reference" edge to the ProductReferences entity.
func (m *ProductHasProductReferenceMutation) ClearProductReference() {
	m.clearedproduct_reference = true
	m.clearedFields[producthasproductreference.FieldProductReferenceID] = struct{}{}
}

// ProductReferenceCleared reports if the "product_reference" edge to the ProductReferences entity was cleared.
func (m *ProductHasProductReferenceMutation) ProductReferenceCleared() bool {
	return m.clearedproduct_reference
}

// ProductReferenceIDs returns the "product_reference" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductReferenceID instead. It exists only for internal usage by the builders.
func (m *ProductHasProductReferenceMutation) ProductReferenceIDs() (ids []int) {
	if id := m.product_reference; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductReference resets all changes to the "product_reference" edge.
func (m *ProductHasProductReferenceMutation) ResetProductReference() {
	m.product_reference = nil
	m.clearedproduct_reference = false
}

// ClearProduct clears the "product" edge to the Products entity.
func (m *ProductHasProductReferenceMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[producthasproductreference.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Products entity was cleared.
func (m *ProductHasProductReferenceMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductHasProductReferenceMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductHasProductReferenceMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ProductHasProductReferenceMutation builder.
func (m *ProductHasProductReferenceMutation) Where(ps ...predicate.ProductHasProductReference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductHasProductReferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductHasProductReferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductHasProductReference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductHasProductReferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductHasProductReferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductHasProductReference).
func (m *ProductHasProductReferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductHasProductReferenceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, producthasproductreference.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, producthasproductreference.FieldDeletedAt)
	}
	if m.product_reference != nil {
		fields = append(fields, producthasproductreference.FieldProductReferenceID)
	}
	if m.product != nil {
		fields = append(fields, producthasproductreference.FieldProductID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductHasProductReferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producthasproductreference.FieldCreatedAt:
		return m.CreatedAt()
	case producthasproductreference.FieldDeletedAt:
		return m.DeletedAt()
	case producthasproductreference.FieldProductReferenceID:
		return m.ProductReferenceID()
	case producthasproductreference.FieldProductID:
		return m.ProductID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductHasProductReferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producthasproductreference.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case producthasproductreference.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case producthasproductreference.FieldProductReferenceID:
		return m.OldProductReferenceID(ctx)
	case producthasproductreference.FieldProductID:
		return m.OldProductID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductHasProductReference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasProductReferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producthasproductreference.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producthasproductreference.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case producthasproductreference.FieldProductReferenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductReferenceID(v)
		return nil
	case producthasproductreference.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductHasProductReference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductHasProductReferenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductHasProductReferenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductHasProductReferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductHasProductReference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductHasProductReferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producthasproductreference.FieldDeletedAt) {
		fields = append(fields, producthasproductreference.FieldDeletedAt)
	}
	if m.FieldCleared(producthasproductreference.FieldProductID) {
		fields = append(fields, producthasproductreference.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductHasProductReferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductHasProductReferenceMutation) ClearField(name string) error {
	switch name {
	case producthasproductreference.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case producthasproductreference.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasProductReference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductHasProductReferenceMutation) ResetField(name string) error {
	switch name {
	case producthasproductreference.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producthasproductreference.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case producthasproductreference.FieldProductReferenceID:
		m.ResetProductReferenceID()
		return nil
	case producthasproductreference.FieldProductID:
		m.ResetProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductHasProductReference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductHasProductReferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product_reference != nil {
		edges = append(edges, producthasproductreference.EdgeProductReference)
	}
	if m.product != nil {
		edges = append(edges, producthasproductreference.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductHasProductReferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producthasproductreference.EdgeProductReference:
		if id := m.product_reference; id != nil {
			return []ent.Value{*id}
		}
	case producthasproductreference.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductHasProductReferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductHasProductReferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductHasProductReferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct_reference {
		edges = append(edges, producthasproductreference.EdgeProductReference)
	}
	if m.clearedproduct {
		edges = append(edges, producthasproductreference.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductHasProductReferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case producthasproductreference.EdgeProductReference:
		return m.clearedproduct_reference
	case producthasproductreference.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductHasProductReferenceMutation) ClearEdge(name string) error {
	switch name {
	case producthasproductreference.EdgeProductReference:
		m.ClearProductReference()
		return nil
	case producthasproductreference.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductHasProductReference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductHasProductReferenceMutation) ResetEdge(name string) error {
	switch name {
	case producthasproductreference.EdgeProductReference:
		m.ResetProductReference()
		return nil
	case producthasproductreference.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductHasProductReference edge %s", name)
}

// ProductInfoMutation represents an operation that mutates the ProductInfo nodes in the graph.
type ProductInfoMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	deleted_at                   *time.Time
	value                        *string
	clearedFields                map[string]struct{}
	info_type                    *int
	clearedinfo_type             bool
	features_values_types        *int
	clearedfeatures_values_types bool
	product_has_info             map[int]struct{}
	removedproduct_has_info      map[int]struct{}
	clearedproduct_has_info      bool
	done                         bool
	oldValue                     func(context.Context) (*ProductInfo, error)
	predicates                   []predicate.ProductInfo
}

var _ ent.Mutation = (*ProductInfoMutation)(nil)

// productinfoOption allows management of the mutation configuration using functional options.
type productinfoOption func(*ProductInfoMutation)

// newProductInfoMutation creates new mutation for the ProductInfo entity.
func newProductInfoMutation(c config, op Op, opts ...productinfoOption) *ProductInfoMutation {
	m := &ProductInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeProductInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductInfoID sets the ID field of the mutation.
func withProductInfoID(id int) productinfoOption {
	return func(m *ProductInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductInfo
		)
		m.oldValue = func(ctx context.Context) (*ProductInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductInfo sets the old ProductInfo of the mutation.
func withProductInfo(node *ProductInfo) productinfoOption {
	return func(m *ProductInfoMutation) {
		m.oldValue = func(context.Context) (*ProductInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[productinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, productinfo.FieldDeletedAt)
}

// SetInfoTypesID sets the "info_types_id" field.
func (m *ProductInfoMutation) SetInfoTypesID(i int) {
	m.info_type = &i
}

// InfoTypesID returns the value of the "info_types_id" field in the mutation.
func (m *ProductInfoMutation) InfoTypesID() (r int, exists bool) {
	v := m.info_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInfoTypesID returns the old "info_types_id" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldInfoTypesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfoTypesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfoTypesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfoTypesID: %w", err)
	}
	return oldValue.InfoTypesID, nil
}

// ClearInfoTypesID clears the value of the "info_types_id" field.
func (m *ProductInfoMutation) ClearInfoTypesID() {
	m.info_type = nil
	m.clearedFields[productinfo.FieldInfoTypesID] = struct{}{}
}

// InfoTypesIDCleared returns if the "info_types_id" field was cleared in this mutation.
func (m *ProductInfoMutation) InfoTypesIDCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldInfoTypesID]
	return ok
}

// ResetInfoTypesID resets all changes to the "info_types_id" field.
func (m *ProductInfoMutation) ResetInfoTypesID() {
	m.info_type = nil
	delete(m.clearedFields, productinfo.FieldInfoTypesID)
}

// SetFeaturesValuesTypesID sets the "features_values_types_id" field.
func (m *ProductInfoMutation) SetFeaturesValuesTypesID(i int) {
	m.features_values_types = &i
}

// FeaturesValuesTypesID returns the value of the "features_values_types_id" field in the mutation.
func (m *ProductInfoMutation) FeaturesValuesTypesID() (r int, exists bool) {
	v := m.features_values_types
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturesValuesTypesID returns the old "features_values_types_id" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldFeaturesValuesTypesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturesValuesTypesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturesValuesTypesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturesValuesTypesID: %w", err)
	}
	return oldValue.FeaturesValuesTypesID, nil
}

// ClearFeaturesValuesTypesID clears the value of the "features_values_types_id" field.
func (m *ProductInfoMutation) ClearFeaturesValuesTypesID() {
	m.features_values_types = nil
	m.clearedFields[productinfo.FieldFeaturesValuesTypesID] = struct{}{}
}

// FeaturesValuesTypesIDCleared returns if the "features_values_types_id" field was cleared in this mutation.
func (m *ProductInfoMutation) FeaturesValuesTypesIDCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldFeaturesValuesTypesID]
	return ok
}

// ResetFeaturesValuesTypesID resets all changes to the "features_values_types_id" field.
func (m *ProductInfoMutation) ResetFeaturesValuesTypesID() {
	m.features_values_types = nil
	delete(m.clearedFields, productinfo.FieldFeaturesValuesTypesID)
}

// SetValue sets the "value" field.
func (m *ProductInfoMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ProductInfoMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ProductInfoMutation) ResetValue() {
	m.value = nil
}

// SetInfoTypeID sets the "info_type" edge to the InfoTypes entity by id.
func (m *ProductInfoMutation) SetInfoTypeID(id int) {
	m.info_type = &id
}

// ClearInfoType clears the "info_type" edge to the InfoTypes entity.
func (m *ProductInfoMutation) ClearInfoType() {
	m.clearedinfo_type = true
	m.clearedFields[productinfo.FieldInfoTypesID] = struct{}{}
}

// InfoTypeCleared reports if the "info_type" edge to the InfoTypes entity was cleared.
func (m *ProductInfoMutation) InfoTypeCleared() bool {
	return m.InfoTypesIDCleared() || m.clearedinfo_type
}

// InfoTypeID returns the "info_type" edge ID in the mutation.
func (m *ProductInfoMutation) InfoTypeID() (id int, exists bool) {
	if m.info_type != nil {
		return *m.info_type, true
	}
	return
}

// InfoTypeIDs returns the "info_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InfoTypeID instead. It exists only for internal usage by the builders.
func (m *ProductInfoMutation) InfoTypeIDs() (ids []int) {
	if id := m.info_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInfoType resets all changes to the "info_type" edge.
func (m *ProductInfoMutation) ResetInfoType() {
	m.info_type = nil
	m.clearedinfo_type = false
}

// ClearFeaturesValuesTypes clears the "features_values_types" edge to the FeaturesValuesTypes entity.
func (m *ProductInfoMutation) ClearFeaturesValuesTypes() {
	m.clearedfeatures_values_types = true
	m.clearedFields[productinfo.FieldFeaturesValuesTypesID] = struct{}{}
}

// FeaturesValuesTypesCleared reports if the "features_values_types" edge to the FeaturesValuesTypes entity was cleared.
func (m *ProductInfoMutation) FeaturesValuesTypesCleared() bool {
	return m.FeaturesValuesTypesIDCleared() || m.clearedfeatures_values_types
}

// FeaturesValuesTypesIDs returns the "features_values_types" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesValuesTypesID instead. It exists only for internal usage by the builders.
func (m *ProductInfoMutation) FeaturesValuesTypesIDs() (ids []int) {
	if id := m.features_values_types; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeaturesValuesTypes resets all changes to the "features_values_types" edge.
func (m *ProductInfoMutation) ResetFeaturesValuesTypes() {
	m.features_values_types = nil
	m.clearedfeatures_values_types = false
}

// AddProductHasInfoIDs adds the "product_has_info" edge to the ProductHasInfo entity by ids.
func (m *ProductInfoMutation) AddProductHasInfoIDs(ids ...int) {
	if m.product_has_info == nil {
		m.product_has_info = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_info[ids[i]] = struct{}{}
	}
}

// ClearProductHasInfo clears the "product_has_info" edge to the ProductHasInfo entity.
func (m *ProductInfoMutation) ClearProductHasInfo() {
	m.clearedproduct_has_info = true
}

// ProductHasInfoCleared reports if the "product_has_info" edge to the ProductHasInfo entity was cleared.
func (m *ProductInfoMutation) ProductHasInfoCleared() bool {
	return m.clearedproduct_has_info
}

// RemoveProductHasInfoIDs removes the "product_has_info" edge to the ProductHasInfo entity by IDs.
func (m *ProductInfoMutation) RemoveProductHasInfoIDs(ids ...int) {
	if m.removedproduct_has_info == nil {
		m.removedproduct_has_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_info, ids[i])
		m.removedproduct_has_info[ids[i]] = struct{}{}
	}
}

// RemovedProductHasInfo returns the removed IDs of the "product_has_info" edge to the ProductHasInfo entity.
func (m *ProductInfoMutation) RemovedProductHasInfoIDs() (ids []int) {
	for id := range m.removedproduct_has_info {
		ids = append(ids, id)
	}
	return
}

// ProductHasInfoIDs returns the "product_has_info" edge IDs in the mutation.
func (m *ProductInfoMutation) ProductHasInfoIDs() (ids []int) {
	for id := range m.product_has_info {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasInfo resets all changes to the "product_has_info" edge.
func (m *ProductInfoMutation) ResetProductHasInfo() {
	m.product_has_info = nil
	m.clearedproduct_has_info = false
	m.removedproduct_has_info = nil
}

// Where appends a list predicates to the ProductInfoMutation builder.
func (m *ProductInfoMutation) Where(ps ...predicate.ProductInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductInfo).
func (m *ProductInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductInfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productinfo.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productinfo.FieldDeletedAt)
	}
	if m.info_type != nil {
		fields = append(fields, productinfo.FieldInfoTypesID)
	}
	if m.features_values_types != nil {
		fields = append(fields, productinfo.FieldFeaturesValuesTypesID)
	}
	if m.value != nil {
		fields = append(fields, productinfo.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productinfo.FieldCreatedAt:
		return m.CreatedAt()
	case productinfo.FieldDeletedAt:
		return m.DeletedAt()
	case productinfo.FieldInfoTypesID:
		return m.InfoTypesID()
	case productinfo.FieldFeaturesValuesTypesID:
		return m.FeaturesValuesTypesID()
	case productinfo.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productinfo.FieldInfoTypesID:
		return m.OldInfoTypesID(ctx)
	case productinfo.FieldFeaturesValuesTypesID:
		return m.OldFeaturesValuesTypesID(ctx)
	case productinfo.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown ProductInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productinfo.FieldInfoTypesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfoTypesID(v)
		return nil
	case productinfo.FieldFeaturesValuesTypesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturesValuesTypesID(v)
		return nil
	case productinfo.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductInfoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productinfo.FieldDeletedAt) {
		fields = append(fields, productinfo.FieldDeletedAt)
	}
	if m.FieldCleared(productinfo.FieldInfoTypesID) {
		fields = append(fields, productinfo.FieldInfoTypesID)
	}
	if m.FieldCleared(productinfo.FieldFeaturesValuesTypesID) {
		fields = append(fields, productinfo.FieldFeaturesValuesTypesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductInfoMutation) ClearField(name string) error {
	switch name {
	case productinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case productinfo.FieldInfoTypesID:
		m.ClearInfoTypesID()
		return nil
	case productinfo.FieldFeaturesValuesTypesID:
		m.ClearFeaturesValuesTypesID()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductInfoMutation) ResetField(name string) error {
	switch name {
	case productinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productinfo.FieldInfoTypesID:
		m.ResetInfoTypesID()
		return nil
	case productinfo.FieldFeaturesValuesTypesID:
		m.ResetFeaturesValuesTypesID()
		return nil
	case productinfo.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.info_type != nil {
		edges = append(edges, productinfo.EdgeInfoType)
	}
	if m.features_values_types != nil {
		edges = append(edges, productinfo.EdgeFeaturesValuesTypes)
	}
	if m.product_has_info != nil {
		edges = append(edges, productinfo.EdgeProductHasInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeInfoType:
		if id := m.info_type; id != nil {
			return []ent.Value{*id}
		}
	case productinfo.EdgeFeaturesValuesTypes:
		if id := m.features_values_types; id != nil {
			return []ent.Value{*id}
		}
	case productinfo.EdgeProductHasInfo:
		ids := make([]ent.Value, 0, len(m.product_has_info))
		for id := range m.product_has_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproduct_has_info != nil {
		edges = append(edges, productinfo.EdgeProductHasInfo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeProductHasInfo:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_info))
		for id := range m.removedproduct_has_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedinfo_type {
		edges = append(edges, productinfo.EdgeInfoType)
	}
	if m.clearedfeatures_values_types {
		edges = append(edges, productinfo.EdgeFeaturesValuesTypes)
	}
	if m.clearedproduct_has_info {
		edges = append(edges, productinfo.EdgeProductHasInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case productinfo.EdgeInfoType:
		return m.clearedinfo_type
	case productinfo.EdgeFeaturesValuesTypes:
		return m.clearedfeatures_values_types
	case productinfo.EdgeProductHasInfo:
		return m.clearedproduct_has_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductInfoMutation) ClearEdge(name string) error {
	switch name {
	case productinfo.EdgeInfoType:
		m.ClearInfoType()
		return nil
	case productinfo.EdgeFeaturesValuesTypes:
		m.ClearFeaturesValuesTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductInfoMutation) ResetEdge(name string) error {
	switch name {
	case productinfo.EdgeInfoType:
		m.ResetInfoType()
		return nil
	case productinfo.EdgeFeaturesValuesTypes:
		m.ResetFeaturesValuesTypes()
		return nil
	case productinfo.EdgeProductHasInfo:
		m.ResetProductHasInfo()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo edge %s", name)
}

// ProductPricesMutation represents an operation that mutates the ProductPrices nodes in the graph.
type ProductPricesMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	deleted_at        *time.Time
	default_value     *float64
	adddefault_value  *float64
	min_value         *float64
	addmin_value      *float64
	clearedFields     map[string]struct{}
	product           *int
	clearedproduct    bool
	price_type        *int
	clearedprice_type bool
	done              bool
	oldValue          func(context.Context) (*ProductPrices, error)
	predicates        []predicate.ProductPrices
}

var _ ent.Mutation = (*ProductPricesMutation)(nil)

// productpricesOption allows management of the mutation configuration using functional options.
type productpricesOption func(*ProductPricesMutation)

// newProductPricesMutation creates new mutation for the ProductPrices entity.
func newProductPricesMutation(c config, op Op, opts ...productpricesOption) *ProductPricesMutation {
	m := &ProductPricesMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPrices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPricesID sets the ID field of the mutation.
func withProductPricesID(id int) productpricesOption {
	return func(m *ProductPricesMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPrices
		)
		m.oldValue = func(ctx context.Context) (*ProductPrices, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPrices.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPrices sets the old ProductPrices of the mutation.
func withProductPrices(node *ProductPrices) productpricesOption {
	return func(m *ProductPricesMutation) {
		m.oldValue = func(context.Context) (*ProductPrices, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPricesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPricesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPricesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductPricesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductPrices.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductPricesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductPricesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductPricesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductPricesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductPricesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductPricesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[productprices.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductPricesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[productprices.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductPricesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, productprices.FieldDeletedAt)
}

// SetPriceTypeID sets the "price_type_id" field.
func (m *ProductPricesMutation) SetPriceTypeID(i int) {
	m.price_type = &i
}

// PriceTypeID returns the value of the "price_type_id" field in the mutation.
func (m *ProductPricesMutation) PriceTypeID() (r int, exists bool) {
	v := m.price_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceTypeID returns the old "price_type_id" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldPriceTypeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceTypeID: %w", err)
	}
	return oldValue.PriceTypeID, nil
}

// ResetPriceTypeID resets all changes to the "price_type_id" field.
func (m *ProductPricesMutation) ResetPriceTypeID() {
	m.price_type = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductPricesMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductPricesMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductPricesMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[productprices.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductPricesMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productprices.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductPricesMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, productprices.FieldProductID)
}

// SetDefaultValue sets the "default_value" field.
func (m *ProductPricesMutation) SetDefaultValue(f float64) {
	m.default_value = &f
	m.adddefault_value = nil
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *ProductPricesMutation) DefaultValue() (r float64, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldDefaultValue(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// AddDefaultValue adds f to the "default_value" field.
func (m *ProductPricesMutation) AddDefaultValue(f float64) {
	if m.adddefault_value != nil {
		*m.adddefault_value += f
	} else {
		m.adddefault_value = &f
	}
}

// AddedDefaultValue returns the value that was added to the "default_value" field in this mutation.
func (m *ProductPricesMutation) AddedDefaultValue() (r float64, exists bool) {
	v := m.adddefault_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *ProductPricesMutation) ResetDefaultValue() {
	m.default_value = nil
	m.adddefault_value = nil
}

// SetMinValue sets the "min_value" field.
func (m *ProductPricesMutation) SetMinValue(f float64) {
	m.min_value = &f
	m.addmin_value = nil
}

// MinValue returns the value of the "min_value" field in the mutation.
func (m *ProductPricesMutation) MinValue() (r float64, exists bool) {
	v := m.min_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMinValue returns the old "min_value" field's value of the ProductPrices entity.
// If the ProductPrices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricesMutation) OldMinValue(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinValue: %w", err)
	}
	return oldValue.MinValue, nil
}

// AddMinValue adds f to the "min_value" field.
func (m *ProductPricesMutation) AddMinValue(f float64) {
	if m.addmin_value != nil {
		*m.addmin_value += f
	} else {
		m.addmin_value = &f
	}
}

// AddedMinValue returns the value that was added to the "min_value" field in this mutation.
func (m *ProductPricesMutation) AddedMinValue() (r float64, exists bool) {
	v := m.addmin_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinValue clears the value of the "min_value" field.
func (m *ProductPricesMutation) ClearMinValue() {
	m.min_value = nil
	m.addmin_value = nil
	m.clearedFields[productprices.FieldMinValue] = struct{}{}
}

// MinValueCleared returns if the "min_value" field was cleared in this mutation.
func (m *ProductPricesMutation) MinValueCleared() bool {
	_, ok := m.clearedFields[productprices.FieldMinValue]
	return ok
}

// ResetMinValue resets all changes to the "min_value" field.
func (m *ProductPricesMutation) ResetMinValue() {
	m.min_value = nil
	m.addmin_value = nil
	delete(m.clearedFields, productprices.FieldMinValue)
}

// ClearProduct clears the "product" edge to the Products entity.
func (m *ProductPricesMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productprices.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Products entity was cleared.
func (m *ProductPricesMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductPricesMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductPricesMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearPriceType clears the "price_type" edge to the PriceType entity.
func (m *ProductPricesMutation) ClearPriceType() {
	m.clearedprice_type = true
	m.clearedFields[productprices.FieldPriceTypeID] = struct{}{}
}

// PriceTypeCleared reports if the "price_type" edge to the PriceType entity was cleared.
func (m *ProductPricesMutation) PriceTypeCleared() bool {
	return m.clearedprice_type
}

// PriceTypeIDs returns the "price_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PriceTypeID instead. It exists only for internal usage by the builders.
func (m *ProductPricesMutation) PriceTypeIDs() (ids []int) {
	if id := m.price_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPriceType resets all changes to the "price_type" edge.
func (m *ProductPricesMutation) ResetPriceType() {
	m.price_type = nil
	m.clearedprice_type = false
}

// Where appends a list predicates to the ProductPricesMutation builder.
func (m *ProductPricesMutation) Where(ps ...predicate.ProductPrices) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductPricesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductPricesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductPrices, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductPricesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductPricesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductPrices).
func (m *ProductPricesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPricesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, productprices.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productprices.FieldDeletedAt)
	}
	if m.price_type != nil {
		fields = append(fields, productprices.FieldPriceTypeID)
	}
	if m.product != nil {
		fields = append(fields, productprices.FieldProductID)
	}
	if m.default_value != nil {
		fields = append(fields, productprices.FieldDefaultValue)
	}
	if m.min_value != nil {
		fields = append(fields, productprices.FieldMinValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPricesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productprices.FieldCreatedAt:
		return m.CreatedAt()
	case productprices.FieldDeletedAt:
		return m.DeletedAt()
	case productprices.FieldPriceTypeID:
		return m.PriceTypeID()
	case productprices.FieldProductID:
		return m.ProductID()
	case productprices.FieldDefaultValue:
		return m.DefaultValue()
	case productprices.FieldMinValue:
		return m.MinValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPricesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productprices.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productprices.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productprices.FieldPriceTypeID:
		return m.OldPriceTypeID(ctx)
	case productprices.FieldProductID:
		return m.OldProductID(ctx)
	case productprices.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case productprices.FieldMinValue:
		return m.OldMinValue(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPrices field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPricesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productprices.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productprices.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productprices.FieldPriceTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceTypeID(v)
		return nil
	case productprices.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productprices.FieldDefaultValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case productprices.FieldMinValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinValue(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrices field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPricesMutation) AddedFields() []string {
	var fields []string
	if m.adddefault_value != nil {
		fields = append(fields, productprices.FieldDefaultValue)
	}
	if m.addmin_value != nil {
		fields = append(fields, productprices.FieldMinValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPricesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productprices.FieldDefaultValue:
		return m.AddedDefaultValue()
	case productprices.FieldMinValue:
		return m.AddedMinValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPricesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productprices.FieldDefaultValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultValue(v)
		return nil
	case productprices.FieldMinValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinValue(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrices numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPricesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productprices.FieldDeletedAt) {
		fields = append(fields, productprices.FieldDeletedAt)
	}
	if m.FieldCleared(productprices.FieldProductID) {
		fields = append(fields, productprices.FieldProductID)
	}
	if m.FieldCleared(productprices.FieldMinValue) {
		fields = append(fields, productprices.FieldMinValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPricesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPricesMutation) ClearField(name string) error {
	switch name {
	case productprices.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case productprices.FieldProductID:
		m.ClearProductID()
		return nil
	case productprices.FieldMinValue:
		m.ClearMinValue()
		return nil
	}
	return fmt.Errorf("unknown ProductPrices nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPricesMutation) ResetField(name string) error {
	switch name {
	case productprices.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productprices.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productprices.FieldPriceTypeID:
		m.ResetPriceTypeID()
		return nil
	case productprices.FieldProductID:
		m.ResetProductID()
		return nil
	case productprices.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case productprices.FieldMinValue:
		m.ResetMinValue()
		return nil
	}
	return fmt.Errorf("unknown ProductPrices field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPricesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, productprices.EdgeProduct)
	}
	if m.price_type != nil {
		edges = append(edges, productprices.EdgePriceType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPricesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productprices.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productprices.EdgePriceType:
		if id := m.price_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPricesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPricesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPricesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, productprices.EdgeProduct)
	}
	if m.clearedprice_type {
		edges = append(edges, productprices.EdgePriceType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPricesMutation) EdgeCleared(name string) bool {
	switch name {
	case productprices.EdgeProduct:
		return m.clearedproduct
	case productprices.EdgePriceType:
		return m.clearedprice_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPricesMutation) ClearEdge(name string) error {
	switch name {
	case productprices.EdgeProduct:
		m.ClearProduct()
		return nil
	case productprices.EdgePriceType:
		m.ClearPriceType()
		return nil
	}
	return fmt.Errorf("unknown ProductPrices unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPricesMutation) ResetEdge(name string) error {
	switch name {
	case productprices.EdgeProduct:
		m.ResetProduct()
		return nil
	case productprices.EdgePriceType:
		m.ResetPriceType()
		return nil
	}
	return fmt.Errorf("unknown ProductPrices edge %s", name)
}

// ProductReferencesMutation represents an operation that mutates the ProductReferences nodes in the graph.
type ProductReferencesMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	created_at                           *time.Time
	deleted_at                           *time.Time
	value                                *string
	clearedFields                        map[string]struct{}
	reference_sources                    *int
	clearedreference_sources             bool
	products                             map[int]struct{}
	removedproducts                      map[int]struct{}
	clearedproducts                      bool
	product_has_product_reference        map[int]struct{}
	removedproduct_has_product_reference map[int]struct{}
	clearedproduct_has_product_reference bool
	done                                 bool
	oldValue                             func(context.Context) (*ProductReferences, error)
	predicates                           []predicate.ProductReferences
}

var _ ent.Mutation = (*ProductReferencesMutation)(nil)

// productreferencesOption allows management of the mutation configuration using functional options.
type productreferencesOption func(*ProductReferencesMutation)

// newProductReferencesMutation creates new mutation for the ProductReferences entity.
func newProductReferencesMutation(c config, op Op, opts ...productreferencesOption) *ProductReferencesMutation {
	m := &ProductReferencesMutation{
		config:        c,
		op:            op,
		typ:           TypeProductReferences,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductReferencesID sets the ID field of the mutation.
func withProductReferencesID(id int) productreferencesOption {
	return func(m *ProductReferencesMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductReferences
		)
		m.oldValue = func(ctx context.Context) (*ProductReferences, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductReferences.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductReferences sets the old ProductReferences of the mutation.
func withProductReferences(node *ProductReferences) productreferencesOption {
	return func(m *ProductReferencesMutation) {
		m.oldValue = func(context.Context) (*ProductReferences, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductReferencesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductReferencesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductReferencesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductReferencesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductReferences.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductReferencesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductReferencesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductReferences entity.
// If the ProductReferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReferencesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductReferencesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductReferencesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductReferencesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductReferences entity.
// If the ProductReferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReferencesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductReferencesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[productreferences.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductReferencesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[productreferences.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductReferencesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, productreferences.FieldDeletedAt)
}

// SetReferenceSourceID sets the "reference_source_id" field.
func (m *ProductReferencesMutation) SetReferenceSourceID(i int) {
	m.reference_sources = &i
}

// ReferenceSourceID returns the value of the "reference_source_id" field in the mutation.
func (m *ProductReferencesMutation) ReferenceSourceID() (r int, exists bool) {
	v := m.reference_sources
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceSourceID returns the old "reference_source_id" field's value of the ProductReferences entity.
// If the ProductReferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReferencesMutation) OldReferenceSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceSourceID: %w", err)
	}
	return oldValue.ReferenceSourceID, nil
}

// ClearReferenceSourceID clears the value of the "reference_source_id" field.
func (m *ProductReferencesMutation) ClearReferenceSourceID() {
	m.reference_sources = nil
	m.clearedFields[productreferences.FieldReferenceSourceID] = struct{}{}
}

// ReferenceSourceIDCleared returns if the "reference_source_id" field was cleared in this mutation.
func (m *ProductReferencesMutation) ReferenceSourceIDCleared() bool {
	_, ok := m.clearedFields[productreferences.FieldReferenceSourceID]
	return ok
}

// ResetReferenceSourceID resets all changes to the "reference_source_id" field.
func (m *ProductReferencesMutation) ResetReferenceSourceID() {
	m.reference_sources = nil
	delete(m.clearedFields, productreferences.FieldReferenceSourceID)
}

// SetValue sets the "value" field.
func (m *ProductReferencesMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ProductReferencesMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ProductReferences entity.
// If the ProductReferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReferencesMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ProductReferencesMutation) ResetValue() {
	m.value = nil
}

// SetReferenceSourcesID sets the "reference_sources" edge to the ReferenceSources entity by id.
func (m *ProductReferencesMutation) SetReferenceSourcesID(id int) {
	m.reference_sources = &id
}

// ClearReferenceSources clears the "reference_sources" edge to the ReferenceSources entity.
func (m *ProductReferencesMutation) ClearReferenceSources() {
	m.clearedreference_sources = true
	m.clearedFields[productreferences.FieldReferenceSourceID] = struct{}{}
}

// ReferenceSourcesCleared reports if the "reference_sources" edge to the ReferenceSources entity was cleared.
func (m *ProductReferencesMutation) ReferenceSourcesCleared() bool {
	return m.ReferenceSourceIDCleared() || m.clearedreference_sources
}

// ReferenceSourcesID returns the "reference_sources" edge ID in the mutation.
func (m *ProductReferencesMutation) ReferenceSourcesID() (id int, exists bool) {
	if m.reference_sources != nil {
		return *m.reference_sources, true
	}
	return
}

// ReferenceSourcesIDs returns the "reference_sources" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferenceSourcesID instead. It exists only for internal usage by the builders.
func (m *ProductReferencesMutation) ReferenceSourcesIDs() (ids []int) {
	if id := m.reference_sources; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferenceSources resets all changes to the "reference_sources" edge.
func (m *ProductReferencesMutation) ResetReferenceSources() {
	m.reference_sources = nil
	m.clearedreference_sources = false
}

// AddProductIDs adds the "products" edge to the Products entity by ids.
func (m *ProductReferencesMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *ProductReferencesMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *ProductReferencesMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Products entity by IDs.
func (m *ProductReferencesMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Products entity.
func (m *ProductReferencesMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductReferencesMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductReferencesMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddProductHasProductReferenceIDs adds the "product_has_product_reference" edge to the ProductHasProductReference entity by ids.
func (m *ProductReferencesMutation) AddProductHasProductReferenceIDs(ids ...int) {
	if m.product_has_product_reference == nil {
		m.product_has_product_reference = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_product_reference[ids[i]] = struct{}{}
	}
}

// ClearProductHasProductReference clears the "product_has_product_reference" edge to the ProductHasProductReference entity.
func (m *ProductReferencesMutation) ClearProductHasProductReference() {
	m.clearedproduct_has_product_reference = true
}

// ProductHasProductReferenceCleared reports if the "product_has_product_reference" edge to the ProductHasProductReference entity was cleared.
func (m *ProductReferencesMutation) ProductHasProductReferenceCleared() bool {
	return m.clearedproduct_has_product_reference
}

// RemoveProductHasProductReferenceIDs removes the "product_has_product_reference" edge to the ProductHasProductReference entity by IDs.
func (m *ProductReferencesMutation) RemoveProductHasProductReferenceIDs(ids ...int) {
	if m.removedproduct_has_product_reference == nil {
		m.removedproduct_has_product_reference = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_product_reference, ids[i])
		m.removedproduct_has_product_reference[ids[i]] = struct{}{}
	}
}

// RemovedProductHasProductReference returns the removed IDs of the "product_has_product_reference" edge to the ProductHasProductReference entity.
func (m *ProductReferencesMutation) RemovedProductHasProductReferenceIDs() (ids []int) {
	for id := range m.removedproduct_has_product_reference {
		ids = append(ids, id)
	}
	return
}

// ProductHasProductReferenceIDs returns the "product_has_product_reference" edge IDs in the mutation.
func (m *ProductReferencesMutation) ProductHasProductReferenceIDs() (ids []int) {
	for id := range m.product_has_product_reference {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasProductReference resets all changes to the "product_has_product_reference" edge.
func (m *ProductReferencesMutation) ResetProductHasProductReference() {
	m.product_has_product_reference = nil
	m.clearedproduct_has_product_reference = false
	m.removedproduct_has_product_reference = nil
}

// Where appends a list predicates to the ProductReferencesMutation builder.
func (m *ProductReferencesMutation) Where(ps ...predicate.ProductReferences) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductReferencesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductReferencesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductReferences, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductReferencesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductReferencesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductReferences).
func (m *ProductReferencesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductReferencesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, productreferences.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productreferences.FieldDeletedAt)
	}
	if m.reference_sources != nil {
		fields = append(fields, productreferences.FieldReferenceSourceID)
	}
	if m.value != nil {
		fields = append(fields, productreferences.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductReferencesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productreferences.FieldCreatedAt:
		return m.CreatedAt()
	case productreferences.FieldDeletedAt:
		return m.DeletedAt()
	case productreferences.FieldReferenceSourceID:
		return m.ReferenceSourceID()
	case productreferences.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductReferencesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productreferences.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productreferences.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productreferences.FieldReferenceSourceID:
		return m.OldReferenceSourceID(ctx)
	case productreferences.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown ProductReferences field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductReferencesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productreferences.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productreferences.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productreferences.FieldReferenceSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceSourceID(v)
		return nil
	case productreferences.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown ProductReferences field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductReferencesMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductReferencesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductReferencesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductReferences numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductReferencesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productreferences.FieldDeletedAt) {
		fields = append(fields, productreferences.FieldDeletedAt)
	}
	if m.FieldCleared(productreferences.FieldReferenceSourceID) {
		fields = append(fields, productreferences.FieldReferenceSourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductReferencesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductReferencesMutation) ClearField(name string) error {
	switch name {
	case productreferences.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case productreferences.FieldReferenceSourceID:
		m.ClearReferenceSourceID()
		return nil
	}
	return fmt.Errorf("unknown ProductReferences nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductReferencesMutation) ResetField(name string) error {
	switch name {
	case productreferences.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productreferences.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productreferences.FieldReferenceSourceID:
		m.ResetReferenceSourceID()
		return nil
	case productreferences.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown ProductReferences field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductReferencesMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.reference_sources != nil {
		edges = append(edges, productreferences.EdgeReferenceSources)
	}
	if m.products != nil {
		edges = append(edges, productreferences.EdgeProducts)
	}
	if m.product_has_product_reference != nil {
		edges = append(edges, productreferences.EdgeProductHasProductReference)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductReferencesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productreferences.EdgeReferenceSources:
		if id := m.reference_sources; id != nil {
			return []ent.Value{*id}
		}
	case productreferences.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case productreferences.EdgeProductHasProductReference:
		ids := make([]ent.Value, 0, len(m.product_has_product_reference))
		for id := range m.product_has_product_reference {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductReferencesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproducts != nil {
		edges = append(edges, productreferences.EdgeProducts)
	}
	if m.removedproduct_has_product_reference != nil {
		edges = append(edges, productreferences.EdgeProductHasProductReference)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductReferencesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productreferences.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case productreferences.EdgeProductHasProductReference:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_product_reference))
		for id := range m.removedproduct_has_product_reference {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductReferencesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreference_sources {
		edges = append(edges, productreferences.EdgeReferenceSources)
	}
	if m.clearedproducts {
		edges = append(edges, productreferences.EdgeProducts)
	}
	if m.clearedproduct_has_product_reference {
		edges = append(edges, productreferences.EdgeProductHasProductReference)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductReferencesMutation) EdgeCleared(name string) bool {
	switch name {
	case productreferences.EdgeReferenceSources:
		return m.clearedreference_sources
	case productreferences.EdgeProducts:
		return m.clearedproducts
	case productreferences.EdgeProductHasProductReference:
		return m.clearedproduct_has_product_reference
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductReferencesMutation) ClearEdge(name string) error {
	switch name {
	case productreferences.EdgeReferenceSources:
		m.ClearReferenceSources()
		return nil
	}
	return fmt.Errorf("unknown ProductReferences unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductReferencesMutation) ResetEdge(name string) error {
	switch name {
	case productreferences.EdgeReferenceSources:
		m.ResetReferenceSources()
		return nil
	case productreferences.EdgeProducts:
		m.ResetProducts()
		return nil
	case productreferences.EdgeProductHasProductReference:
		m.ResetProductHasProductReference()
		return nil
	}
	return fmt.Errorf("unknown ProductReferences edge %s", name)
}

// ProductsMutation represents an operation that mutates the Products nodes in the graph.
type ProductsMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	created_at                           *time.Time
	deleted_at                           *time.Time
	name                                 *string
	stock                                *int
	addstock                             *int
	clearedFields                        map[string]struct{}
	category                             *int
	clearedcategory                      bool
	brand                                *int
	clearedbrand                         bool
	variant_type                         *int
	clearedvariant_type                  bool
	product_references                   *int
	clearedproduct_references            bool
	product_has_image                    map[int]struct{}
	removedproduct_has_image             map[int]struct{}
	clearedproduct_has_image             bool
	promotion_has_product                map[int]struct{}
	removedpromotion_has_product         map[int]struct{}
	clearedpromotion_has_product         bool
	tool_has_product                     map[int]struct{}
	removedtool_has_product              map[int]struct{}
	clearedtool_has_product              bool
	product_has_feature                  map[int]struct{}
	removedproduct_has_feature           map[int]struct{}
	clearedproduct_has_feature           bool
	product_has_info                     map[int]struct{}
	removedproduct_has_info              map[int]struct{}
	clearedproduct_has_info              bool
	product_has_product_reference        map[int]struct{}
	removedproduct_has_product_reference map[int]struct{}
	clearedproduct_has_product_reference bool
	product_prices                       map[int]struct{}
	removedproduct_prices                map[int]struct{}
	clearedproduct_prices                bool
	done                                 bool
	oldValue                             func(context.Context) (*Products, error)
	predicates                           []predicate.Products
}

var _ ent.Mutation = (*ProductsMutation)(nil)

// productsOption allows management of the mutation configuration using functional options.
type productsOption func(*ProductsMutation)

// newProductsMutation creates new mutation for the Products entity.
func newProductsMutation(c config, op Op, opts ...productsOption) *ProductsMutation {
	m := &ProductsMutation{
		config:        c,
		op:            op,
		typ:           TypeProducts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductsID sets the ID field of the mutation.
func withProductsID(id int) productsOption {
	return func(m *ProductsMutation) {
		var (
			err   error
			once  sync.Once
			value *Products
		)
		m.oldValue = func(ctx context.Context) (*Products, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Products.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProducts sets the old Products of the mutation.
func withProducts(node *Products) productsOption {
	return func(m *ProductsMutation) {
		m.oldValue = func(context.Context) (*Products, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Products.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[products.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[products.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, products.FieldDeletedAt)
}

// SetCategoryID sets the "category_id" field.
func (m *ProductsMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductsMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldCategoryID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *ProductsMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[products.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *ProductsMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[products.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductsMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, products.FieldCategoryID)
}

// SetBrandID sets the "brand_id" field.
func (m *ProductsMutation) SetBrandID(i int) {
	m.brand = &i
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *ProductsMutation) BrandID() (r int, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldBrandID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *ProductsMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[products.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *ProductsMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[products.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *ProductsMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, products.FieldBrandID)
}

// SetVariantTypeID sets the "variant_type_id" field.
func (m *ProductsMutation) SetVariantTypeID(i int) {
	m.variant_type = &i
}

// VariantTypeID returns the value of the "variant_type_id" field in the mutation.
func (m *ProductsMutation) VariantTypeID() (r int, exists bool) {
	v := m.variant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantTypeID returns the old "variant_type_id" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldVariantTypeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantTypeID: %w", err)
	}
	return oldValue.VariantTypeID, nil
}

// ClearVariantTypeID clears the value of the "variant_type_id" field.
func (m *ProductsMutation) ClearVariantTypeID() {
	m.variant_type = nil
	m.clearedFields[products.FieldVariantTypeID] = struct{}{}
}

// VariantTypeIDCleared returns if the "variant_type_id" field was cleared in this mutation.
func (m *ProductsMutation) VariantTypeIDCleared() bool {
	_, ok := m.clearedFields[products.FieldVariantTypeID]
	return ok
}

// ResetVariantTypeID resets all changes to the "variant_type_id" field.
func (m *ProductsMutation) ResetVariantTypeID() {
	m.variant_type = nil
	delete(m.clearedFields, products.FieldVariantTypeID)
}

// SetProductReferencesID sets the "product_references_id" field.
func (m *ProductsMutation) SetProductReferencesID(i int) {
	m.product_references = &i
}

// ProductReferencesID returns the value of the "product_references_id" field in the mutation.
func (m *ProductsMutation) ProductReferencesID() (r int, exists bool) {
	v := m.product_references
	if v == nil {
		return
	}
	return *v, true
}

// OldProductReferencesID returns the old "product_references_id" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldProductReferencesID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductReferencesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductReferencesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductReferencesID: %w", err)
	}
	return oldValue.ProductReferencesID, nil
}

// ClearProductReferencesID clears the value of the "product_references_id" field.
func (m *ProductsMutation) ClearProductReferencesID() {
	m.product_references = nil
	m.clearedFields[products.FieldProductReferencesID] = struct{}{}
}

// ProductReferencesIDCleared returns if the "product_references_id" field was cleared in this mutation.
func (m *ProductsMutation) ProductReferencesIDCleared() bool {
	_, ok := m.clearedFields[products.FieldProductReferencesID]
	return ok
}

// ResetProductReferencesID resets all changes to the "product_references_id" field.
func (m *ProductsMutation) ResetProductReferencesID() {
	m.product_references = nil
	delete(m.clearedFields, products.FieldProductReferencesID)
}

// SetName sets the "name" field.
func (m *ProductsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductsMutation) ResetName() {
	m.name = nil
}

// SetStock sets the "stock" field.
func (m *ProductsMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductsMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Products entity.
// If the Products object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductsMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductsMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductsMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductsMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ProductsMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[products.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ProductsMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProductsMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductsMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *ProductsMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[products.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *ProductsMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *ProductsMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *ProductsMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearVariantType clears the "variant_type" edge to the VariantType entity.
func (m *ProductsMutation) ClearVariantType() {
	m.clearedvariant_type = true
	m.clearedFields[products.FieldVariantTypeID] = struct{}{}
}

// VariantTypeCleared reports if the "variant_type" edge to the VariantType entity was cleared.
func (m *ProductsMutation) VariantTypeCleared() bool {
	return m.VariantTypeIDCleared() || m.clearedvariant_type
}

// VariantTypeIDs returns the "variant_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VariantTypeID instead. It exists only for internal usage by the builders.
func (m *ProductsMutation) VariantTypeIDs() (ids []int) {
	if id := m.variant_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVariantType resets all changes to the "variant_type" edge.
func (m *ProductsMutation) ResetVariantType() {
	m.variant_type = nil
	m.clearedvariant_type = false
}

// ClearProductReferences clears the "product_references" edge to the ProductReferences entity.
func (m *ProductsMutation) ClearProductReferences() {
	m.clearedproduct_references = true
	m.clearedFields[products.FieldProductReferencesID] = struct{}{}
}

// ProductReferencesCleared reports if the "product_references" edge to the ProductReferences entity was cleared.
func (m *ProductsMutation) ProductReferencesCleared() bool {
	return m.ProductReferencesIDCleared() || m.clearedproduct_references
}

// ProductReferencesIDs returns the "product_references" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductReferencesID instead. It exists only for internal usage by the builders.
func (m *ProductsMutation) ProductReferencesIDs() (ids []int) {
	if id := m.product_references; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductReferences resets all changes to the "product_references" edge.
func (m *ProductsMutation) ResetProductReferences() {
	m.product_references = nil
	m.clearedproduct_references = false
}

// AddProductHasImageIDs adds the "product_has_image" edge to the ProductHasImage entity by ids.
func (m *ProductsMutation) AddProductHasImageIDs(ids ...int) {
	if m.product_has_image == nil {
		m.product_has_image = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_image[ids[i]] = struct{}{}
	}
}

// ClearProductHasImage clears the "product_has_image" edge to the ProductHasImage entity.
func (m *ProductsMutation) ClearProductHasImage() {
	m.clearedproduct_has_image = true
}

// ProductHasImageCleared reports if the "product_has_image" edge to the ProductHasImage entity was cleared.
func (m *ProductsMutation) ProductHasImageCleared() bool {
	return m.clearedproduct_has_image
}

// RemoveProductHasImageIDs removes the "product_has_image" edge to the ProductHasImage entity by IDs.
func (m *ProductsMutation) RemoveProductHasImageIDs(ids ...int) {
	if m.removedproduct_has_image == nil {
		m.removedproduct_has_image = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_image, ids[i])
		m.removedproduct_has_image[ids[i]] = struct{}{}
	}
}

// RemovedProductHasImage returns the removed IDs of the "product_has_image" edge to the ProductHasImage entity.
func (m *ProductsMutation) RemovedProductHasImageIDs() (ids []int) {
	for id := range m.removedproduct_has_image {
		ids = append(ids, id)
	}
	return
}

// ProductHasImageIDs returns the "product_has_image" edge IDs in the mutation.
func (m *ProductsMutation) ProductHasImageIDs() (ids []int) {
	for id := range m.product_has_image {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasImage resets all changes to the "product_has_image" edge.
func (m *ProductsMutation) ResetProductHasImage() {
	m.product_has_image = nil
	m.clearedproduct_has_image = false
	m.removedproduct_has_image = nil
}

// AddPromotionHasProductIDs adds the "promotion_has_product" edge to the PromotionHasProduct entity by ids.
func (m *ProductsMutation) AddPromotionHasProductIDs(ids ...int) {
	if m.promotion_has_product == nil {
		m.promotion_has_product = make(map[int]struct{})
	}
	for i := range ids {
		m.promotion_has_product[ids[i]] = struct{}{}
	}
}

// ClearPromotionHasProduct clears the "promotion_has_product" edge to the PromotionHasProduct entity.
func (m *ProductsMutation) ClearPromotionHasProduct() {
	m.clearedpromotion_has_product = true
}

// PromotionHasProductCleared reports if the "promotion_has_product" edge to the PromotionHasProduct entity was cleared.
func (m *ProductsMutation) PromotionHasProductCleared() bool {
	return m.clearedpromotion_has_product
}

// RemovePromotionHasProductIDs removes the "promotion_has_product" edge to the PromotionHasProduct entity by IDs.
func (m *ProductsMutation) RemovePromotionHasProductIDs(ids ...int) {
	if m.removedpromotion_has_product == nil {
		m.removedpromotion_has_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.promotion_has_product, ids[i])
		m.removedpromotion_has_product[ids[i]] = struct{}{}
	}
}

// RemovedPromotionHasProduct returns the removed IDs of the "promotion_has_product" edge to the PromotionHasProduct entity.
func (m *ProductsMutation) RemovedPromotionHasProductIDs() (ids []int) {
	for id := range m.removedpromotion_has_product {
		ids = append(ids, id)
	}
	return
}

// PromotionHasProductIDs returns the "promotion_has_product" edge IDs in the mutation.
func (m *ProductsMutation) PromotionHasProductIDs() (ids []int) {
	for id := range m.promotion_has_product {
		ids = append(ids, id)
	}
	return
}

// ResetPromotionHasProduct resets all changes to the "promotion_has_product" edge.
func (m *ProductsMutation) ResetPromotionHasProduct() {
	m.promotion_has_product = nil
	m.clearedpromotion_has_product = false
	m.removedpromotion_has_product = nil
}

// AddToolHasProductIDs adds the "tool_has_product" edge to the ToolHasProduct entity by ids.
func (m *ProductsMutation) AddToolHasProductIDs(ids ...int) {
	if m.tool_has_product == nil {
		m.tool_has_product = make(map[int]struct{})
	}
	for i := range ids {
		m.tool_has_product[ids[i]] = struct{}{}
	}
}

// ClearToolHasProduct clears the "tool_has_product" edge to the ToolHasProduct entity.
func (m *ProductsMutation) ClearToolHasProduct() {
	m.clearedtool_has_product = true
}

// ToolHasProductCleared reports if the "tool_has_product" edge to the ToolHasProduct entity was cleared.
func (m *ProductsMutation) ToolHasProductCleared() bool {
	return m.clearedtool_has_product
}

// RemoveToolHasProductIDs removes the "tool_has_product" edge to the ToolHasProduct entity by IDs.
func (m *ProductsMutation) RemoveToolHasProductIDs(ids ...int) {
	if m.removedtool_has_product == nil {
		m.removedtool_has_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tool_has_product, ids[i])
		m.removedtool_has_product[ids[i]] = struct{}{}
	}
}

// RemovedToolHasProduct returns the removed IDs of the "tool_has_product" edge to the ToolHasProduct entity.
func (m *ProductsMutation) RemovedToolHasProductIDs() (ids []int) {
	for id := range m.removedtool_has_product {
		ids = append(ids, id)
	}
	return
}

// ToolHasProductIDs returns the "tool_has_product" edge IDs in the mutation.
func (m *ProductsMutation) ToolHasProductIDs() (ids []int) {
	for id := range m.tool_has_product {
		ids = append(ids, id)
	}
	return
}

// ResetToolHasProduct resets all changes to the "tool_has_product" edge.
func (m *ProductsMutation) ResetToolHasProduct() {
	m.tool_has_product = nil
	m.clearedtool_has_product = false
	m.removedtool_has_product = nil
}

// AddProductHasFeatureIDs adds the "product_has_feature" edge to the ProductHasFeature entity by ids.
func (m *ProductsMutation) AddProductHasFeatureIDs(ids ...int) {
	if m.product_has_feature == nil {
		m.product_has_feature = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_feature[ids[i]] = struct{}{}
	}
}

// ClearProductHasFeature clears the "product_has_feature" edge to the ProductHasFeature entity.
func (m *ProductsMutation) ClearProductHasFeature() {
	m.clearedproduct_has_feature = true
}

// ProductHasFeatureCleared reports if the "product_has_feature" edge to the ProductHasFeature entity was cleared.
func (m *ProductsMutation) ProductHasFeatureCleared() bool {
	return m.clearedproduct_has_feature
}

// RemoveProductHasFeatureIDs removes the "product_has_feature" edge to the ProductHasFeature entity by IDs.
func (m *ProductsMutation) RemoveProductHasFeatureIDs(ids ...int) {
	if m.removedproduct_has_feature == nil {
		m.removedproduct_has_feature = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_feature, ids[i])
		m.removedproduct_has_feature[ids[i]] = struct{}{}
	}
}

// RemovedProductHasFeature returns the removed IDs of the "product_has_feature" edge to the ProductHasFeature entity.
func (m *ProductsMutation) RemovedProductHasFeatureIDs() (ids []int) {
	for id := range m.removedproduct_has_feature {
		ids = append(ids, id)
	}
	return
}

// ProductHasFeatureIDs returns the "product_has_feature" edge IDs in the mutation.
func (m *ProductsMutation) ProductHasFeatureIDs() (ids []int) {
	for id := range m.product_has_feature {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasFeature resets all changes to the "product_has_feature" edge.
func (m *ProductsMutation) ResetProductHasFeature() {
	m.product_has_feature = nil
	m.clearedproduct_has_feature = false
	m.removedproduct_has_feature = nil
}

// AddProductHasInfoIDs adds the "product_has_info" edge to the ProductHasInfo entity by ids.
func (m *ProductsMutation) AddProductHasInfoIDs(ids ...int) {
	if m.product_has_info == nil {
		m.product_has_info = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_info[ids[i]] = struct{}{}
	}
}

// ClearProductHasInfo clears the "product_has_info" edge to the ProductHasInfo entity.
func (m *ProductsMutation) ClearProductHasInfo() {
	m.clearedproduct_has_info = true
}

// ProductHasInfoCleared reports if the "product_has_info" edge to the ProductHasInfo entity was cleared.
func (m *ProductsMutation) ProductHasInfoCleared() bool {
	return m.clearedproduct_has_info
}

// RemoveProductHasInfoIDs removes the "product_has_info" edge to the ProductHasInfo entity by IDs.
func (m *ProductsMutation) RemoveProductHasInfoIDs(ids ...int) {
	if m.removedproduct_has_info == nil {
		m.removedproduct_has_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_info, ids[i])
		m.removedproduct_has_info[ids[i]] = struct{}{}
	}
}

// RemovedProductHasInfo returns the removed IDs of the "product_has_info" edge to the ProductHasInfo entity.
func (m *ProductsMutation) RemovedProductHasInfoIDs() (ids []int) {
	for id := range m.removedproduct_has_info {
		ids = append(ids, id)
	}
	return
}

// ProductHasInfoIDs returns the "product_has_info" edge IDs in the mutation.
func (m *ProductsMutation) ProductHasInfoIDs() (ids []int) {
	for id := range m.product_has_info {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasInfo resets all changes to the "product_has_info" edge.
func (m *ProductsMutation) ResetProductHasInfo() {
	m.product_has_info = nil
	m.clearedproduct_has_info = false
	m.removedproduct_has_info = nil
}

// AddProductHasProductReferenceIDs adds the "product_has_product_reference" edge to the ProductHasProductReference entity by ids.
func (m *ProductsMutation) AddProductHasProductReferenceIDs(ids ...int) {
	if m.product_has_product_reference == nil {
		m.product_has_product_reference = make(map[int]struct{})
	}
	for i := range ids {
		m.product_has_product_reference[ids[i]] = struct{}{}
	}
}

// ClearProductHasProductReference clears the "product_has_product_reference" edge to the ProductHasProductReference entity.
func (m *ProductsMutation) ClearProductHasProductReference() {
	m.clearedproduct_has_product_reference = true
}

// ProductHasProductReferenceCleared reports if the "product_has_product_reference" edge to the ProductHasProductReference entity was cleared.
func (m *ProductsMutation) ProductHasProductReferenceCleared() bool {
	return m.clearedproduct_has_product_reference
}

// RemoveProductHasProductReferenceIDs removes the "product_has_product_reference" edge to the ProductHasProductReference entity by IDs.
func (m *ProductsMutation) RemoveProductHasProductReferenceIDs(ids ...int) {
	if m.removedproduct_has_product_reference == nil {
		m.removedproduct_has_product_reference = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_has_product_reference, ids[i])
		m.removedproduct_has_product_reference[ids[i]] = struct{}{}
	}
}

// RemovedProductHasProductReference returns the removed IDs of the "product_has_product_reference" edge to the ProductHasProductReference entity.
func (m *ProductsMutation) RemovedProductHasProductReferenceIDs() (ids []int) {
	for id := range m.removedproduct_has_product_reference {
		ids = append(ids, id)
	}
	return
}

// ProductHasProductReferenceIDs returns the "product_has_product_reference" edge IDs in the mutation.
func (m *ProductsMutation) ProductHasProductReferenceIDs() (ids []int) {
	for id := range m.product_has_product_reference {
		ids = append(ids, id)
	}
	return
}

// ResetProductHasProductReference resets all changes to the "product_has_product_reference" edge.
func (m *ProductsMutation) ResetProductHasProductReference() {
	m.product_has_product_reference = nil
	m.clearedproduct_has_product_reference = false
	m.removedproduct_has_product_reference = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrices entity by ids.
func (m *ProductsMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrices entity.
func (m *ProductsMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrices entity was cleared.
func (m *ProductsMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrices entity by IDs.
func (m *ProductsMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_prices, ids[i])
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrices entity.
func (m *ProductsMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *ProductsMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *ProductsMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// Where appends a list predicates to the ProductsMutation builder.
func (m *ProductsMutation) Where(ps ...predicate.Products) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Products, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Products).
func (m *ProductsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, products.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, products.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, products.FieldCategoryID)
	}
	if m.brand != nil {
		fields = append(fields, products.FieldBrandID)
	}
	if m.variant_type != nil {
		fields = append(fields, products.FieldVariantTypeID)
	}
	if m.product_references != nil {
		fields = append(fields, products.FieldProductReferencesID)
	}
	if m.name != nil {
		fields = append(fields, products.FieldName)
	}
	if m.stock != nil {
		fields = append(fields, products.FieldStock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case products.FieldCreatedAt:
		return m.CreatedAt()
	case products.FieldDeletedAt:
		return m.DeletedAt()
	case products.FieldCategoryID:
		return m.CategoryID()
	case products.FieldBrandID:
		return m.BrandID()
	case products.FieldVariantTypeID:
		return m.VariantTypeID()
	case products.FieldProductReferencesID:
		return m.ProductReferencesID()
	case products.FieldName:
		return m.Name()
	case products.FieldStock:
		return m.Stock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case products.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case products.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case products.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case products.FieldBrandID:
		return m.OldBrandID(ctx)
	case products.FieldVariantTypeID:
		return m.OldVariantTypeID(ctx)
	case products.FieldProductReferencesID:
		return m.OldProductReferencesID(ctx)
	case products.FieldName:
		return m.OldName(ctx)
	case products.FieldStock:
		return m.OldStock(ctx)
	}
	return nil, fmt.Errorf("unknown Products field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case products.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case products.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case products.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case products.FieldBrandID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case products.FieldVariantTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantTypeID(v)
		return nil
	case products.FieldProductReferencesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductReferencesID(v)
		return nil
	case products.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case products.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	}
	return fmt.Errorf("unknown Products field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductsMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, products.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case products.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case products.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown Products numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(products.FieldDeletedAt) {
		fields = append(fields, products.FieldDeletedAt)
	}
	if m.FieldCleared(products.FieldCategoryID) {
		fields = append(fields, products.FieldCategoryID)
	}
	if m.FieldCleared(products.FieldBrandID) {
		fields = append(fields, products.FieldBrandID)
	}
	if m.FieldCleared(products.FieldVariantTypeID) {
		fields = append(fields, products.FieldVariantTypeID)
	}
	if m.FieldCleared(products.FieldProductReferencesID) {
		fields = append(fields, products.FieldProductReferencesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductsMutation) ClearField(name string) error {
	switch name {
	case products.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case products.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case products.FieldBrandID:
		m.ClearBrandID()
		return nil
	case products.FieldVariantTypeID:
		m.ClearVariantTypeID()
		return nil
	case products.FieldProductReferencesID:
		m.ClearProductReferencesID()
		return nil
	}
	return fmt.Errorf("unknown Products nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductsMutation) ResetField(name string) error {
	switch name {
	case products.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case products.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case products.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case products.FieldBrandID:
		m.ResetBrandID()
		return nil
	case products.FieldVariantTypeID:
		m.ResetVariantTypeID()
		return nil
	case products.FieldProductReferencesID:
		m.ResetProductReferencesID()
		return nil
	case products.FieldName:
		m.ResetName()
		return nil
	case products.FieldStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Products field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductsMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.category != nil {
		edges = append(edges, products.EdgeCategory)
	}
	if m.brand != nil {
		edges = append(edges, products.EdgeBrand)
	}
	if m.variant_type != nil {
		edges = append(edges, products.EdgeVariantType)
	}
	if m.product_references != nil {
		edges = append(edges, products.EdgeProductReferences)
	}
	if m.product_has_image != nil {
		edges = append(edges, products.EdgeProductHasImage)
	}
	if m.promotion_has_product != nil {
		edges = append(edges, products.EdgePromotionHasProduct)
	}
	if m.tool_has_product != nil {
		edges = append(edges, products.EdgeToolHasProduct)
	}
	if m.product_has_feature != nil {
		edges = append(edges, products.EdgeProductHasFeature)
	}
	if m.product_has_info != nil {
		edges = append(edges, products.EdgeProductHasInfo)
	}
	if m.product_has_product_reference != nil {
		edges = append(edges, products.EdgeProductHasProductReference)
	}
	if m.product_prices != nil {
		edges = append(edges, products.EdgeProductPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case products.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case products.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case products.EdgeVariantType:
		if id := m.variant_type; id != nil {
			return []ent.Value{*id}
		}
	case products.EdgeProductReferences:
		if id := m.product_references; id != nil {
			return []ent.Value{*id}
		}
	case products.EdgeProductHasImage:
		ids := make([]ent.Value, 0, len(m.product_has_image))
		for id := range m.product_has_image {
			ids = append(ids, id)
		}
		return ids
	case products.EdgePromotionHasProduct:
		ids := make([]ent.Value, 0, len(m.promotion_has_product))
		for id := range m.promotion_has_product {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeToolHasProduct:
		ids := make([]ent.Value, 0, len(m.tool_has_product))
		for id := range m.tool_has_product {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasFeature:
		ids := make([]ent.Value, 0, len(m.product_has_feature))
		for id := range m.product_has_feature {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasInfo:
		ids := make([]ent.Value, 0, len(m.product_has_info))
		for id := range m.product_has_info {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasProductReference:
		ids := make([]ent.Value, 0, len(m.product_has_product_reference))
		for id := range m.product_has_product_reference {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedproduct_has_image != nil {
		edges = append(edges, products.EdgeProductHasImage)
	}
	if m.removedpromotion_has_product != nil {
		edges = append(edges, products.EdgePromotionHasProduct)
	}
	if m.removedtool_has_product != nil {
		edges = append(edges, products.EdgeToolHasProduct)
	}
	if m.removedproduct_has_feature != nil {
		edges = append(edges, products.EdgeProductHasFeature)
	}
	if m.removedproduct_has_info != nil {
		edges = append(edges, products.EdgeProductHasInfo)
	}
	if m.removedproduct_has_product_reference != nil {
		edges = append(edges, products.EdgeProductHasProductReference)
	}
	if m.removedproduct_prices != nil {
		edges = append(edges, products.EdgeProductPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case products.EdgeProductHasImage:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_image))
		for id := range m.removedproduct_has_image {
			ids = append(ids, id)
		}
		return ids
	case products.EdgePromotionHasProduct:
		ids := make([]ent.Value, 0, len(m.removedpromotion_has_product))
		for id := range m.removedpromotion_has_product {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeToolHasProduct:
		ids := make([]ent.Value, 0, len(m.removedtool_has_product))
		for id := range m.removedtool_has_product {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasFeature:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_feature))
		for id := range m.removedproduct_has_feature {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasInfo:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_info))
		for id := range m.removedproduct_has_info {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductHasProductReference:
		ids := make([]ent.Value, 0, len(m.removedproduct_has_product_reference))
		for id := range m.removedproduct_has_product_reference {
			ids = append(ids, id)
		}
		return ids
	case products.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedcategory {
		edges = append(edges, products.EdgeCategory)
	}
	if m.clearedbrand {
		edges = append(edges, products.EdgeBrand)
	}
	if m.clearedvariant_type {
		edges = append(edges, products.EdgeVariantType)
	}
	if m.clearedproduct_references {
		edges = append(edges, products.EdgeProductReferences)
	}
	if m.clearedproduct_has_image {
		edges = append(edges, products.EdgeProductHasImage)
	}
	if m.clearedpromotion_has_product {
		edges = append(edges, products.EdgePromotionHasProduct)
	}
	if m.clearedtool_has_product {
		edges = append(edges, products.EdgeToolHasProduct)
	}
	if m.clearedproduct_has_feature {
		edges = append(edges, products.EdgeProductHasFeature)
	}
	if m.clearedproduct_has_info {
		edges = append(edges, products.EdgeProductHasInfo)
	}
	if m.clearedproduct_has_product_reference {
		edges = append(edges, products.EdgeProductHasProductReference)
	}
	if m.clearedproduct_prices {
		edges = append(edges, products.EdgeProductPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductsMutation) EdgeCleared(name string) bool {
	switch name {
	case products.EdgeCategory:
		return m.clearedcategory
	case products.EdgeBrand:
		return m.clearedbrand
	case products.EdgeVariantType:
		return m.clearedvariant_type
	case products.EdgeProductReferences:
		return m.clearedproduct_references
	case products.EdgeProductHasImage:
		return m.clearedproduct_has_image
	case products.EdgePromotionHasProduct:
		return m.clearedpromotion_has_product
	case products.EdgeToolHasProduct:
		return m.clearedtool_has_product
	case products.EdgeProductHasFeature:
		return m.clearedproduct_has_feature
	case products.EdgeProductHasInfo:
		return m.clearedproduct_has_info
	case products.EdgeProductHasProductReference:
		return m.clearedproduct_has_product_reference
	case products.EdgeProductPrices:
		return m.clearedproduct_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductsMutation) ClearEdge(name string) error {
	switch name {
	case products.EdgeCategory:
		m.ClearCategory()
		return nil
	case products.EdgeBrand:
		m.ClearBrand()
		return nil
	case products.EdgeVariantType:
		m.ClearVariantType()
		return nil
	case products.EdgeProductReferences:
		m.ClearProductReferences()
		return nil
	}
	return fmt.Errorf("unknown Products unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductsMutation) ResetEdge(name string) error {
	switch name {
	case products.EdgeCategory:
		m.ResetCategory()
		return nil
	case products.EdgeBrand:
		m.ResetBrand()
		return nil
	case products.EdgeVariantType:
		m.ResetVariantType()
		return nil
	case products.EdgeProductReferences:
		m.ResetProductReferences()
		return nil
	case products.EdgeProductHasImage:
		m.ResetProductHasImage()
		return nil
	case products.EdgePromotionHasProduct:
		m.ResetPromotionHasProduct()
		return nil
	case products.EdgeToolHasProduct:
		m.ResetToolHasProduct()
		return nil
	case products.EdgeProductHasFeature:
		m.ResetProductHasFeature()
		return nil
	case products.EdgeProductHasInfo:
		m.ResetProductHasInfo()
		return nil
	case products.EdgeProductHasProductReference:
		m.ResetProductHasProductReference()
		return nil
	case products.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	}
	return fmt.Errorf("unknown Products edge %s", name)
}

// PromotionHasProductMutation represents an operation that mutates the PromotionHasProduct nodes in the graph.
type PromotionHasProductMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	promocional_price    *float64
	addpromocional_price *float64
	clearedFields        map[string]struct{}
	products             *int
	clearedproducts      bool
	promotions           *int
	clearedpromotions    bool
	done                 bool
	oldValue             func(context.Context) (*PromotionHasProduct, error)
	predicates           []predicate.PromotionHasProduct
}

var _ ent.Mutation = (*PromotionHasProductMutation)(nil)

// promotionhasproductOption allows management of the mutation configuration using functional options.
type promotionhasproductOption func(*PromotionHasProductMutation)

// newPromotionHasProductMutation creates new mutation for the PromotionHasProduct entity.
func newPromotionHasProductMutation(c config, op Op, opts ...promotionhasproductOption) *PromotionHasProductMutation {
	m := &PromotionHasProductMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionHasProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionHasProductID sets the ID field of the mutation.
func withPromotionHasProductID(id int) promotionhasproductOption {
	return func(m *PromotionHasProductMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionHasProduct
		)
		m.oldValue = func(ctx context.Context) (*PromotionHasProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionHasProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionHasProduct sets the old PromotionHasProduct of the mutation.
func withPromotionHasProduct(node *PromotionHasProduct) promotionhasproductOption {
	return func(m *PromotionHasProductMutation) {
		m.oldValue = func(context.Context) (*PromotionHasProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionHasProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionHasProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionHasProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionHasProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionHasProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionHasProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionHasProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionHasProduct entity.
// If the PromotionHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionHasProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionHasProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionHasProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionHasProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionHasProduct entity.
// If the PromotionHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionHasProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionHasProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionhasproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionHasProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionhasproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionHasProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionhasproduct.FieldDeletedAt)
}

// SetProductsID sets the "products_id" field.
func (m *PromotionHasProductMutation) SetProductsID(i int) {
	m.products = &i
}

// ProductsID returns the value of the "products_id" field in the mutation.
func (m *PromotionHasProductMutation) ProductsID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductsID returns the old "products_id" field's value of the PromotionHasProduct entity.
// If the PromotionHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionHasProductMutation) OldProductsID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductsID: %w", err)
	}
	return oldValue.ProductsID, nil
}

// ClearProductsID clears the value of the "products_id" field.
func (m *PromotionHasProductMutation) ClearProductsID() {
	m.products = nil
	m.clearedFields[promotionhasproduct.FieldProductsID] = struct{}{}
}

// ProductsIDCleared returns if the "products_id" field was cleared in this mutation.
func (m *PromotionHasProductMutation) ProductsIDCleared() bool {
	_, ok := m.clearedFields[promotionhasproduct.FieldProductsID]
	return ok
}

// ResetProductsID resets all changes to the "products_id" field.
func (m *PromotionHasProductMutation) ResetProductsID() {
	m.products = nil
	delete(m.clearedFields, promotionhasproduct.FieldProductsID)
}

// SetPromotionsID sets the "promotions_id" field.
func (m *PromotionHasProductMutation) SetPromotionsID(i int) {
	m.promotions = &i
}

// PromotionsID returns the value of the "promotions_id" field in the mutation.
func (m *PromotionHasProductMutation) PromotionsID() (r int, exists bool) {
	v := m.promotions
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionsID returns the old "promotions_id" field's value of the PromotionHasProduct entity.
// If the PromotionHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionHasProductMutation) OldPromotionsID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionsID: %w", err)
	}
	return oldValue.PromotionsID, nil
}

// ClearPromotionsID clears the value of the "promotions_id" field.
func (m *PromotionHasProductMutation) ClearPromotionsID() {
	m.promotions = nil
	m.clearedFields[promotionhasproduct.FieldPromotionsID] = struct{}{}
}

// PromotionsIDCleared returns if the "promotions_id" field was cleared in this mutation.
func (m *PromotionHasProductMutation) PromotionsIDCleared() bool {
	_, ok := m.clearedFields[promotionhasproduct.FieldPromotionsID]
	return ok
}

// ResetPromotionsID resets all changes to the "promotions_id" field.
func (m *PromotionHasProductMutation) ResetPromotionsID() {
	m.promotions = nil
	delete(m.clearedFields, promotionhasproduct.FieldPromotionsID)
}

// SetPromocionalPrice sets the "promocional_price" field.
func (m *PromotionHasProductMutation) SetPromocionalPrice(f float64) {
	m.promocional_price = &f
	m.addpromocional_price = nil
}

// PromocionalPrice returns the value of the "promocional_price" field in the mutation.
func (m *PromotionHasProductMutation) PromocionalPrice() (r float64, exists bool) {
	v := m.promocional_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPromocionalPrice returns the old "promocional_price" field's value of the PromotionHasProduct entity.
// If the PromotionHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionHasProductMutation) OldPromocionalPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromocionalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromocionalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromocionalPrice: %w", err)
	}
	return oldValue.PromocionalPrice, nil
}

// AddPromocionalPrice adds f to the "promocional_price" field.
func (m *PromotionHasProductMutation) AddPromocionalPrice(f float64) {
	if m.addpromocional_price != nil {
		*m.addpromocional_price += f
	} else {
		m.addpromocional_price = &f
	}
}

// AddedPromocionalPrice returns the value that was added to the "promocional_price" field in this mutation.
func (m *PromotionHasProductMutation) AddedPromocionalPrice() (r float64, exists bool) {
	v := m.addpromocional_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromocionalPrice resets all changes to the "promocional_price" field.
func (m *PromotionHasProductMutation) ResetPromocionalPrice() {
	m.promocional_price = nil
	m.addpromocional_price = nil
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *PromotionHasProductMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[promotionhasproduct.FieldProductsID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *PromotionHasProductMutation) ProductsCleared() bool {
	return m.ProductsIDCleared() || m.clearedproducts
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *PromotionHasProductMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *PromotionHasProductMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// ClearPromotions clears the "promotions" edge to the Promotions entity.
func (m *PromotionHasProductMutation) ClearPromotions() {
	m.clearedpromotions = true
	m.clearedFields[promotionhasproduct.FieldPromotionsID] = struct{}{}
}

// PromotionsCleared reports if the "promotions" edge to the Promotions entity was cleared.
func (m *PromotionHasProductMutation) PromotionsCleared() bool {
	return m.PromotionsIDCleared() || m.clearedpromotions
}

// PromotionsIDs returns the "promotions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromotionsID instead. It exists only for internal usage by the builders.
func (m *PromotionHasProductMutation) PromotionsIDs() (ids []int) {
	if id := m.promotions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotions resets all changes to the "promotions" edge.
func (m *PromotionHasProductMutation) ResetPromotions() {
	m.promotions = nil
	m.clearedpromotions = false
}

// Where appends a list predicates to the PromotionHasProductMutation builder.
func (m *PromotionHasProductMutation) Where(ps ...predicate.PromotionHasProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionHasProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionHasProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionHasProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionHasProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionHasProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionHasProduct).
func (m *PromotionHasProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionHasProductMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, promotionhasproduct.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionhasproduct.FieldDeletedAt)
	}
	if m.products != nil {
		fields = append(fields, promotionhasproduct.FieldProductsID)
	}
	if m.promotions != nil {
		fields = append(fields, promotionhasproduct.FieldPromotionsID)
	}
	if m.promocional_price != nil {
		fields = append(fields, promotionhasproduct.FieldPromocionalPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionHasProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionhasproduct.FieldCreatedAt:
		return m.CreatedAt()
	case promotionhasproduct.FieldDeletedAt:
		return m.DeletedAt()
	case promotionhasproduct.FieldProductsID:
		return m.ProductsID()
	case promotionhasproduct.FieldPromotionsID:
		return m.PromotionsID()
	case promotionhasproduct.FieldPromocionalPrice:
		return m.PromocionalPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionHasProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionhasproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionhasproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionhasproduct.FieldProductsID:
		return m.OldProductsID(ctx)
	case promotionhasproduct.FieldPromotionsID:
		return m.OldPromotionsID(ctx)
	case promotionhasproduct.FieldPromocionalPrice:
		return m.OldPromocionalPrice(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionHasProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionHasProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionhasproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionhasproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionhasproduct.FieldProductsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductsID(v)
		return nil
	case promotionhasproduct.FieldPromotionsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionsID(v)
		return nil
	case promotionhasproduct.FieldPromocionalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromocionalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionHasProductMutation) AddedFields() []string {
	var fields []string
	if m.addpromocional_price != nil {
		fields = append(fields, promotionhasproduct.FieldPromocionalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionHasProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionhasproduct.FieldPromocionalPrice:
		return m.AddedPromocionalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionHasProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionhasproduct.FieldPromocionalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromocionalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionHasProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionhasproduct.FieldDeletedAt) {
		fields = append(fields, promotionhasproduct.FieldDeletedAt)
	}
	if m.FieldCleared(promotionhasproduct.FieldProductsID) {
		fields = append(fields, promotionhasproduct.FieldProductsID)
	}
	if m.FieldCleared(promotionhasproduct.FieldPromotionsID) {
		fields = append(fields, promotionhasproduct.FieldPromotionsID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionHasProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionHasProductMutation) ClearField(name string) error {
	switch name {
	case promotionhasproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionhasproduct.FieldProductsID:
		m.ClearProductsID()
		return nil
	case promotionhasproduct.FieldPromotionsID:
		m.ClearPromotionsID()
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionHasProductMutation) ResetField(name string) error {
	switch name {
	case promotionhasproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionhasproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionhasproduct.FieldProductsID:
		m.ResetProductsID()
		return nil
	case promotionhasproduct.FieldPromotionsID:
		m.ResetPromotionsID()
		return nil
	case promotionhasproduct.FieldPromocionalPrice:
		m.ResetPromocionalPrice()
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionHasProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, promotionhasproduct.EdgeProducts)
	}
	if m.promotions != nil {
		edges = append(edges, promotionhasproduct.EdgePromotions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionHasProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionhasproduct.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case promotionhasproduct.EdgePromotions:
		if id := m.promotions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionHasProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionHasProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionHasProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, promotionhasproduct.EdgeProducts)
	}
	if m.clearedpromotions {
		edges = append(edges, promotionhasproduct.EdgePromotions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionHasProductMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionhasproduct.EdgeProducts:
		return m.clearedproducts
	case promotionhasproduct.EdgePromotions:
		return m.clearedpromotions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionHasProductMutation) ClearEdge(name string) error {
	switch name {
	case promotionhasproduct.EdgeProducts:
		m.ClearProducts()
		return nil
	case promotionhasproduct.EdgePromotions:
		m.ClearPromotions()
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionHasProductMutation) ResetEdge(name string) error {
	switch name {
	case promotionhasproduct.EdgeProducts:
		m.ResetProducts()
		return nil
	case promotionhasproduct.EdgePromotions:
		m.ResetPromotions()
		return nil
	}
	return fmt.Errorf("unknown PromotionHasProduct edge %s", name)
}

// PromotionsMutation represents an operation that mutates the Promotions nodes in the graph.
type PromotionsMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	starting_datetime            *time.Time
	ending_datetime              *time.Time
	clearedFields                map[string]struct{}
	promotion_has_product        map[int]struct{}
	removedpromotion_has_product map[int]struct{}
	clearedpromotion_has_product bool
	done                         bool
	oldValue                     func(context.Context) (*Promotions, error)
	predicates                   []predicate.Promotions
}

var _ ent.Mutation = (*PromotionsMutation)(nil)

// promotionsOption allows management of the mutation configuration using functional options.
type promotionsOption func(*PromotionsMutation)

// newPromotionsMutation creates new mutation for the Promotions entity.
func newPromotionsMutation(c config, op Op, opts ...promotionsOption) *PromotionsMutation {
	m := &PromotionsMutation{
		config:        c,
		op:            op,
		typ:           TypePromotions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionsID sets the ID field of the mutation.
func withPromotionsID(id int) promotionsOption {
	return func(m *PromotionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotions
		)
		m.oldValue = func(ctx context.Context) (*Promotions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotions sets the old Promotions of the mutation.
func withPromotions(node *Promotions) promotionsOption {
	return func(m *PromotionsMutation) {
		m.oldValue = func(context.Context) (*Promotions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Promotions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Promotions entity.
// If the Promotions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Promotions entity.
// If the Promotions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotions.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotions.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotions.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PromotionsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Promotions entity.
// If the Promotions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionsMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromotionsMutation) ResetName() {
	m.name = nil
}

// SetStartingDatetime sets the "starting_datetime" field.
func (m *PromotionsMutation) SetStartingDatetime(t time.Time) {
	m.starting_datetime = &t
}

// StartingDatetime returns the value of the "starting_datetime" field in the mutation.
func (m *PromotionsMutation) StartingDatetime() (r time.Time, exists bool) {
	v := m.starting_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartingDatetime returns the old "starting_datetime" field's value of the Promotions entity.
// If the Promotions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionsMutation) OldStartingDatetime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartingDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartingDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartingDatetime: %w", err)
	}
	return oldValue.StartingDatetime, nil
}

// ResetStartingDatetime resets all changes to the "starting_datetime" field.
func (m *PromotionsMutation) ResetStartingDatetime() {
	m.starting_datetime = nil
}

// SetEndingDatetime sets the "ending_datetime" field.
func (m *PromotionsMutation) SetEndingDatetime(t time.Time) {
	m.ending_datetime = &t
}

// EndingDatetime returns the value of the "ending_datetime" field in the mutation.
func (m *PromotionsMutation) EndingDatetime() (r time.Time, exists bool) {
	v := m.ending_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndingDatetime returns the old "ending_datetime" field's value of the Promotions entity.
// If the Promotions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionsMutation) OldEndingDatetime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndingDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndingDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndingDatetime: %w", err)
	}
	return oldValue.EndingDatetime, nil
}

// ResetEndingDatetime resets all changes to the "ending_datetime" field.
func (m *PromotionsMutation) ResetEndingDatetime() {
	m.ending_datetime = nil
}

// AddPromotionHasProductIDs adds the "promotion_has_product" edge to the PromotionHasProduct entity by ids.
func (m *PromotionsMutation) AddPromotionHasProductIDs(ids ...int) {
	if m.promotion_has_product == nil {
		m.promotion_has_product = make(map[int]struct{})
	}
	for i := range ids {
		m.promotion_has_product[ids[i]] = struct{}{}
	}
}

// ClearPromotionHasProduct clears the "promotion_has_product" edge to the PromotionHasProduct entity.
func (m *PromotionsMutation) ClearPromotionHasProduct() {
	m.clearedpromotion_has_product = true
}

// PromotionHasProductCleared reports if the "promotion_has_product" edge to the PromotionHasProduct entity was cleared.
func (m *PromotionsMutation) PromotionHasProductCleared() bool {
	return m.clearedpromotion_has_product
}

// RemovePromotionHasProductIDs removes the "promotion_has_product" edge to the PromotionHasProduct entity by IDs.
func (m *PromotionsMutation) RemovePromotionHasProductIDs(ids ...int) {
	if m.removedpromotion_has_product == nil {
		m.removedpromotion_has_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.promotion_has_product, ids[i])
		m.removedpromotion_has_product[ids[i]] = struct{}{}
	}
}

// RemovedPromotionHasProduct returns the removed IDs of the "promotion_has_product" edge to the PromotionHasProduct entity.
func (m *PromotionsMutation) RemovedPromotionHasProductIDs() (ids []int) {
	for id := range m.removedpromotion_has_product {
		ids = append(ids, id)
	}
	return
}

// PromotionHasProductIDs returns the "promotion_has_product" edge IDs in the mutation.
func (m *PromotionsMutation) PromotionHasProductIDs() (ids []int) {
	for id := range m.promotion_has_product {
		ids = append(ids, id)
	}
	return
}

// ResetPromotionHasProduct resets all changes to the "promotion_has_product" edge.
func (m *PromotionsMutation) ResetPromotionHasProduct() {
	m.promotion_has_product = nil
	m.clearedpromotion_has_product = false
	m.removedpromotion_has_product = nil
}

// Where appends a list predicates to the PromotionsMutation builder.
func (m *PromotionsMutation) Where(ps ...predicate.Promotions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Promotions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Promotions).
func (m *PromotionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, promotions.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotions.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, promotions.FieldName)
	}
	if m.starting_datetime != nil {
		fields = append(fields, promotions.FieldStartingDatetime)
	}
	if m.ending_datetime != nil {
		fields = append(fields, promotions.FieldEndingDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotions.FieldCreatedAt:
		return m.CreatedAt()
	case promotions.FieldDeletedAt:
		return m.DeletedAt()
	case promotions.FieldName:
		return m.Name()
	case promotions.FieldStartingDatetime:
		return m.StartingDatetime()
	case promotions.FieldEndingDatetime:
		return m.EndingDatetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotions.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotions.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotions.FieldName:
		return m.OldName(ctx)
	case promotions.FieldStartingDatetime:
		return m.OldStartingDatetime(ctx)
	case promotions.FieldEndingDatetime:
		return m.OldEndingDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Promotions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotions.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotions.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotions.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotions.FieldStartingDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartingDatetime(v)
		return nil
	case promotions.FieldEndingDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndingDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Promotions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotions.FieldDeletedAt) {
		fields = append(fields, promotions.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionsMutation) ClearField(name string) error {
	switch name {
	case promotions.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Promotions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionsMutation) ResetField(name string) error {
	switch name {
	case promotions.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotions.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotions.FieldName:
		m.ResetName()
		return nil
	case promotions.FieldStartingDatetime:
		m.ResetStartingDatetime()
		return nil
	case promotions.FieldEndingDatetime:
		m.ResetEndingDatetime()
		return nil
	}
	return fmt.Errorf("unknown Promotions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.promotion_has_product != nil {
		edges = append(edges, promotions.EdgePromotionHasProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotions.EdgePromotionHasProduct:
		ids := make([]ent.Value, 0, len(m.promotion_has_product))
		for id := range m.promotion_has_product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpromotion_has_product != nil {
		edges = append(edges, promotions.EdgePromotionHasProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotions.EdgePromotionHasProduct:
		ids := make([]ent.Value, 0, len(m.removedpromotion_has_product))
		for id := range m.removedpromotion_has_product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpromotion_has_product {
		edges = append(edges, promotions.EdgePromotionHasProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionsMutation) EdgeCleared(name string) bool {
	switch name {
	case promotions.EdgePromotionHasProduct:
		return m.clearedpromotion_has_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Promotions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionsMutation) ResetEdge(name string) error {
	switch name {
	case promotions.EdgePromotionHasProduct:
		m.ResetPromotionHasProduct()
		return nil
	}
	return fmt.Errorf("unknown Promotions edge %s", name)
}

// ReferenceSourcesMutation represents an operation that mutates the ReferenceSources nodes in the graph.
type ReferenceSourcesMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	deleted_at                *time.Time
	name                      *string
	clearedFields             map[string]struct{}
	product_references        map[int]struct{}
	removedproduct_references map[int]struct{}
	clearedproduct_references bool
	done                      bool
	oldValue                  func(context.Context) (*ReferenceSources, error)
	predicates                []predicate.ReferenceSources
}

var _ ent.Mutation = (*ReferenceSourcesMutation)(nil)

// referencesourcesOption allows management of the mutation configuration using functional options.
type referencesourcesOption func(*ReferenceSourcesMutation)

// newReferenceSourcesMutation creates new mutation for the ReferenceSources entity.
func newReferenceSourcesMutation(c config, op Op, opts ...referencesourcesOption) *ReferenceSourcesMutation {
	m := &ReferenceSourcesMutation{
		config:        c,
		op:            op,
		typ:           TypeReferenceSources,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferenceSourcesID sets the ID field of the mutation.
func withReferenceSourcesID(id int) referencesourcesOption {
	return func(m *ReferenceSourcesMutation) {
		var (
			err   error
			once  sync.Once
			value *ReferenceSources
		)
		m.oldValue = func(ctx context.Context) (*ReferenceSources, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReferenceSources.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferenceSources sets the old ReferenceSources of the mutation.
func withReferenceSources(node *ReferenceSources) referencesourcesOption {
	return func(m *ReferenceSourcesMutation) {
		m.oldValue = func(context.Context) (*ReferenceSources, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferenceSourcesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferenceSourcesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReferenceSourcesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReferenceSourcesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReferenceSources.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReferenceSourcesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReferenceSourcesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReferenceSources entity.
// If the ReferenceSources object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferenceSourcesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReferenceSourcesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReferenceSourcesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReferenceSourcesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ReferenceSources entity.
// If the ReferenceSources object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferenceSourcesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReferenceSourcesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[referencesources.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReferenceSourcesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[referencesources.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReferenceSourcesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, referencesources.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ReferenceSourcesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReferenceSourcesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReferenceSources entity.
// If the ReferenceSources object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferenceSourcesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReferenceSourcesMutation) ResetName() {
	m.name = nil
}

// AddProductReferenceIDs adds the "product_references" edge to the ProductReferences entity by ids.
func (m *ReferenceSourcesMutation) AddProductReferenceIDs(ids ...int) {
	if m.product_references == nil {
		m.product_references = make(map[int]struct{})
	}
	for i := range ids {
		m.product_references[ids[i]] = struct{}{}
	}
}

// ClearProductReferences clears the "product_references" edge to the ProductReferences entity.
func (m *ReferenceSourcesMutation) ClearProductReferences() {
	m.clearedproduct_references = true
}

// ProductReferencesCleared reports if the "product_references" edge to the ProductReferences entity was cleared.
func (m *ReferenceSourcesMutation) ProductReferencesCleared() bool {
	return m.clearedproduct_references
}

// RemoveProductReferenceIDs removes the "product_references" edge to the ProductReferences entity by IDs.
func (m *ReferenceSourcesMutation) RemoveProductReferenceIDs(ids ...int) {
	if m.removedproduct_references == nil {
		m.removedproduct_references = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_references, ids[i])
		m.removedproduct_references[ids[i]] = struct{}{}
	}
}

// RemovedProductReferences returns the removed IDs of the "product_references" edge to the ProductReferences entity.
func (m *ReferenceSourcesMutation) RemovedProductReferencesIDs() (ids []int) {
	for id := range m.removedproduct_references {
		ids = append(ids, id)
	}
	return
}

// ProductReferencesIDs returns the "product_references" edge IDs in the mutation.
func (m *ReferenceSourcesMutation) ProductReferencesIDs() (ids []int) {
	for id := range m.product_references {
		ids = append(ids, id)
	}
	return
}

// ResetProductReferences resets all changes to the "product_references" edge.
func (m *ReferenceSourcesMutation) ResetProductReferences() {
	m.product_references = nil
	m.clearedproduct_references = false
	m.removedproduct_references = nil
}

// Where appends a list predicates to the ReferenceSourcesMutation builder.
func (m *ReferenceSourcesMutation) Where(ps ...predicate.ReferenceSources) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReferenceSourcesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReferenceSourcesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReferenceSources, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReferenceSourcesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReferenceSourcesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReferenceSources).
func (m *ReferenceSourcesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReferenceSourcesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, referencesources.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, referencesources.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, referencesources.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReferenceSourcesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case referencesources.FieldCreatedAt:
		return m.CreatedAt()
	case referencesources.FieldDeletedAt:
		return m.DeletedAt()
	case referencesources.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReferenceSourcesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case referencesources.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case referencesources.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case referencesources.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ReferenceSources field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferenceSourcesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case referencesources.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case referencesources.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case referencesources.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ReferenceSources field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReferenceSourcesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReferenceSourcesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferenceSourcesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReferenceSources numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReferenceSourcesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(referencesources.FieldDeletedAt) {
		fields = append(fields, referencesources.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReferenceSourcesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferenceSourcesMutation) ClearField(name string) error {
	switch name {
	case referencesources.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ReferenceSources nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReferenceSourcesMutation) ResetField(name string) error {
	switch name {
	case referencesources.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case referencesources.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case referencesources.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ReferenceSources field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReferenceSourcesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_references != nil {
		edges = append(edges, referencesources.EdgeProductReferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReferenceSourcesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case referencesources.EdgeProductReferences:
		ids := make([]ent.Value, 0, len(m.product_references))
		for id := range m.product_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReferenceSourcesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_references != nil {
		edges = append(edges, referencesources.EdgeProductReferences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReferenceSourcesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case referencesources.EdgeProductReferences:
		ids := make([]ent.Value, 0, len(m.removedproduct_references))
		for id := range m.removedproduct_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReferenceSourcesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_references {
		edges = append(edges, referencesources.EdgeProductReferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReferenceSourcesMutation) EdgeCleared(name string) bool {
	switch name {
	case referencesources.EdgeProductReferences:
		return m.clearedproduct_references
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReferenceSourcesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ReferenceSources unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReferenceSourcesMutation) ResetEdge(name string) error {
	switch name {
	case referencesources.EdgeProductReferences:
		m.ResetProductReferences()
		return nil
	}
	return fmt.Errorf("unknown ReferenceSources edge %s", name)
}

// ToolHasProductMutation represents an operation that mutates the ToolHasProduct nodes in the graph.
type ToolHasProductMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	products        *int
	clearedproducts bool
	tools           *int
	clearedtools    bool
	done            bool
	oldValue        func(context.Context) (*ToolHasProduct, error)
	predicates      []predicate.ToolHasProduct
}

var _ ent.Mutation = (*ToolHasProductMutation)(nil)

// toolhasproductOption allows management of the mutation configuration using functional options.
type toolhasproductOption func(*ToolHasProductMutation)

// newToolHasProductMutation creates new mutation for the ToolHasProduct entity.
func newToolHasProductMutation(c config, op Op, opts ...toolhasproductOption) *ToolHasProductMutation {
	m := &ToolHasProductMutation{
		config:        c,
		op:            op,
		typ:           TypeToolHasProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolHasProductID sets the ID field of the mutation.
func withToolHasProductID(id int) toolhasproductOption {
	return func(m *ToolHasProductMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolHasProduct
		)
		m.oldValue = func(ctx context.Context) (*ToolHasProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolHasProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolHasProduct sets the old ToolHasProduct of the mutation.
func withToolHasProduct(node *ToolHasProduct) toolhasproductOption {
	return func(m *ToolHasProductMutation) {
		m.oldValue = func(context.Context) (*ToolHasProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolHasProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolHasProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolHasProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolHasProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolHasProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolHasProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolHasProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolHasProduct entity.
// If the ToolHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolHasProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolHasProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ToolHasProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ToolHasProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ToolHasProduct entity.
// If the ToolHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolHasProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ToolHasProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[toolhasproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ToolHasProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[toolhasproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ToolHasProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, toolhasproduct.FieldDeletedAt)
}

// SetProductsID sets the "products_id" field.
func (m *ToolHasProductMutation) SetProductsID(i int) {
	m.products = &i
}

// ProductsID returns the value of the "products_id" field in the mutation.
func (m *ToolHasProductMutation) ProductsID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductsID returns the old "products_id" field's value of the ToolHasProduct entity.
// If the ToolHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolHasProductMutation) OldProductsID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductsID: %w", err)
	}
	return oldValue.ProductsID, nil
}

// ClearProductsID clears the value of the "products_id" field.
func (m *ToolHasProductMutation) ClearProductsID() {
	m.products = nil
	m.clearedFields[toolhasproduct.FieldProductsID] = struct{}{}
}

// ProductsIDCleared returns if the "products_id" field was cleared in this mutation.
func (m *ToolHasProductMutation) ProductsIDCleared() bool {
	_, ok := m.clearedFields[toolhasproduct.FieldProductsID]
	return ok
}

// ResetProductsID resets all changes to the "products_id" field.
func (m *ToolHasProductMutation) ResetProductsID() {
	m.products = nil
	delete(m.clearedFields, toolhasproduct.FieldProductsID)
}

// SetToolsID sets the "tools_id" field.
func (m *ToolHasProductMutation) SetToolsID(i int) {
	m.tools = &i
}

// ToolsID returns the value of the "tools_id" field in the mutation.
func (m *ToolHasProductMutation) ToolsID() (r int, exists bool) {
	v := m.tools
	if v == nil {
		return
	}
	return *v, true
}

// OldToolsID returns the old "tools_id" field's value of the ToolHasProduct entity.
// If the ToolHasProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolHasProductMutation) OldToolsID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolsID: %w", err)
	}
	return oldValue.ToolsID, nil
}

// ClearToolsID clears the value of the "tools_id" field.
func (m *ToolHasProductMutation) ClearToolsID() {
	m.tools = nil
	m.clearedFields[toolhasproduct.FieldToolsID] = struct{}{}
}

// ToolsIDCleared returns if the "tools_id" field was cleared in this mutation.
func (m *ToolHasProductMutation) ToolsIDCleared() bool {
	_, ok := m.clearedFields[toolhasproduct.FieldToolsID]
	return ok
}

// ResetToolsID resets all changes to the "tools_id" field.
func (m *ToolHasProductMutation) ResetToolsID() {
	m.tools = nil
	delete(m.clearedFields, toolhasproduct.FieldToolsID)
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *ToolHasProductMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[toolhasproduct.FieldProductsID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *ToolHasProductMutation) ProductsCleared() bool {
	return m.ProductsIDCleared() || m.clearedproducts
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ToolHasProductMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ToolHasProductMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// ClearTools clears the "tools" edge to the Tools entity.
func (m *ToolHasProductMutation) ClearTools() {
	m.clearedtools = true
	m.clearedFields[toolhasproduct.FieldToolsID] = struct{}{}
}

// ToolsCleared reports if the "tools" edge to the Tools entity was cleared.
func (m *ToolHasProductMutation) ToolsCleared() bool {
	return m.ToolsIDCleared() || m.clearedtools
}

// ToolsIDs returns the "tools" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToolsID instead. It exists only for internal usage by the builders.
func (m *ToolHasProductMutation) ToolsIDs() (ids []int) {
	if id := m.tools; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTools resets all changes to the "tools" edge.
func (m *ToolHasProductMutation) ResetTools() {
	m.tools = nil
	m.clearedtools = false
}

// Where appends a list predicates to the ToolHasProductMutation builder.
func (m *ToolHasProductMutation) Where(ps ...predicate.ToolHasProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolHasProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolHasProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolHasProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolHasProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolHasProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolHasProduct).
func (m *ToolHasProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolHasProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, toolhasproduct.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, toolhasproduct.FieldDeletedAt)
	}
	if m.products != nil {
		fields = append(fields, toolhasproduct.FieldProductsID)
	}
	if m.tools != nil {
		fields = append(fields, toolhasproduct.FieldToolsID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolHasProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolhasproduct.FieldCreatedAt:
		return m.CreatedAt()
	case toolhasproduct.FieldDeletedAt:
		return m.DeletedAt()
	case toolhasproduct.FieldProductsID:
		return m.ProductsID()
	case toolhasproduct.FieldToolsID:
		return m.ToolsID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolHasProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolhasproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolhasproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case toolhasproduct.FieldProductsID:
		return m.OldProductsID(ctx)
	case toolhasproduct.FieldToolsID:
		return m.OldToolsID(ctx)
	}
	return nil, fmt.Errorf("unknown ToolHasProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolHasProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolhasproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolhasproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case toolhasproduct.FieldProductsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductsID(v)
		return nil
	case toolhasproduct.FieldToolsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolsID(v)
		return nil
	}
	return fmt.Errorf("unknown ToolHasProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolHasProductMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolHasProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolHasProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolHasProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolHasProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolhasproduct.FieldDeletedAt) {
		fields = append(fields, toolhasproduct.FieldDeletedAt)
	}
	if m.FieldCleared(toolhasproduct.FieldProductsID) {
		fields = append(fields, toolhasproduct.FieldProductsID)
	}
	if m.FieldCleared(toolhasproduct.FieldToolsID) {
		fields = append(fields, toolhasproduct.FieldToolsID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolHasProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolHasProductMutation) ClearField(name string) error {
	switch name {
	case toolhasproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case toolhasproduct.FieldProductsID:
		m.ClearProductsID()
		return nil
	case toolhasproduct.FieldToolsID:
		m.ClearToolsID()
		return nil
	}
	return fmt.Errorf("unknown ToolHasProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolHasProductMutation) ResetField(name string) error {
	switch name {
	case toolhasproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolhasproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case toolhasproduct.FieldProductsID:
		m.ResetProductsID()
		return nil
	case toolhasproduct.FieldToolsID:
		m.ResetToolsID()
		return nil
	}
	return fmt.Errorf("unknown ToolHasProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolHasProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, toolhasproduct.EdgeProducts)
	}
	if m.tools != nil {
		edges = append(edges, toolhasproduct.EdgeTools)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolHasProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toolhasproduct.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case toolhasproduct.EdgeTools:
		if id := m.tools; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolHasProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolHasProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolHasProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, toolhasproduct.EdgeProducts)
	}
	if m.clearedtools {
		edges = append(edges, toolhasproduct.EdgeTools)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolHasProductMutation) EdgeCleared(name string) bool {
	switch name {
	case toolhasproduct.EdgeProducts:
		return m.clearedproducts
	case toolhasproduct.EdgeTools:
		return m.clearedtools
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolHasProductMutation) ClearEdge(name string) error {
	switch name {
	case toolhasproduct.EdgeProducts:
		m.ClearProducts()
		return nil
	case toolhasproduct.EdgeTools:
		m.ClearTools()
		return nil
	}
	return fmt.Errorf("unknown ToolHasProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolHasProductMutation) ResetEdge(name string) error {
	switch name {
	case toolhasproduct.EdgeProducts:
		m.ResetProducts()
		return nil
	case toolhasproduct.EdgeTools:
		m.ResetTools()
		return nil
	}
	return fmt.Errorf("unknown ToolHasProduct edge %s", name)
}

// ToolsMutation represents an operation that mutates the Tools nodes in the graph.
type ToolsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	deleted_at              *time.Time
	name                    *string
	clearedFields           map[string]struct{}
	tool_has_product        map[int]struct{}
	removedtool_has_product map[int]struct{}
	clearedtool_has_product bool
	done                    bool
	oldValue                func(context.Context) (*Tools, error)
	predicates              []predicate.Tools
}

var _ ent.Mutation = (*ToolsMutation)(nil)

// toolsOption allows management of the mutation configuration using functional options.
type toolsOption func(*ToolsMutation)

// newToolsMutation creates new mutation for the Tools entity.
func newToolsMutation(c config, op Op, opts ...toolsOption) *ToolsMutation {
	m := &ToolsMutation{
		config:        c,
		op:            op,
		typ:           TypeTools,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolsID sets the ID field of the mutation.
func withToolsID(id int) toolsOption {
	return func(m *ToolsMutation) {
		var (
			err   error
			once  sync.Once
			value *Tools
		)
		m.oldValue = func(ctx context.Context) (*Tools, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tools.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTools sets the old Tools of the mutation.
func withTools(node *Tools) toolsOption {
	return func(m *ToolsMutation) {
		m.oldValue = func(context.Context) (*Tools, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tools.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tools entity.
// If the Tools object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ToolsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ToolsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tools entity.
// If the Tools object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ToolsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tools.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ToolsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tools.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ToolsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tools.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ToolsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ToolsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tools entity.
// If the Tools object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolsMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ToolsMutation) ResetName() {
	m.name = nil
}

// AddToolHasProductIDs adds the "tool_has_product" edge to the ToolHasProduct entity by ids.
func (m *ToolsMutation) AddToolHasProductIDs(ids ...int) {
	if m.tool_has_product == nil {
		m.tool_has_product = make(map[int]struct{})
	}
	for i := range ids {
		m.tool_has_product[ids[i]] = struct{}{}
	}
}

// ClearToolHasProduct clears the "tool_has_product" edge to the ToolHasProduct entity.
func (m *ToolsMutation) ClearToolHasProduct() {
	m.clearedtool_has_product = true
}

// ToolHasProductCleared reports if the "tool_has_product" edge to the ToolHasProduct entity was cleared.
func (m *ToolsMutation) ToolHasProductCleared() bool {
	return m.clearedtool_has_product
}

// RemoveToolHasProductIDs removes the "tool_has_product" edge to the ToolHasProduct entity by IDs.
func (m *ToolsMutation) RemoveToolHasProductIDs(ids ...int) {
	if m.removedtool_has_product == nil {
		m.removedtool_has_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tool_has_product, ids[i])
		m.removedtool_has_product[ids[i]] = struct{}{}
	}
}

// RemovedToolHasProduct returns the removed IDs of the "tool_has_product" edge to the ToolHasProduct entity.
func (m *ToolsMutation) RemovedToolHasProductIDs() (ids []int) {
	for id := range m.removedtool_has_product {
		ids = append(ids, id)
	}
	return
}

// ToolHasProductIDs returns the "tool_has_product" edge IDs in the mutation.
func (m *ToolsMutation) ToolHasProductIDs() (ids []int) {
	for id := range m.tool_has_product {
		ids = append(ids, id)
	}
	return
}

// ResetToolHasProduct resets all changes to the "tool_has_product" edge.
func (m *ToolsMutation) ResetToolHasProduct() {
	m.tool_has_product = nil
	m.clearedtool_has_product = false
	m.removedtool_has_product = nil
}

// Where appends a list predicates to the ToolsMutation builder.
func (m *ToolsMutation) Where(ps ...predicate.Tools) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tools, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tools).
func (m *ToolsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, tools.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tools.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tools.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tools.FieldCreatedAt:
		return m.CreatedAt()
	case tools.FieldDeletedAt:
		return m.DeletedAt()
	case tools.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tools.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tools.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tools.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tools field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tools.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tools.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tools.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tools field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tools numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tools.FieldDeletedAt) {
		fields = append(fields, tools.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolsMutation) ClearField(name string) error {
	switch name {
	case tools.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Tools nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolsMutation) ResetField(name string) error {
	switch name {
	case tools.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tools.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tools.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tools field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tool_has_product != nil {
		edges = append(edges, tools.EdgeToolHasProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tools.EdgeToolHasProduct:
		ids := make([]ent.Value, 0, len(m.tool_has_product))
		for id := range m.tool_has_product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtool_has_product != nil {
		edges = append(edges, tools.EdgeToolHasProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tools.EdgeToolHasProduct:
		ids := make([]ent.Value, 0, len(m.removedtool_has_product))
		for id := range m.removedtool_has_product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtool_has_product {
		edges = append(edges, tools.EdgeToolHasProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolsMutation) EdgeCleared(name string) bool {
	switch name {
	case tools.EdgeToolHasProduct:
		return m.clearedtool_has_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tools unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolsMutation) ResetEdge(name string) error {
	switch name {
	case tools.EdgeToolHasProduct:
		m.ResetToolHasProduct()
		return nil
	}
	return fmt.Errorf("unknown Tools edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	deleted_at              *time.Time
	name                    *string
	_Surname                *string
	clearedFields           map[string]struct{}
	products                map[int]struct{}
	removedproducts         map[int]struct{}
	clearedproducts         bool
	created_products        map[int]struct{}
	removedcreated_products map[int]struct{}
	clearedcreated_products bool
	updated_products        map[int]struct{}
	removedupdated_products map[int]struct{}
	clearedupdated_products bool
	deleted_products        map[int]struct{}
	removeddeleted_products map[int]struct{}
	cleareddeleted_products bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSurname sets the "Surname" field.
func (m *UserMutation) SetSurname(s string) {
	m._Surname = &s
}

// Surname returns the value of the "Surname" field in the mutation.
func (m *UserMutation) Surname() (r string, exists bool) {
	v := m._Surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "Surname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ResetSurname resets all changes to the "Surname" field.
func (m *UserMutation) ResetSurname() {
	m._Surname = nil
}

// AddProductIDs adds the "products" edge to the Products entity by ids.
func (m *UserMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *UserMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *UserMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Products entity by IDs.
func (m *UserMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Products entity.
func (m *UserMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *UserMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *UserMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddCreatedProductIDs adds the "created_products" edge to the Products entity by ids.
func (m *UserMutation) AddCreatedProductIDs(ids ...int) {
	if m.created_products == nil {
		m.created_products = make(map[int]struct{})
	}
	for i := range ids {
		m.created_products[ids[i]] = struct{}{}
	}
}

// ClearCreatedProducts clears the "created_products" edge to the Products entity.
func (m *UserMutation) ClearCreatedProducts() {
	m.clearedcreated_products = true
}

// CreatedProductsCleared reports if the "created_products" edge to the Products entity was cleared.
func (m *UserMutation) CreatedProductsCleared() bool {
	return m.clearedcreated_products
}

// RemoveCreatedProductIDs removes the "created_products" edge to the Products entity by IDs.
func (m *UserMutation) RemoveCreatedProductIDs(ids ...int) {
	if m.removedcreated_products == nil {
		m.removedcreated_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_products, ids[i])
		m.removedcreated_products[ids[i]] = struct{}{}
	}
}

// RemovedCreatedProducts returns the removed IDs of the "created_products" edge to the Products entity.
func (m *UserMutation) RemovedCreatedProductsIDs() (ids []int) {
	for id := range m.removedcreated_products {
		ids = append(ids, id)
	}
	return
}

// CreatedProductsIDs returns the "created_products" edge IDs in the mutation.
func (m *UserMutation) CreatedProductsIDs() (ids []int) {
	for id := range m.created_products {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedProducts resets all changes to the "created_products" edge.
func (m *UserMutation) ResetCreatedProducts() {
	m.created_products = nil
	m.clearedcreated_products = false
	m.removedcreated_products = nil
}

// AddUpdatedProductIDs adds the "updated_products" edge to the Products entity by ids.
func (m *UserMutation) AddUpdatedProductIDs(ids ...int) {
	if m.updated_products == nil {
		m.updated_products = make(map[int]struct{})
	}
	for i := range ids {
		m.updated_products[ids[i]] = struct{}{}
	}
}

// ClearUpdatedProducts clears the "updated_products" edge to the Products entity.
func (m *UserMutation) ClearUpdatedProducts() {
	m.clearedupdated_products = true
}

// UpdatedProductsCleared reports if the "updated_products" edge to the Products entity was cleared.
func (m *UserMutation) UpdatedProductsCleared() bool {
	return m.clearedupdated_products
}

// RemoveUpdatedProductIDs removes the "updated_products" edge to the Products entity by IDs.
func (m *UserMutation) RemoveUpdatedProductIDs(ids ...int) {
	if m.removedupdated_products == nil {
		m.removedupdated_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updated_products, ids[i])
		m.removedupdated_products[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedProducts returns the removed IDs of the "updated_products" edge to the Products entity.
func (m *UserMutation) RemovedUpdatedProductsIDs() (ids []int) {
	for id := range m.removedupdated_products {
		ids = append(ids, id)
	}
	return
}

// UpdatedProductsIDs returns the "updated_products" edge IDs in the mutation.
func (m *UserMutation) UpdatedProductsIDs() (ids []int) {
	for id := range m.updated_products {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedProducts resets all changes to the "updated_products" edge.
func (m *UserMutation) ResetUpdatedProducts() {
	m.updated_products = nil
	m.clearedupdated_products = false
	m.removedupdated_products = nil
}

// AddDeletedProductIDs adds the "deleted_products" edge to the Products entity by ids.
func (m *UserMutation) AddDeletedProductIDs(ids ...int) {
	if m.deleted_products == nil {
		m.deleted_products = make(map[int]struct{})
	}
	for i := range ids {
		m.deleted_products[ids[i]] = struct{}{}
	}
}

// ClearDeletedProducts clears the "deleted_products" edge to the Products entity.
func (m *UserMutation) ClearDeletedProducts() {
	m.cleareddeleted_products = true
}

// DeletedProductsCleared reports if the "deleted_products" edge to the Products entity was cleared.
func (m *UserMutation) DeletedProductsCleared() bool {
	return m.cleareddeleted_products
}

// RemoveDeletedProductIDs removes the "deleted_products" edge to the Products entity by IDs.
func (m *UserMutation) RemoveDeletedProductIDs(ids ...int) {
	if m.removeddeleted_products == nil {
		m.removeddeleted_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deleted_products, ids[i])
		m.removeddeleted_products[ids[i]] = struct{}{}
	}
}

// RemovedDeletedProducts returns the removed IDs of the "deleted_products" edge to the Products entity.
func (m *UserMutation) RemovedDeletedProductsIDs() (ids []int) {
	for id := range m.removeddeleted_products {
		ids = append(ids, id)
	}
	return
}

// DeletedProductsIDs returns the "deleted_products" edge IDs in the mutation.
func (m *UserMutation) DeletedProductsIDs() (ids []int) {
	for id := range m.deleted_products {
		ids = append(ids, id)
	}
	return
}

// ResetDeletedProducts resets all changes to the "deleted_products" edge.
func (m *UserMutation) ResetDeletedProducts() {
	m.deleted_products = nil
	m.cleareddeleted_products = false
	m.removeddeleted_products = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Surname != nil {
		fields = append(fields, user.FieldSurname)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldSurname:
		return m.Surname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSurname:
		return m.OldSurname(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSurname:
		m.ResetSurname()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.products != nil {
		edges = append(edges, user.EdgeProducts)
	}
	if m.created_products != nil {
		edges = append(edges, user.EdgeCreatedProducts)
	}
	if m.updated_products != nil {
		edges = append(edges, user.EdgeUpdatedProducts)
	}
	if m.deleted_products != nil {
		edges = append(edges, user.EdgeDeletedProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProducts:
		ids := make([]ent.Value, 0, len(m.created_products))
		for id := range m.created_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedProducts:
		ids := make([]ent.Value, 0, len(m.updated_products))
		for id := range m.updated_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeletedProducts:
		ids := make([]ent.Value, 0, len(m.deleted_products))
		for id := range m.deleted_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproducts != nil {
		edges = append(edges, user.EdgeProducts)
	}
	if m.removedcreated_products != nil {
		edges = append(edges, user.EdgeCreatedProducts)
	}
	if m.removedupdated_products != nil {
		edges = append(edges, user.EdgeUpdatedProducts)
	}
	if m.removeddeleted_products != nil {
		edges = append(edges, user.EdgeDeletedProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProducts:
		ids := make([]ent.Value, 0, len(m.removedcreated_products))
		for id := range m.removedcreated_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedProducts:
		ids := make([]ent.Value, 0, len(m.removedupdated_products))
		for id := range m.removedupdated_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeletedProducts:
		ids := make([]ent.Value, 0, len(m.removeddeleted_products))
		for id := range m.removeddeleted_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproducts {
		edges = append(edges, user.EdgeProducts)
	}
	if m.clearedcreated_products {
		edges = append(edges, user.EdgeCreatedProducts)
	}
	if m.clearedupdated_products {
		edges = append(edges, user.EdgeUpdatedProducts)
	}
	if m.cleareddeleted_products {
		edges = append(edges, user.EdgeDeletedProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProducts:
		return m.clearedproducts
	case user.EdgeCreatedProducts:
		return m.clearedcreated_products
	case user.EdgeUpdatedProducts:
		return m.clearedupdated_products
	case user.EdgeDeletedProducts:
		return m.cleareddeleted_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProducts:
		m.ResetProducts()
		return nil
	case user.EdgeCreatedProducts:
		m.ResetCreatedProducts()
		return nil
	case user.EdgeUpdatedProducts:
		m.ResetUpdatedProducts()
		return nil
	case user.EdgeDeletedProducts:
		m.ResetDeletedProducts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VariantTypeMutation represents an operation that mutates the VariantType nodes in the graph.
type VariantTypeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	deleted_at      *time.Time
	name            *string
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*VariantType, error)
	predicates      []predicate.VariantType
}

var _ ent.Mutation = (*VariantTypeMutation)(nil)

// varianttypeOption allows management of the mutation configuration using functional options.
type varianttypeOption func(*VariantTypeMutation)

// newVariantTypeMutation creates new mutation for the VariantType entity.
func newVariantTypeMutation(c config, op Op, opts ...varianttypeOption) *VariantTypeMutation {
	m := &VariantTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeVariantType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariantTypeID sets the ID field of the mutation.
func withVariantTypeID(id int) varianttypeOption {
	return func(m *VariantTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *VariantType
		)
		m.oldValue = func(ctx context.Context) (*VariantType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VariantType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariantType sets the old VariantType of the mutation.
func withVariantType(node *VariantType) varianttypeOption {
	return func(m *VariantTypeMutation) {
		m.oldValue = func(context.Context) (*VariantType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariantTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariantTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VariantTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VariantTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VariantType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VariantTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VariantTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VariantType entity.
// If the VariantType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VariantTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VariantTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VariantTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VariantType entity.
// If the VariantType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VariantTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[varianttype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VariantTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[varianttype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VariantTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, varianttype.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *VariantTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VariantTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VariantType entity.
// If the VariantType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantTypeMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VariantTypeMutation) ResetName() {
	m.name = nil
}

// AddProductIDs adds the "products" edge to the Products entity by ids.
func (m *VariantTypeMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Products entity.
func (m *VariantTypeMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Products entity was cleared.
func (m *VariantTypeMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Products entity by IDs.
func (m *VariantTypeMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Products entity.
func (m *VariantTypeMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *VariantTypeMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *VariantTypeMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the VariantTypeMutation builder.
func (m *VariantTypeMutation) Where(ps ...predicate.VariantType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VariantTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VariantTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VariantType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VariantTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VariantTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VariantType).
func (m *VariantTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VariantTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, varianttype.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, varianttype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, varianttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VariantTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case varianttype.FieldCreatedAt:
		return m.CreatedAt()
	case varianttype.FieldDeletedAt:
		return m.DeletedAt()
	case varianttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VariantTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case varianttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case varianttype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case varianttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown VariantType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case varianttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case varianttype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case varianttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown VariantType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VariantTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VariantTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VariantType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VariantTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(varianttype.FieldDeletedAt) {
		fields = append(fields, varianttype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VariantTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariantTypeMutation) ClearField(name string) error {
	switch name {
	case varianttype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VariantType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VariantTypeMutation) ResetField(name string) error {
	switch name {
	case varianttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case varianttype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case varianttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown VariantType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VariantTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, varianttype.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VariantTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case varianttype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VariantTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, varianttype.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VariantTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case varianttype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VariantTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, varianttype.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VariantTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case varianttype.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VariantTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VariantType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VariantTypeMutation) ResetEdge(name string) error {
	switch name {
	case varianttype.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown VariantType edge %s", name)
}
